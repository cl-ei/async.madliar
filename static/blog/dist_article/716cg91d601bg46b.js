window.articleList={
"20150423": {
"create_time": "2015年4月23日",
"id": 20150423,
"content": "##什么是引用？\n　　通俗来讲，引用是一个名称，它可以指作一个对象的别名。引用分为两种：lvalue引用和rvalue引用。\n\n　　lvalue引用是一个变量的别名，它可以出现在一个赋值语句的左边，处于一个持久存储的位置。需要注意的是，lvalue引用是一个别名而不是指针，我们可以重新给指针赋值而使它（指针）指向另一个对象，但引用不可以这么做，我们不能修改它使其指向另一个对象。我们在声明引用时，就必须指出对应的变量，并且自始至终都不能改变。rvalue引用也作为变量的别名，但它也能引用rvalue，lvalue引用却不可以。\n\n##使用lvalue引用\n　　可以通过下列方式声明lvalue引用：\n\n\t\tlong Sum(0L);\n\t\tlong & refSum(sum);\n\n　　上述第一句是使用函数表示法来声明一个初始值为0的长整形变量，在字面值后面附加“L”指明此值为long型变量，如不指定则默认为int型。如果不添加“L”后缀，则可能发生隐式的类型转换，即：int型的字面值转换为long型后再赋予Sum，显然，标准的用法可以避免某些危险的情况发生，因此建议添加后缀“L”。也有人写小写的“l”，虽然可以达到相同的效果，但它容易与数字1混淆。\n\n　　第二句是声明一个可以替代原变量名“Sum”的引用，引用符“&”出现在类型名称“long”的后面、变量名refSum的前面，表明这是一个lvalue引用。现在，可以用refSum代替原来的变量名Sum。运行下面的程序：\n\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tlong Sum(0L);\n\t\t\tlong & refSum(Sum);\n\n\t\t\trefSum = 10;\n\n\t\t\tcout<<Sum\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出结果“10”。与使用指针所不同的是，使用指针必须解除引用才能参与到表达式中，用来访问变量的是指针的地址，而lvalue引用完全等价于被引用的变量。\n\n　　需要注意的是，如果这样定义：```int & refData = 10;```是不能通过编译的，因为字面值是常数而不能改变，为了保持常量值完整性，需要作出如下改变：```const int & refData = 10;```。这样，使用refData和使用字面值10可以达到相同的作用，但这意味着我们不能给refData重新赋值，因为它已经是一个常量。\n\n##使用rvalue引用\n　　使用两个引用符号“&&”来定义一个rvalue引用。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tlong Sum(10L);\n\n\t\t\tlong && refExp(2*Sum+3);\t\t\t\n\n\t\t\tcout<<refExp\n\t\t\t\t<<endl;\n\t\t}\n\t\t\n　　程序输出：23。这恰好是2*Sum+3的结果。这里虽然编译通过并执行，但实际上不是rvalue的引用方式，一般也不会这么用。这两种引用的主要用途是定义可能具有巨大值得函数，将在后面章节详细叙述。\n\n",
"layout": "post",
"title": "学习C++之二：使用引用",
"category": "学习笔记",
"description": "使用C++中类似指针的一种功能",
"preview": "通俗来讲，引用是一个名称，它可以指作一个对象的别名。引用分为两种：lvalue引用和rvalue引用。\n\n　　lvalue引用是一个变量的别名，它可以出现在一个赋值语句的左边，处于一个持久存储的位置。需要注意的是，lvalue引用是一个别名而不是指针，我们可以重新给指针赋值而使它（指针）指向另一个对象，但引用不可以这么做，我们不能修改它使其指向另一个对象。我们在声明引用时，就必须指出对应的变量，并且自始至终都不能改变。rvalue引用也作为变量的别名，但它也能引用rvalue，lvalue引用却不可以。\n\n##使用lvalue引用\n　　可以通过下列方式声明lvalue引用：\n\n\t\tlong Sum(0L);\n\t\tlong & refSum(sum);\n\n　　上述第一句是使用函数表示法来声明一个初始值为0的长整形变量，在字面值后面附加“L”指明此值为long型变量，如不指定则默认为int型。如果不添加“L”后缀，则可能发生隐式的类型转换，即：int型的字面值转换为long型后再赋予Sum，显然，标准的用法可以避免某些危险的情况发生，因此建议添加后缀“L”。也有人写小写的“l”，虽然可以达到相同的效果，但它容易与数字1混淆。\n\n　　第二句是声明一个可以替代原变量名“Sum”的引用，引用符“&”出现在类型名称“long”的后面、变量名refSum的前面，表明这是一个lvalue引用。现在，可以用refSum代替原来的变量名Sum。运行下面的程序：\n\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tlong Sum(0L);\n\t\t\tlong & refSum(Sum);\n\n\t\t\trefSum = 10;\n\n\t\t\tcout<<Sum\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出结果“10”。与使用指针所不同的是，使用指针必须解除引用才能参与到表达式中，用来访问变量的是指针的地址，而lvalue引用完全等价于被引用的变量。\n\n　　需要注意的是，如果这样定义：```int & refData = 10;```是不能通过编译的，因为字面值是常数而不能改变，为了保持常量值完整性，需要作出如下改变：```const int & refData = 10;```。这样，使用refData和使用字面值10可以达到相同的作用，但这意味着我们不能给refData重新赋值，因为它已经是一个常量。\n\n##使用rvalue引用\n　　使用两个引用符号“&&”来定义一个rvalue引用。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tlong Sum(10L);\n\n\t\t\tlong && refExp(2*Sum+3);\t\t\t\n\n\t\t\tcout<<refExp\n\t\t\t\t<<endl;\n\t\t}\n\t\t\n　　程序输出：23。这恰好是2*Sum+3的结果。这里虽然编译通过并执行，但实际上不是rvalue的引用方式，一般也不会这么用。这两种引用的主要用途是定义可能具有巨大值得函数，将在后面章节详细叙述。\n\n",
"first_figure": "/static/blog/img/preview_1.jpg"
},
"20170127": {
"create_time": "2017年1月27日",
"id": 20170127,
"content": "<img   src=\"/static/blog/img/blog/20170127/0.jpg\" style=\"width: 100%\">\n　　\n\n我躺在路的中央\n\n举起脚\n\n踩在天上\n\n我想我是醉了\n\n却清楚的看到，\n\n思念的来路，和梦的去处。\n\n<span style=\"float: right;margin-right:20%;\">——慕容引刀</span>\n\n\n　　\n",
"title": "诗和远方",
"category": "观点",
"tags": [
"诗和远方"
],
"preview": "我躺在路的中央\n\n举起脚\n\n踩在天上\n\n我想我是醉了\n\n却清楚的看到，\n\n思念的来路，和梦的去处。\n\n<span style=\"float: right;margin-right:20%;\">——慕容引刀</span>\n\n\n　　\n",
"first_figure": "/static/blog/img/blog/20170127/0.jpg"
},
"20160826": {
"create_time": "2016年8月26日",
"id": 20160826,
"content": " \n<img src=\"/static/blog/img/project/20160826/0.jpg\" style=\"width:100%;\"/>\n\n　　我打算在博客里添加上这些音乐。没有适合本页风格的js插件可以使用，所以手动实现了。\n<!--more-->\n\n　　最开始的那一版是初学js的时候做的，由于对js的不熟练，遇到问题了总是各种百度，导致最后逻辑混乱、jQuery和js原生方法胡乱交织一起，显得十分拙劣（虽然现在也很拙劣）。而最近对其进行了重新整理，较之前有一些改观，现在发布出来欢迎拍砖。\n\n## 一、简介\n\n　　这是一个无后台的简易的音乐播放器，点击这里查看全部代码<a target=\"_blank\" href=\"https://github.com/cl-ei/music_player\">https://github.com/cl-ei/music_player</a>。你可以按照下述方式把这个播放器嵌入到任意html中：\n\n```\n<iframe src=\"https://music.caoliang.net/ref/\"\n        frameborder=\"0\" \n        scrolling=\"no\"\n        marginheight=\"0\"\n        marginwidth=\"0\"     \n        width=\"350px\"  \n        height=\"150px\"\n        style=\" border: 1px solid #000;\">\n</iframe>\n```\n\n　　效果如下：\n<center>\n<iframe name=\"frame\" \n        src=\"https://music.caoliang.net/ref/\"\n        frameborder=\"0\" \n        scrolling=\"no\"\n        marginheight=\"0\"\n        marginwidth=\"0\"     \n        width=\"350px\"  \n        height=\"150px\"\n        style=\" border: 1px solid #000;\">\n</iframe>\n</center>\n\n　　如果你部署在自己的服务器上，将src替换为```src=\"/ref/index.html\"```。所有音乐存放在```/music```目录下，同时将音乐文件名写到```/ref/index.html```文件中的```<script>```标签里即可。如下：\n\n```\n<script type=\"text/javascript\">\nmusic_list = [\n    \"Nightingale - Yanni.mp3\",\n    \"暮色苍然 はちみつれもん.mp3\",\n    \"Comtine D'un Autre Ete L'apres Midi  Yann Tiersen.mp3\",\n    \"夜的钢琴曲(五) 石进.mp3\",\n    \"さよならの夏 手嶌葵.mp3\",\n    ... ...\n];\n</script>\n</body>\n```\n## 二、页面结构\n　　HTML页面主要分为两层。第一层是标题和按钮，第二层是列表和3个按钮。列表的滚动其实是调整margin-top属性，外加一个list_border的div将列表超出的部分隐藏掉。除了UI简陋以外，目前依然有很多做的不够好的地方，例如点击进度条不能直接将滑块置于点击位置、必须拖动，还有列表滑动不能支持触控等。这些希望以后慢慢改进。\n\n　　标题“CL's 疯言疯语”在最初是```<p>```标签，使用的是Microsoft YaHei UI Light字体，但很多电脑没有内置此字体，所以常会显示很low的宋体，偶尔会格式错乱，所以在后来改为了图片。但chrome浏览器对图片的缩放会使用优化算法处理图像的边缘，这使得字体边缘变得模糊，所以在chrome浏览器上的体验反而会更差。如下图，左右分别为chrome浏览器、Edge浏览器的效果。后续依然会解决这个问题。当然，欢迎高手告知我解决办法，不胜感激。\n\n![虚化](/static/blog/img/project/20160826/1.bmp)\n\n　　另外，有的网页背景音乐关不掉，每次一打开页面就会烦人的播放音乐，这是非常令人反感的。这里使用了三个cookie，分别记录播放位置和播放状态。如果第一次打开页面，它会自动播放第一首歌。而之后的一个月内再次打开页面，它会记录关闭前的状态，如果之前是暂停的，此时也会暂停；如果之前在播放，此时会断点续播。\n",
"layout": "post",
"title": "自己动手做极简风音乐播放器",
"category": "学习笔记",
"tags": [
"编程"
],
"preview": " \n我打算在博客里添加上这些音乐。没有适合本页风格的js插件可以使用，所以手动实现了。\n",
"first_figure": "/static/blog/img/preview_5.jpg"
},
"20161128": {
"create_time": "2016年11月28日",
"id": 20161128,
"content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n　　很久以前学校召开了一场电子设计大赛的经验交谈会。会上不知不觉聊到了大学教育体制、课程设置等问题，大家都畅所欲言，当时我也发表了自己的观点。我当然是讨厌那时的大学课堂的，认为即便课堂上传授的知识非常重要，也容易使人在枯燥无味的学习过程和应试体制中丧失兴趣和意志，从而迷失方向。\n\n　　我们是工科学生，课堂上讲了太多的公式、定理，分析了太多深入理论，而实践却少之又少，多少有些让人不耐烦。我们最大的问题是不知道学的东西能干什么，我的建议是尽量多的安排实验和设计课程，即使不能做出什么成果，但至少知道努力的方向。我打了个比方，我爸爸做饭总是先把所有的食材都准备好，然后再点火、下锅，不紧不慢的烹饪。而老妈却大不一样，直接放油烧锅，然后下主要食材，边炒边放葱姜蒜等佐料，结果一出锅还是老妈的香。我觉得大学应该借鉴这种“炒菜精神”，即便没有准备好，也可尝试一番，实践出真知。等把一切都准备好了，黄花菜也该凉了……\n<!--more-->\n　　而工作中发生过很多事都狠狠的扇了当初的自己几个耳光。它让人意识到，有很多事情是急不来的。处理它们必须有系统性的知识储备作为支撑，这样在面对一些隐蔽的问题的时候才能不去踩坑，软件开发就是这样。常常有人问我，做一个网站得多久？这个问题很好回答，如果你会点html和css，那么半天时间你就可以做一个至少能够访问的网站。而什么叫“会html”呢？有人说，我学了3年的html，也有人说，我半天就学会了。事实上，他们说的都对，但两者的质量肯定是不一样的。\n\n　　一个实际发生事：有一个需求，就是在某个网页的最上层呈现一个透明层用来绘制一些特效，但不能阻挡底层的元素。如果直接用一个div罩上，那整个页面的鼠标事件都被它截走了，页面无法操作，这显然不是想要的效果。为了解决这个问题，身边几个小伙都尝试了好久。他们不是专搞前端的，但JavaScript也都挺熟练，有个小伙更是写了2、300行代码来绕开这个问题，但最后还是达不到想要的效果。而这个棘手的问题，最终被一个前端工程师用了最简短的一句css解决了：“pointer-events： none”， 没有用到一行js。\n\n　　术业有专攻，因为有完整的知识体系，才能“专”。我以前也常对人说，如果要掌握一门编程语言的语法，几个小时足矣。但那也仅仅是语法而已，而不是编程方法。甚至，掌握基本语法都不够。比如下面的代码：\n\n```\ndefault_pos = get_default() # return: [ …… ]\npos = default_pos\n……\t# 做一些事情，pos的值发生改变\n\npos = default_pos # 将pos 置为默认值\n```\n\n在程序一开始保存了一个default_pos作为默认值，pos经过很多次运算，但最终再把它置回默认值。如果你运行了代码，也许你会惊讶：pos的值回不去了！因为default_pos的值发生了改变。全局没有一个地方来修改这个default_pos，它的值最后竟然变了！当然，也有人看到第二行时就知道发生什么事了。有的人一眼明白，而有的人即便被告知原因，也仍要思索一番。然而可怕的是，这种错误有的时候并不显而易见，比如下方的Python代码：\n```\n……\nsrc_list = get_list() # return： [ …… ]\ntotal_list = combine(src_list, ……) # 可能会把src_list原样返回，但很难觉察\n\nfor _ in total_list:\n    …… # 做一些事，但不会修改total_list\n    if ……：\n        del src_list[src_list.index(_)]\n\nsave(src_list)\n```\n按道理，for循环里一定能够遍历完total_list中的所有元素，并对其逐一做处理。但事实上却不是这样，某些元素没有做任何处理，直接跳到了下一次循环！你可能没有意识到，第二行的combine()函数可能原样返回src_list，然后total_list和src_list是同一个对象！所以灾难性的后果就发生了：在第8行可能删掉这个列表中的某个对象，然后要遍历的列表total_list发生改变、元素位置依次前移，而迭代器是不知情的，所以就遗漏了即将要遍历的这个元素——因为它往前移了。谁都知道在遍历一个list时不能对它改变，但在实际的语境中你很难觉察到你的所做所为，就像此例。\n\n　　错误谁都会犯，老手也是如此。而程序员不仅仅要能写代码，debug也是一项重要的能力。一旦bug出现了，专门深入的、系统性的学习过Python的人能够很快定位问题，而也许有些人甚至review好几遍代码都不能找到原因。 你想现学现卖，边学边实践，看起来像是做出了很多成果，但基础是极其不扎实的，一旦出现了问题就显得非常棘手。就如老妈做饭快，但这纯粹因为熟练，跟方式没有任何关系，如果规定以相同的时间炒菜，那依然会是老妈做的更香。很多时候，“快”只是一个表面现象，“快”的根本原因也可能在于，“先慢后快”。只有慢下来有了深厚的积淀，做事才能有条不紊、快而有序。\n\n　　我想以后再也不会对任何人说，多久就能学好XX、多久就能做出XX之类的话了。有些东西博大精深，需要一遍遍的学习和反复的推敲，不只是你看起来表面的样子。\n\n　　",
"layout": "post",
"title": "系统性学习的重要性",
"category": "观点",
"tags": [
"编程"
],
"preview": "很久以前学校召开了一场电子设计大赛的经验交谈会。会上不知不觉聊到了大学教育体制、课程设置等问题，大家都畅所欲言，当时我也发表了自己的观点。我当然是讨厌那时的大学课堂的，认为即便课堂上传授的知识非常重要，也容易使人在枯燥无味的学习过程和应试体制中丧失兴趣和意志，从而迷失方向。\n\n　　我们是工科学生，课堂上讲了太多的公式、定理，分析了太多深入理论，而实践却少之又少，多少有些让人不耐烦。我们最大的问题是不知道学的东西能干什么，我的建议是尽量多的安排实验和设计课程，即使不能做出什么成果，但至少知道努力的方向。我打了个比方，我爸爸做饭总是先把所有的食材都准备好，然后再点火、下锅，不紧不慢的烹饪。而老妈却大不一样，直接放油烧锅，然后下主要食材，边炒边放葱姜蒜等佐料，结果一出锅还是老妈的香。我觉得大学应该借鉴这种“炒菜精神”，即便没有准备好，也可尝试一番，实践出真知。等把一切都准备好了，黄花菜也该凉了……\n",
"first_figure": "/static/blog/img/project/20160811/0.jpg"
},
"20150712": {
"create_time": "2015年7月12日",
"id": 20150712,
"content": "![world](/static/blog/img/blog/20150712/2015071200.jpg)\n\n　　刚来学校报到那天，是我第一次离家几百公里来到一个完全陌生的地方。带我来的是表姐，她跟我一起从早上忙到下午，学校报到流程完了之后，帮我买了些生活用品。我们在学校食堂吃了顿饭，然后她就走了。我从宿舍楼的窗户上看她慢慢离开学校，心里异常的失落。\n<!--more-->\n　　有次舍友提议在宿舍里开一个小卖部，当时我们都信心满满要在大学里干一番轰轰烈烈的事业。我也自告奋勇的要求去北郊的一个食品批发市场进货。我孤身一人倒换了好几路公交车终于来到地图指示的地方，却发现这里既偏僻又荒凉。虽然有一辆辆三轮车忙碌的进出一个胡同，却始终没发现什么铺子或者存货的仓库。寻找了一个多小时却毫无收获，我彻底失望了，最终还是有些不甘心的踏上返程的公车。\n\n　　换车的时候，我在报刊亭买了罐冰封，就地在路边的石阶上坐了下来。喝着饮料，看着人们忙碌的来来往往，也许那情景有点像离家很远的孩子，落魄的在街头流浪。那刻感觉自己的存在其实是一种孤独。\n\n　　大二那年暑假，我邀请一个小女生组队参加了一个比赛。我经常去地下小吃城吃菠菜面，她也会陪在我一起。比赛第一天晚上，我通宵做作品，并没有给她分配任务，所以我让她回去睡觉，可她执意要在工作室陪我。不知我忙了多久，回头一看却发现她角落的桌上睡着了。我点了盘蚊香放在她身旁，看着她略带婴儿肥的小脸枕在瘦小的手臂上，安安静静睡去的样子，那刻真的很美好。\n\n　　她爱看恐怖电影，赛前训练的那段日子，晚上常常和我在那个冷清的比赛教室里看恐怖片。她的胆子比一般人大得多，看到惊恐的时刻我总是不自觉的去拉她的衣角，而她却淡定得像只猫。\n\n　　可比赛结束后，她不再跟我说话。给她发短信也不怎么搭理，约她出去玩也总是找借口拒绝。我反省倒底做错了什么的时候，却偶然看见她和一个陌生的男生牵手走在一起。原来，她有了男朋友。他和她从我面前走过，跟我挥手打招呼 ，我微笑着点头。我故意不去看他们的背影，转头的跟旁边的朋友说着话，显得有些语无伦次。他们并不知道，我是在极力地掩饰内心的孤独。\n\n　　近些日子因为临近期末，大家仿佛都无事可做，一群无聊的人聚集一起打起了扑克，也许这是他们能做的最不无聊的事情了。后来隔壁的舍友也加入了这个队伍。打牌的时候他们声嘶力竭的狂笑、摔着桌子和板凳，完全没有在意一旁无辜的人。我强忍着愤怒去操场上狂奔，最终疲惫不堪的倒在床上，而他们的欢乐依然在继续。\n\n　　我知道制止他们是不可能的。我戴上了耳机，音量调到最大，精疲力竭的躺在床板上听着音乐，迷迷糊糊的睡着。大概到了凌晨两三点，宿舍的灯早已熄了，台灯的电池也耗尽了，他们意犹未尽的散了。隔壁的人也回到了他们该去的地方。大家都躺在了床上，在一片呼噜声中，我却彻彻底底的失眠了。\n\n　　第二天中午，住在本地的室友都回到家里，寝室里就剩我和另外一人。他从床上爬起来，说，“他们都回家去了，我去网吧开黑你去不？” 烈日当头的天气，仿佛除了网吧再没有什么好的去处。\n\n　　“不去。” 我告诉他。\n\n　　过了好久，他说，“唉，都没人陪我，好孤独。”\n\n\n",
"layout": "post",
"title": "孤独",
"category": "观点",
"description": "也许孤独的人是可耻的",
"tags": [
"生活"
],
"preview": "![world](/static/blog/img/blog/20150712/2015071200.jpg)\n\n　　刚来学校报到那天，是我第一次离家几百公里来到一个完全陌生的地方。带我来的是表姐，她跟我一起从早上忙到下午，学校报到流程完了之后，帮我买了些生活用品。我们在学校食堂吃了顿饭，然后她就走了。我从宿舍楼的窗户上看她慢慢离开学校，心里异常的失落。\n",
"first_figure": "/static/blog/img/preview_2.jpg"
},
"20150710": {
"create_time": "2015年7月10日",
"id": 20150710,
"content": "![raspberrypi](/static/blog/img/project/20150710/2015071000.jpg)\n\n　　树莓派拥有一组用户定义的GPIO，通过它可以收集传感器数据、驱动电机等等，各种异想天开的小发明少了它都无法实现。下面简单分析一下如何用树莓派的GPIO来驱动直流电机。\n<!--more-->\n　　我记得在很小的时候，老爸给我买了一个播放磁带的单放机，那机器里面就有一个小电机驱动磁带、播放声音。但是那个时候的单放机都没有稳压电路，新买的电池插到机器里，磁带就转的很快，放出来的声音声调偏高。如果电池快没电了，磁带就转的很慢，播放出来的音乐声调又非常的低沉。如果粗心大意，将电池装反，那悲剧发生了：磁带反转，甚至会卡在机器里……\n\n　　虽然现在很难买到磁带机了，但通过这种现象可以总结出直流电机的两个特性，一是驱动电压越高，转速越快；二是驱动电压的极性如果调换，那电机旋转的方向也会逆转过来。\n\n　　树莓派驱动电机，是将树莓派的GPIO输出的信号放大后，加载到直流电机的两个输入端。树莓派的IO口可以单独输出高低电平，也就是正负电压，所以控制直流电机的正反转是相对容易的。但却无法让GPIO输出介于0V到3.3V之间的电压，所以不采取某些特殊措施的话，电机要么只能停住，要么就只能全速运行，很难实现调速。\n\n　　所谓特殊的措施，就是使用“脉冲宽度调制(Pulse Width Modulation,PWM)”技术来产生驱动信号。简单理解，就是使用一定占空比的方波信号来驱动电机，由于其频率较高，所以从宏观上看信号的有效电压值与占空比成一定关系：占空比越高，则等效的电压越高，当占空比为100%时，输出的电压为VCC，也就是3.3V。如图，蓝色为PWM信号，红色为等效的模拟信号。在误差可以接受的情况下，使用下面两种信号放大后来驱动电机，效果几乎是相同的。\n\n![raspberrypi](/static/blog/img//project/20150710/2015071002.jpg)\n\n　　不过可惜的是，官方阉割了第二代的树莓派的PWM功能，所以控制电机只能使用软件模拟产生PWM的方法，或者使用额外的控制器来协助控制电机。弄清了树莓派控制电机的原理，重点是如何搭建驱动电路，也就是放大树莓派IO引脚的信号的模块。虽然市面上可以买到各种直流电机的驱动模块，它们的核心是集成电机驱动芯片，使用方便，但它们并不能满足所有的需求，一来它们的售价比较昂贵，二来在不同的情况下，我们需要定制不同规模的驱动电路，小马拉大车或者大马拉小车总是不合适的。\n\n##最简单的电机驱动\n　　把它归结为第一类驱动，它的特点是：只能实现调速而不能改变电机转向，没有刹车功能。\n\n![raspberrypi](/static/blog/img//project/20150710/2015071003.png)\n\n　　此电机驱动的核心在于下方的MOS管。这里的MOS管为增强型N MOS管，它有三个电极，上方的为漏极D，左侧为栅极G，下方为源极S。不同型号的MOS管有不同的阈值电压，即栅极-源极电压，VGS。在实际电路中，栅极上的电压大于VGS的时候，MOS管导通，电流经过漏极、源极产生通路，电机开始转动。如果栅极电压低于VGS，则MOS管截止，整个电路不导通，电机失去动力。所以，只要PWM信号的高电平大于VGS，低电平小于VGS，则可以直接作为栅极的驱动信号来控制MOS管的导通与关断。\n\n##实现刹车\n　　其实只需要很少的改变就可以实现刹车功能。刹车就是使电机抱死、锁死，不允许它运转。如果采用第一种电机驱动，PWM信号处于低电平期间电机虽然失去动力，但依靠惯性仍然会继续转动。可以看到，电机一端固定至VCC，另一端却是悬空的。如果将悬空的引脚也接到VCC，则在电机的线圈间形成回路，电机依靠惯性转动时产生的反电动势会加载到自身，使电机产生反向转动的趋势，从而实现刹车。第二类的驱动可如下设计：\n\n![raspberrypi](/static/blog/img//project/20150710/2015071004.png)\n\n　　这里增加了一个PMOS管。PMOS管倒着放置在电路图中，上方是源极S，下方是漏极D，左侧为栅极G。与NMOS不同的是，PMOS管的源极接入高电平，阈值电压VGS为负值，栅极与源极的电压差（栅-源电压）也为负值。当栅-源电压的绝对值大于阈值电压VGS的绝对值时，MOS管导通；小于VGS的绝对值时，MOS管截止。因此，输入的PWM信号为高电平时，上方的PMOS截止，下方的NMOS导通，电机左侧电平为低，右侧为高，开始运转；当PWM信号为低时，上方的PMOS导通，下方的NMOS截止，电机两侧都为高电平，因此刹车。\n\n　　但事实上，上面的电机驱动电路有着致命的危险和安全隐患。危险发生在下面两种情况之一：其一是PWM信号的高电平电压与电机驱动电压VCC相差较大，其二是PWM信号频率过高，这两种情况都会严重烧毁电路。第一点是因为，如果PWM信号的高电平电压，比电机驱动电压VCC减掉PMOS的阈值电压VGS的绝对值还要低，那么即使PWM为高电平，上方的PMOS管栅-源电压绝对值依然大于阈值电压VGS的绝对值，此时PMOS管无法关断，而下方的NMOS已经导通。所以，两个MOS管同时导通，强大的电流经过两个MOS管而造成短路，这是不允许的。其二是因为，NMOS和PMOS的制作工艺不同，MOS管切换关断或导通的状态需要一定的时间（通常为几十至几百纳秒）。当PWM信号由低电平跳变到高电平，有可能造成NMOS还没来得及关断而PMOS已经导通，或者PMOS还没来得及关断而NMOS已经导通的情况，此时强大的电流也会流过两个MOS管。但如果PWM信号频率较低，这种电流冲击频率也低，不会对电路造成严重损害，但PWM信号频率较高的话，两个MOS管就会反复遭受大电流冲击，因此将造成短路而引发事故。\n\n　　因此，改进型的驱动如下：\n\n![raspberrypi](/static/blog/img//project/20150710/2015071005.png)\n\n　　使用两路独立的PWM信号来控制左侧的半桥。注意到两路PWM信号的差别，当上方的PWM信号跳变为高电平时，PMOS截止，短暂的延时之后，下方的PWM信号才跳变到高电平，使下方的NMOS导通。同样在反过程中，也用类似的方法确保了其中一个MOS管有足够的时间关断，避免了电平的冲突。两路PWM信号相差的部分，被称之为死区。死区的的选取较为重要，若死区时间较短，则不能避免电平冲突，若时间较长，就会影响PWM信号的精确度。\n\n　　上面的电机驱动解决了MOS管不能同时关断、同时导通的问题，但仍然不能解决另外一个问题，那就是PWM信号的电平匹配问题。前面分析过，如果PWM信号高电平低于电机驱动电压VCC减去PMOS管的阈值电压VGS的绝对值，那不管PWM信号为高电平还是低电平，PMOS管都将无法关断。想要解决这个问题其实并不难，只要将PMOS也替换为NMOS，同时将PMOS对应的PWM信号翻转即可。\n\n![raspberrypi](/static/blog/img//project/20150710/2015071006.png)\n\n　　由于驱动电路中全部是NMOS管，只要PWM信号低电平小于VGS，高电平大于VGS，就不再有MOS管无法关断的问题。现在已经完美的解决了上述的两个问题。但付出的代价是，多使用了一路PWM波。这对于树莓派是致命的，因为二代的树莓派没有硬件PWM发生器，即使是一代的树莓派，也只有1路PWM输出。所以要输出两路互补带死区的PWM信号，必须借助其他的控制器了。笔者在这里强烈推荐德州仪器的MSP430系列微控制器，在多路PWM输出方面功能强大，配置起来也十分灵活。下面是MSP430数据手册中将其配置为“互补的带死区PWM输出模式”的部分截图：\n\n![raspberrypi](/static/blog/img//project/20150710/2015071007.png)\n\n##全H桥电机驱动\n　　有了的基础，想要理解全H桥电机驱动就容易多了。只需要将左边的半桥复制到右侧，这样整个电路如同一个“H”形，因此也被称为H桥。这样就可以实现刹车、调速、正反转的功能。\n\n![raspberrypi](/static/blog/img//project/20150710/2015071008.png)\n\n　　此时电机驱动就完美了，但为了保护微控制器的输出端口，常常使用光电耦合器来隔离强电和弱电区。光耦的使用方法较为简单，这里不再赘述。\n\n　　在广泛使用的各种集成电机驱动芯片中，H桥为基本构成部分，绝大多数直流电机驱动都建立在“H”桥的基础之上。而且“H”桥电路不仅仅用于电机的驱动，还常用于直流-交流变换的电路当中，这里仅仅对最基本的工作原理作出浅析。总之，它是一种应用非常广泛的电路，非常值得深入探究。",
"layout": "post",
"title": "树莓派之电机驱动",
"category": "学习笔记",
"description": "制作做机器人的第一步",
"tags": [
"编程",
"树莓派"
],
"preview": "![raspberrypi](/static/blog/img/project/20150710/2015071000.jpg)\n\n　　树莓派拥有一组用户定义的GPIO，通过它可以收集传感器数据、驱动电机等等，各种异想天开的小发明少了它都无法实现。下面简单分析一下如何用树莓派的GPIO来驱动直流电机。\n",
"first_figure": "/static/blog/img/preview_0.jpg"
},
"20161027": {
"create_time": "2016年10月27日",
"id": 20161027,
"content": "<img src=\"/static/blog/img/blog/20161027/0.jpg\" alt=\"money\" style=\"width:100%;\"/>\n\n　　虽然毕业也快半年了，但跟大学同学聚在一块聊天时总会有意无意聊到这个话题。\n其中有个刚从南方回来的同学。他觉得之前所做的嵌入开发的工作没有技术含量，成长空间狭窄，就辞职回了西安，但来到西安第一份工作更加坑爹。每天上班十几个小时，单休，甚至国庆7天法定假日公司都要克扣一天，任务重而薪水却不成正比。他问我，“你有考虑过自己单干吗？”\n<!--more-->\n\n　　“怎么单干？”\n\n　　“先在淘宝开家店，自己创业。边卖产品，边学习技术，然后……”\n\n　　“那你卖什么呢？”\n\n　　“很多东西啊，比如DIY的电机驱动板啊，还有……”\n\n　　“……”\n\n　　这么一说，让我想起了很多事情。这貌似是很多大学生创业的思路了，至少我所认识的人当中就有不少抱有这个想法。但我却是极力反对的。\n\n##创业不能光想着“能做什么”，更要考虑“做不到什么”\n\n　　“创业”这个词在我的心里是很神圣的，同样的还有“团队”。我所理解的创业，即使不如扎克伯格“让每一位社会公民以公共身份社交”而创业、乔布斯“为了改变世界”而创业那样报复远大，但也至少是为了改善某些令人不爽的社会状况、解决某些产品的用户痛点，为了做自己喜欢做的事而创业，就像DISCUZZ!和超级课程表一样，创始人都出身草根，但却真真抓住了某个市场的空档、把握住了用户需求，做出了一些大家真正需要的东西。但现在好多大学生摆地摊“创业”、送外卖“创业”、洗餐盘“创业”……每次他们自豪的介绍他们所谓的“团队”，我都深恶痛绝，简直把这几个神圣的词汇侮辱的一文不值，真的太low了。\n\n　　他们是真的热爱这份工作吗？如果哪个大学生愿意摆一辈子地摊，我就信了。很多人向往创业，但能力却不足以支撑起自己的梦想，怎么办？我能干的，就是摆地摊、送外卖了，先从这个干起吧，即使不成功这种经历也是一种历练。多么美好！是，王卫成功了，从一个快递小哥做到了快递一哥，但坦白的讲，你会是下一个王卫么？人们只是看到了一个跑腿送货的变成了商界领袖，却没有看到他对市场敏锐的洞察力、对企业强大的管控能力，周密的商业战略和布局，还有背后付出的不为人知的代价。整天送外卖，你能做到一个长安区份额第一么？做不到，那你就是一个送外卖的。做的到？拿出企划书、市场调研报告，聊聊未来三年的详细规划？还有怎么去融资、怎么在这种低端市场与他人竞争？不知道？拜托，那你还只是一个送外卖的。如果只是身体走在前面而大脑不去思考，那还不如躺下来睡大觉，至少身体不会觉得很累。\n\n##要找到自己的核心竞争力\n\n　　我们出来创业，是一定要盈利的，想挣钱的人多了去了，要在残酷的竞争下霸占一块市场，你必须有别人所不具备的东西才行。如果你做出来的东西，在大街上随随便便拉一个人也能做出来，那你的可替代性太强，这种创业是没有意义的。就好比街边卖煎饼果子的手推车小贩，他们天天对骂，而最后也不见得谁把谁比下去。有价值的东西得是你独有的，不管是品牌，还是渠道、技术，或者是其他的软硬件资源，别人接手不了，你才有可能活下来。退一步讲，如果你做出来的东西别人也能做，但你花了1一个月做出来，别人可能要花费1年才能做出来，那也是你的竞争力，否则天花板就在你可以预见的位置。\n\n　　有个同学给我看他的伙伴做的“自动快递柜”，就是一个用电子锁的机柜，快递员可以把包裹放在柜子里，然后发送密码给收件人，收件人来到柜子前输入密码解锁、取货，以节约快递小哥送货时间。\n\n　　他问我这个设计怎么样，我笑着给他看了一张照片：\n\n<img src=\"/static/blog/img/blog/20161027/1.jpg\" alt=\"money\" />\n\n　　这是京东的自提柜。我问了物业，这个柜子已经放在这里快三年了。这个柜子跟京东订单联网的，你输入密码能提货，还能投放一系列京东的营销广告、互动游戏等内容，比如取完货了抽个奖什么的，这应该是花费了非常多工程师的工时做出来的。仅仅凭一个刚刚毕业的大学生能做出这样的产品吗？也许可以，但我想耗费的时间可能几倍甚至几十倍于京东的承包公司吧。那哥们引以为傲的产品，粗制滥造，完完全全就是一个模型的存在。有意思的是，据说这哥们在众筹平台上还筹到了一笔不少的钱。我实在想不到如果不是为了炒作，谁会去给这种项目投钱，但我却是很期待这产品的后续。\n\n　　而那位同学提议开个淘宝店卖电机驱动板，所谓的电机驱动板其实就是大学生电子竞赛和机器人竞赛用的驱动板。至于功能性，一切为了比赛，它的受众面很小。巧的是，我之前在一个偶然的机会使用过一套松下公司的电机系统，那是一个完整的解决方案，范围覆盖了软件SDK、运动控制卡、电机驱动器和电机，甚至包括机械件，这一套系统需要用户插手配置的都非常少，极大节约了开发人员的时间。可以说，如果凭我一人之力，花费20年也打造不出来这样一套好用的系统，何况人家卖的还这么便宜，拿什么去跟人家竞争？真要创业，我们相当于凭几个人之力和一个有着千人级别研发团队的公司竞争，这可能吗？如果哪个企业要采购这一类产品，暂且不讨论制作工艺、功能性、专利壁垒，就算你做的产品和松下公司一样好，但谁敢采用一个没有任何工业认证、初创、售后都无法保障的公司做出的产品呢？\n\n　　做别人做过的东西，不能算自己的核心竞争力，何况你做出的东西不如人家的好、不如人家的便宜。这样的创业，不叫创业。\n\n##时间就是生命，我们没时间胡乱折腾了\n\n　　创业是令人向往的，但现实也是残酷的。除了干活、做你最想做的那部分工作之外，你也要洗衣烧饭、考虑生计，面对的压力更多。你选择创业的同时，也就放弃了你的生活。我们已经都是成年人了，二十多岁正是容光焕发的年华，你说要多闯闯、突破自我、做些疯狂的事没什么不对，毕竟等到上有老下有小的时候，背着一大家子的包袱，再也不会像现在这样轻松。说得没错，但还没有缜密的计划就要草率的做出影响未来几年甚至十几年的决定，这是不可取的。\n\n　　时间是最容易被忽视的东西。就如我同学说的，开个淘宝店边卖产品边学技术，这场景有点像某位大侠厌倦了江湖的打打杀杀而归隐田园，牧马放羊、与世无争，一切静谧而安好……但如果淘宝店真开起来，谁能边当客服边学习知识呢？看书看得正入神，客户发来消息，而你只能10秒内响应。怎么办？还有设计、生产、供应链、财务、物流……一系列的事情都要亲力亲为，哪还有时间去学习知识呢？如果你要组件团队、扩大规模来替你分担工作，即使不考虑资金，那制度和流程在哪里，怎么保证这一套体系包括人和资源都能正常运作起来？\n\n　　有的人在公司里积累项目经验，有的人在图书馆、在实验室汲取知识，这是没有干扰的学习状态。真开了淘宝店，怕就怕只有自己在电脑前一心二用、虚度光阴、自欺欺人了。我们已经二十多岁了，一个人平均寿命按75岁计算，如今我们都已度过了最宝贵的1/3。更别提老年了，谁都不会愿意到了老年还为了生计而奔波，而是更想种个小菜园没事了去河边钓钓鱼。都说生命在于折腾，可生命却禁不起折腾，我们每个决定都影响着今后的人生轨迹，不要再像小孩子一样说风就是雨、头脑一热就决定要做这做那。\n\n　　你可以热爱创业，但你却不能迷失方向。你可以热爱创业，却不能鄙视创业以外的生活方式。当你什么都不清楚、完全没有准备的情况下，做一个小小码农不好吗？写一行代码，就挣一行代码的工钱，这是一种畏畏缩缩的生活方式，同样也是一种踏踏实实的生活方式。在成熟的集体里，学习成熟的技术，这些东西也许是无数前人的智慧累加迭代、继承下来的，现在把这部分东西用你的思维将它完善再传承到下一届，何尝不是一件有意义的事情呢？\n\n　　最后你问我创不创业，我想，也许会的。但那应该是几年后，也许是几十年后，我想到那时不管是视野还是资源都不是现在的条件所能相提并论的。怀揣着对市场和未来的敬畏，用几年甚至更久的时间去筹备这件事，就算失败也至少不会比现在狼狈。最后，友情提示：创业有风险，创业需谨慎。",
"layout": "post",
"title": "关于创业",
"category": "观点",
"tags": [
"生活"
],
"preview": "虽然毕业也快半年了，但跟大学同学聚在一块聊天时总会有意无意聊到这个话题。\n其中有个刚从南方回来的同学。他觉得之前所做的嵌入开发的工作没有技术含量，成长空间狭窄，就辞职回了西安，但来到西安第一份工作更加坑爹。每天上班十几个小时，单休，甚至国庆7天法定假日公司都要克扣一天，任务重而薪水却不成正比。他问我，“你有考虑过自己单干吗？”\n",
"first_figure": "/static/blog/img/blog/20161027/0.jpg"
},
"20150121": {
"create_time": "2015年1月21日",
"id": 20150121,
"content": "\n## MySQL的运算符\n\n一、算术运算\n\n```\n+\t\t\t\n-\n*\n/ 或 DIV\t\t#除，若除数为0则返回NULL\n% 或 MOD\t\t\t#取余，MOD(12,3)相当于 12%3\n```\n\n\n二、比较运算符\n\n```\n=\t\t\t\t#等于返回1\n<> 或 !=\t\t#不等于返回1\n#上面两种运算符不能用于NULL的比较，操作数有NULL则返回NULL\n\n\n<=>\t\t\t\t#可用于NULL的比较\n\n<\n<=\n\n>\n>=\n\n#上面四种大小比较运算符不能用于NULL的比较，操作数有NULL则返回NULL\n\nBETWEEN\t\t\t#存在于指定范围\n#使用格式为 a BETWEEN min AND max; 判断时包含两端端点的值\n#当三个操作数类型相同，相当于 a>=min and a<=max\n\nIN\t\t\t\t#存在于指定集合\n#格式 a  in (var_1,var_2...) ; 列表中如果有a的值则返回1\n\nIS NULL\t\t\t\nIS NOT NULL\n\nLIKE\t\t\t#统配符匹配\n#格式 a LIKE %sub_str% ; 若a中含有sub_str则返回1\n#例如：select 'hello_world' like '%llo%' ; 结果为1\n\n\nREGEXP 或 RLIKE\t\t\t#正则表达式\n#格式 a REGEXP str_pat ;\n```\n三、逻辑运算符\n\n```\nNOT 或 !\n#操作数为0返回1，为非零返回0，为NULL 则返回 NOT NULL\n\nAND 或 &&\n#有NULL 返回 NULL ,有0返回0 , 全部非零返回1\n\nOR 或 ||\n#有1返回1,  没1有NULL返回NULL ,没1没NULL 返回0\n\nXOR \n#有NULL 返回NULL, 否则真假相同返回0，真假不同返回1\n```\n\n四、位运算符\n\n```\n&\n|\n^\t\t\t#位异或\n~\t\t\t#位取反\n\n>>\t\t\t#移入补0，移出丢弃\n<<\n```\n\n五、运算符的优先级\n运算符优先级```由低到高```：\n\n```\n:=\n||, OR, XOR\n&&, AND\nNOT\nBETWEEN, CASE, WHEN, THEN, ELSE\n=, <=>, >=, <=, <, >, !=, IS, LIKE, REGEXP, IN\n|\n&\n<<, >>\n-, +\n*, /, %\n^\t\t\t#位异或\n-, ~\t\t#一元减号和一元比特翻转\n!, NOT\n```",
"layout": "post",
"title": "MySQL(3):运算符",
"category": "学习笔记",
"description": "MySQL的运算符",
"tags": [
"MySQL"
],
"preview": "一、算术运算\n\n```\n+\t\t\t\n-\n*\n/ 或 DIV\t\t#除，若除数为0则返回NULL\n% 或 MOD\t\t\t#取余，MOD(12,3)相当于 12%3\n```\n\n\n二、比较运算符\n\n```\n=\t\t\t\t#等于返回1\n<> 或 !=\t\t#不等于返回1\n#上面两种运算符不能用于NULL的比较，操作数有NULL则返回NULL\n\n\n<=>\t\t\t\t#可用于NULL的比较\n\n<\n<=\n\n>\n>=\n\n#上面四种大小比较运算符不能用于NULL的比较，操作数有NULL则返回NULL\n\nBETWEEN\t\t\t#存在于指定范围\n#使用格式为 a BETWEEN min AND max; 判断时包含两端端点的值\n#当三个操作数类型相同，相当于 a>=min and a<=max\n\nIN\t\t\t\t#存在于指定集合\n#格式 a  in (var_1,var_2...) ; 列表中如果有a的值则返回1\n\nIS NULL\t\t\t\nIS NOT NULL\n\nLIKE\t\t\t#统配符匹配\n#格式 a LIKE %sub_str% ; 若a中含有sub_str则返回1\n#例如：select 'hello_world' like '%llo%' ; 结果为1\n\n\nREGEXP 或 RLIKE\t\t\t#正则表达式\n#格式 a REGEXP str_pat ;\n```\n三、逻辑运算符\n\n```\nNOT 或 !\n#操作数为0返回1，为非零返回0，为NULL 则返回 NOT NULL\n\nAND 或 &&\n#有NULL 返回 NULL ,有0返回0 , 全部非零返回1\n\nOR 或 ||\n#有1返回1,  没1有NULL返回NULL ,没1没NULL 返回0\n\nXOR \n#有NULL 返回NULL, 否则真假相同返回0，真假不同返回1\n```\n\n四、位运算符\n\n```\n&\n|\n^\t\t\t#位异或\n~\t\t\t#位取反\n\n>>\t\t\t#移入补0，移出丢弃\n<<\n```\n\n五、运算符的优先级\n运算符优先级```由低到高```：\n\n```\n:=\n||, OR, XOR\n&&, AND\nNOT\nBETWEEN, CASE, WHEN, THEN, ELSE\n=, <=>, >=, <=, <, >, !=, IS, LIKE, REGEXP, IN\n|\n&\n<<, >>\n-, +\n*, /, %\n^\t\t\t#位异或\n-, ~\t\t#一元减号和一元比特翻转\n!, NOT\n```",
"first_figure": "/static/blog/img/preview_0.jpg"
},
"20150110": {
"create_time": "2015年1月10日",
"id": 20150110,
"content": "\n## MySQL的常用操作\n\n1、DDL，数据定义语句\n\n定义数据段、数据库、表、列、索引等数据库对象。\n```\ncreate\ndrop\nalter\n```\n\n2、DML，数据操纵语句\n\n添加、删除、更新、查询。\n```\ninsert\ndelete\nupdate\nselect\n```\n3、DCL，数据控制控制\n\n定义安全和权限级别。\n```\ngrant\nrevoke\n```\n### 一、DDL\n\n1、查看数据库\n\n```\nSHOW DATABASES\n```\n\n2、查看表的列表\n\n```\nSHOW TABLES \nSHOW TABLES FROM db_name\n```\n\n3、创建数据库\n\n```\nCREATE DATABASE db_name\n```\n\n4、删除数据库\n\n```\nDROP DATABASE db_name\t\n```\n\n5、选择操作的数据库\n\n```\nUSE db_name\n```\n\n6、创建表\n\n```\nCREATE TABLE tb_name(\n\tcolumn_name_1\tcolumn_type_1\tconstraints,\n\t #项名称\t\t\t项数据类型\t\t约束条件\n\t ...\n\tcolumn_name_n\tcolumn_type_n\tconstraints\n)\n```\n\n7、查看表的定义(项目)\n\n```\nDESC tb_name\n```\n\n8、删除表\n\n```\nDROP TABLE tb_name\n```\n\n9、重定义表项类型\n\n```\nALTER TABLE tb_name MODIFY column column_define [FIRST / AFTER col_name]\t\t\n```\n\n例如：将表user_info的user_name列的数据类型改为varchar(20)\n\n```\nALTER TABLE user_info MODIFY user_name varchar(20)\n```\n\n10、增加表字段(项)\n\n```\nALTER TABLE tb_name ADD col_name col_define [ FIRST / AFTER col_name ]\n```\n\n例如：在表 user_info 的 user_name 项之后，增加一项 user_age\n\n```\nALTER TABLE user_info MODIFY user_age int(2) AFTER user_name\n```\n\n11、删除表字段(项)\n\n```\nALTER TABLE tb_name DROP col_name\n```\n\n12、字段更名\n\n```\nALTER TABLE tb_name CHANGE old_col_name new_col_name col_define\n```\n\n13、修改排序,参见“重定义表类型”\n\n只要表项的名称、定义为变，通过最后一个可选参数[FIRST / AFTER col_name]来指定顺序。\n\n```\nALTER TABLE tb_name MODIFY column column_define [FIRST / AFTER col_name]\n```\n14、更改表名称\n\n```\nALTER TABLE tb_name RENAME new_tb_name\n```\n\n### 二、DML\n\n1、查看记录\n\n```\nSELECT * FROM tb_name\n```\n\n2、插入记录\n\n(1)插入一行\n\n```\nINSERT INTO tb_name(field_1,field_2...) VALUES(var_1,var_2...) \n```\n\n例如，表main_info 插入一条记录。某些项允许为NULL时可以跳过。\n\n```\nINSERT INTO main_info(name,age,birthday) VALUES('caoliang',24,'1992-01-01');\n```\n\n不指定名称时，VALUES的序列要和表定义相匹配。\n如表main_info:\n\n```\nmysql> desc main_info;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| name     | varchar(10) | YES  |     | NULL    |       |\n| age      | int(2)      | YES  |     | NULL    |       |\n| birthday | date        | YES  |     | NULL    |       |\n| workyear | int(2)      | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n```\n\n可以使用：\n```\nINSERT INTO main_info VALUES('zhangsan',30,'1992-01-01',5);\n```\n\n(2)插入多行\n\n```\nINSERT INTO tb_name(field_1,field_2...) \nVALUES\n(recd_1_var_1,recd_1_var_2...),\n(recd_2_var_1,recd_2_var_2...),\n(recd_3_var_1,recd_3_var_2...),\n...\n```\n每一条记录值后面有逗号分隔。\n\n2、更新记录(更改记录的值)\n\n```\nUPDATE tb_name SET field_1=var_1,field_2=var_2 ... [ WHERE CONDITION]\n```\nWHERE CONDITION为更新的条件，如改变下面的数据库张三的id改为0\n\n```\nmysql> select * from main_info;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n| NULL | zhangsan |   30 | 1992-01-01 |        5 |\n|    1 | caoliang | NULL | 1993-01-01 |     NULL |\n+------+----------+------+------------+----------+\n\nmysql> update main_info set id=0 where name='zhangsan';\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> select * from main_info;                        \n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    0 | zhangsan |   30 | 1992-01-01 |        5 |\n|    1 | caoliang | NULL | 1993-01-01 |     NULL |\n+------+----------+------+------------+----------+\n```\n\nupdate 命令可以改变多条记录的值。例如：\n\n```\nUPDATE main_info addi_info SET main_info.id = addi_info.cxid WHERE main_info.age = 12\n```\n\n3、删除记录\n\n```\nDELETE FROM tb_name WHERE condition\n```\n\n如上面的数据库，删除张三：\n\n```\nDELETE a FROM main_info a WHERE a.name='zhangsan';\n```\n\na为main_info的别名。另外，如果不加附加条件去执行```DELETE FROM tb_name;```会清空整个表，此操作较为危险。\n\n\t\n\n\n\n\n\t\n",
"layout": "post",
"title": "MySQL(1):常用操作",
"category": "学习笔记",
"description": "MySQL的常用操作",
"tags": [
"MySQL"
],
"preview": "1、DDL，数据定义语句\n\n定义数据段、数据库、表、列、索引等数据库对象。\n```\ncreate\ndrop\nalter\n```\n\n2、DML，数据操纵语句\n\n添加、删除、更新、查询。\n```\ninsert\ndelete\nupdate\nselect\n```\n3、DCL，数据控制控制\n\n定义安全和权限级别。\n```\ngrant\nrevoke\n```\n### 一、DDL\n\n1、查看数据库\n\n```\nSHOW DATABASES\n```\n\n2、查看表的列表\n\n```\nSHOW TABLES \nSHOW TABLES FROM db_name\n```\n\n3、创建数据库\n\n```\nCREATE DATABASE db_name\n```\n\n4、删除数据库\n\n```\nDROP DATABASE db_name\t\n```\n\n5、选择操作的数据库\n\n```\nUSE db_name\n```\n\n6、创建表\n\n```\nCREATE TABLE tb_name(\n\tcolumn_name_1\tcolumn_type_1\tconstraints,\n\t #项名称\t\t\t项数据类型\t\t约束条件\n\t ...\n\tcolumn_name_n\tcolumn_type_n\tconstraints\n)\n```\n\n7、查看表的定义(项目)\n\n```\nDESC tb_name\n```\n\n8、删除表\n\n```\nDROP TABLE tb_name\n```\n\n9、重定义表项类型\n\n```\nALTER TABLE tb_name MODIFY column column_define [FIRST / AFTER col_name]\t\t\n```\n\n例如：将表user_info的user_name列的数据类型改为varchar(20)\n\n```\nALTER TABLE user_info MODIFY user_name varchar(20)\n```\n\n10、增加表字段(项)\n\n```\nALTER TABLE tb_name ADD col_name col_define [ FIRST / AFTER col_name ]\n```\n\n例如：在表 user_info 的 user_name 项之后，增加一项 user_age\n\n```\nALTER TABLE user_info MODIFY user_age int(2) AFTER user_name\n```\n\n11、删除表字段(项)\n\n```\nALTER TABLE tb_name DROP col_name\n```\n\n12、字段更名\n\n```\nALTER TABLE tb_name CHANGE old_col_name new_col_name col_define\n```\n\n13、修改排序,参见“重定义表类型”\n\n只要表项的名称、定义为变，通过最后一个可选参数[FIRST / AFTER col_name]来指定顺序。\n\n```\nALTER TABLE tb_name MODIFY column column_define [FIRST / AFTER col_name]\n```\n14、更改表名称\n\n```\nALTER TABLE tb_name RENAME new_tb_name\n```\n\n### 二、DML\n\n1、查看记录\n\n```\nSELECT * FROM tb_name\n```\n\n2、插入记录\n\n(1)插入一行\n\n```\nINSERT INTO tb_name(field_1,field_2...) VALUES(var_1,var_2...) \n```\n\n例如，表main_info 插入一条记录。某些项允许为NULL时可以跳过。\n\n```\nINSERT INTO main_info(name,age,birthday) VALUES('caoliang',24,'1992-01-01');\n```\n\n不指定名称时，VALUES的序列要和表定义相匹配。\n如表main_info:\n\n```\nmysql> desc main_info;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| name     | varchar(10) | YES  |     | NULL    |       |\n| age      | int(2)      | YES  |     | NULL    |       |\n| birthday | date        | YES  |     | NULL    |       |\n| workyear | int(2)      | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n```\n\n可以使用：\n```\nINSERT INTO main_info VALUES('zhangsan',30,'1992-01-01',5);\n```\n\n(2)插入多行\n\n```\nINSERT INTO tb_name(field_1,field_2...) \nVALUES\n(recd_1_var_1,recd_1_var_2...),\n(recd_2_var_1,recd_2_var_2...),\n(recd_3_var_1,recd_3_var_2...),\n...\n```\n每一条记录值后面有逗号分隔。\n\n2、更新记录(更改记录的值)\n\n```\nUPDATE tb_name SET field_1=var_1,field_2=var_2 ... [ WHERE CONDITION]\n```\nWHERE CONDITION为更新的条件，如改变下面的数据库张三的id改为0\n\n```\nmysql> select * from main_info;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n| NULL | zhangsan |   30 | 1992-01-01 |        5 |\n|    1 | caoliang | NULL | 1993-01-01 |     NULL |\n+------+----------+------+------------+----------+\n\nmysql> update main_info set id=0 where name='zhangsan';\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> select * from main_info;                        \n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    0 | zhangsan |   30 | 1992-01-01 |        5 |\n|    1 | caoliang | NULL | 1993-01-01 |     NULL |\n+------+----------+------+------------+----------+\n```\n\nupdate 命令可以改变多条记录的值。例如：\n\n```\nUPDATE main_info addi_info SET main_info.id = addi_info.cxid WHERE main_info.age = 12\n```\n\n3、删除记录\n\n```\nDELETE FROM tb_name WHERE condition\n```\n\n如上面的数据库，删除张三：\n\n```\nDELETE a FROM main_info a WHERE a.name='zhangsan';\n```\n\na为main_info的别名。另外，如果不加附加条件去执行```DELETE FROM tb_name;```会清空整个表，此操作较为危险。\n\n\t\n\n\n\n\n\t\n",
"first_figure": "/static/blog/img/preview_3.jpg"
},
"20150430": {
"create_time": "2015年4月30日",
"id": 20150430,
"content": "##函数重载的概念\n　　记得在编写ARM微处理器的串口发送信息、电脑显示的驱动程序时，遇到过一些麻烦。电脑端会把收到的所有数据都当做ASCII码来处理，因此，发送信息时，需要将整形数据、浮点型数等各种数据类型的信息转换为ASCII码。因此就需要编写很多转换的函数，比如将整形数转化为字符串的函数、将浮点数转换为字符串的函数……\n\n　　当然也有更简单的办法，比如只编写```putchar()```函数，然后通过移植stdio库，就可以把剩下的工作交给```printf()```来完成。但更多的时候，只是因为操作的数据类型不一样，我们就被迫去编写好几个本质上做相同事情的函数。比如，求两个整形数中的最大数 ```int maxInt(int a, int b)```、求两个double型数中的最大数```double maxDouble(double a, double b)``` ……我们在编写这组函数的时候，需要不停的发明新的名称，而且使用的时候还要有所选择，这简直让人难以忍受。\n\n　　有没有更好的办法呢？当然有，函数的重载就允许我们使用同一个名称来定义多个函数。可以以上面的原型来编写一组重载函数：\n\n\t\tint max(int a, int b);\n\t\tdouble max(double a,double b);\n\t\t... ...\n\n　　当我们需要求两个数中的最大数时，只需要调用```max()```函数就可以，而不再需要关注其他的事情。\n\n##不能编写重载函数的情况\n　　在C++编译的机制中，所有的函数都有签名，而且任何一个函数的签名都是唯一的。函数的签名由函数的名称和形参表来决定，如果通过函数名称和形参表不能区分两个函数，则程序不能通过编译。\n\n　　这也就意味着，我们不能通过返回值的类型来编写重载函数，比如：\n\n\t\tint max(int a, int b);\n\t\tdouble max(int a, int b);\n\n　　上面的函数不能通过编译。因为如果我们执行```auto a = max(x,y);```则函数不能确定究竟要返回哪种数据类型，这显然是很矛盾的事情。\n\n　　当使用引用形参来编写重载函数的时候，要确定编译器能选择一种合适的重载方式，否则无法编译。比如使用下面的代码，程序将不能编译：\n\n\t\tvoid fun(int n);\n\t\tvoid fun(int & refn);\n\n　　这是因为，当函数使用int型的形参来调用```fun()```时，这两个函数都适用，因此造成矛盾。\n\n##函数模板\n　　使用上述方法，可以使用一个函数名来编写不同的函数，使得这一组函数都可以做本质上相同的事，而不必纠结操作的数的类型。但是它还不够好，因为我们仍然需要针对不同的情况，重复编写本质上相似的代码。这时，我们可以编写一个函数的模板，在编译程序时，编译器就针对具体情况来生成需要的函数，这样我们只需要编写一次代码就可以做很多事情。正是因为引入了这一机制，代码的利用率大大提高。\n\n　　如下编写一个函数的模板：\n\n\t\ttemplate<typename T>\n\t\tT max(T a,T b)\n\t\t{\n\t\t\tif ( a < b) return b;\n\t\t\telse return a;\n\t\t}\n\n　　template关键字将后面的程序标示为模板定义，后面的尖括号包围着用来创建实例的形参类型，这里只有一个形参类型，被定义为T。T前面使用typename表明T是该模板的形参类型，也有人写class。因为class是定义类型的通用术语，定义类实质上也是在定义自己的数据类型。但使用typename更加倾向于用户定义的基本类型，因此也有很多人倾向于使用typename来定义形参类型。\n\n　　一旦这样定义，则在编译程序时，编译器就根据提供的具体类型的实参来替代T，来生成实例,这个过程称作实例化。如果调用```long temp = max(3L, 4L);```则会生成与之相应的函数：```long max(long a, long b){ ... ... };```。如果后面仅仅只使用了这个实例，则不会有新的类型的实例生成，比如没有使用```short max(short a, short b)```,就不会生成这个实例函数。这样一来，有时本可以通过强制类型转换来改变实参的类型，来适应已经生成的实例函数，避免生成新的实例函数从而增加代码的大小，但编译器却倾向于生成这种类型的实例，来避免强制类型转换。\n\n##decltype操作符\n　　使用decltype操作符可以得到一个表达式的类型。比如，有时函数的返回类型需要根据传入的实参的数据类型来确定，比如要求两个不同数类型的数的乘积，则要编写这样一个函数：\n\n\t\ttemplate<typename T1, typename T2>\n\t\tauto mul(T1 a,T2 b) -> decltype (a*b)\n\t\t{\n\t\t\treturn (a*b);\n\t\t}\n\n　　其中```auto func( ... ) -> return_type```是函数的拖尾声明方法，return_type是返回的数据类型，如果不使用decltype操作符，对于普通函数也可以这么做，例如``` int max(int a, int b)```也可以定义为```auto max(int a, int b) -> int```。因为此时不知道实参a和b的具体类型，也不知道(a*b)的具体类型，所以使用decltype操作符来指定函数的返回类型为(a*b)的类型。\n\n　　要注意的是，不可以直接这样定义函数mul：```decltype (a*b) mul(T1 a,T2 b) { ... }```,因为a和b在函数处理返回类型的时候尚未定义。使用decltype操作符也可以单独定义一个变量的类型，就向下面：\n\n\tdecltype (a*b) x = (a*b);\n\n　　则变量x的类型为(a*b)的类型，值为a与b的乘积。\n　　\n\n\n",
"layout": "post",
"title": "学习C++之七：函数的重载与函数模板",
"category": "学习笔记",
"description": "扩展函数功能的一种方式",
"preview": "记得在编写ARM微处理器的串口发送信息、电脑显示的驱动程序时，遇到过一些麻烦。电脑端会把收到的所有数据都当做ASCII码来处理，因此，发送信息时，需要将整形数据、浮点型数等各种数据类型的信息转换为ASCII码。因此就需要编写很多转换的函数，比如将整形数转化为字符串的函数、将浮点数转换为字符串的函数……\n\n　　当然也有更简单的办法，比如只编写```putchar()```函数，然后通过移植stdio库，就可以把剩下的工作交给```printf()```来完成。但更多的时候，只是因为操作的数据类型不一样，我们就被迫去编写好几个本质上做相同事情的函数。比如，求两个整形数中的最大数 ```int maxInt(int a, int b)```、求两个double型数中的最大数```double maxDouble(double a, double b)``` ……我们在编写这组函数的时候，需要不停的发明新的名称，而且使用的时候还要有所选择，这简直让人难以忍受。\n\n　　有没有更好的办法呢？当然有，函数的重载就允许我们使用同一个名称来定义多个函数。可以以上面的原型来编写一组重载函数：\n\n\t\tint max(int a, int b);\n\t\tdouble max(double a,double b);\n\t\t... ...\n\n　　当我们需要求两个数中的最大数时，只需要调用```max()```函数就可以，而不再需要关注其他的事情。\n\n##不能编写重载函数的情况\n　　在C++编译的机制中，所有的函数都有签名，而且任何一个函数的签名都是唯一的。函数的签名由函数的名称和形参表来决定，如果通过函数名称和形参表不能区分两个函数，则程序不能通过编译。\n\n　　这也就意味着，我们不能通过返回值的类型来编写重载函数，比如：\n\n\t\tint max(int a, int b);\n\t\tdouble max(int a, int b);\n\n　　上面的函数不能通过编译。因为如果我们执行```auto a = max(x,y);```则函数不能确定究竟要返回哪种数据类型，这显然是很矛盾的事情。\n\n　　当使用引用形参来编写重载函数的时候，要确定编译器能选择一种合适的重载方式，否则无法编译。比如使用下面的代码，程序将不能编译：\n\n\t\tvoid fun(int n);\n\t\tvoid fun(int & refn);\n\n　　这是因为，当函数使用int型的形参来调用```fun()```时，这两个函数都适用，因此造成矛盾。\n\n##函数模板\n　　使用上述方法，可以使用一个函数名来编写不同的函数，使得这一组函数都可以做本质上相同的事，而不必纠结操作的数的类型。但是它还不够好，因为我们仍然需要针对不同的情况，重复编写本质上相似的代码。这时，我们可以编写一个函数的模板，在编译程序时，编译器就针对具体情况来生成需要的函数，这样我们只需要编写一次代码就可以做很多事情。正是因为引入了这一机制，代码的利用率大大提高。\n\n　　如下编写一个函数的模板：\n\n\t\ttemplate<typename T>\n\t\tT max(T a,T b)\n\t\t{\n\t\t\tif ( a < b) return b;\n\t\t\telse return a;\n\t\t}\n\n　　template关键字将后面的程序标示为模板定义，后面的尖括号包围着用来创建实例的形参类型，这里只有一个形参类型，被定义为T。T前面使用typename表明T是该模板的形参类型，也有人写class。因为class是定义类型的通用术语，定义类实质上也是在定义自己的数据类型。但使用typename更加倾向于用户定义的基本类型，因此也有很多人倾向于使用typename来定义形参类型。\n\n　　一旦这样定义，则在编译程序时，编译器就根据提供的具体类型的实参来替代T，来生成实例,这个过程称作实例化。如果调用```long temp = max(3L, 4L);```则会生成与之相应的函数：```long max(long a, long b){ ... ... };```。如果后面仅仅只使用了这个实例，则不会有新的类型的实例生成，比如没有使用```short max(short a, short b)```,就不会生成这个实例函数。这样一来，有时本可以通过强制类型转换来改变实参的类型，来适应已经生成的实例函数，避免生成新的实例函数从而增加代码的大小，但编译器却倾向于生成这种类型的实例，来避免强制类型转换。\n\n##decltype操作符\n　　使用decltype操作符可以得到一个表达式的类型。比如，有时函数的返回类型需要根据传入的实参的数据类型来确定，比如要求两个不同数类型的数的乘积，则要编写这样一个函数：\n\n\t\ttemplate<typename T1, typename T2>\n\t\tauto mul(T1 a,T2 b) -> decltype (a*b)\n\t\t{\n\t\t\treturn (a*b);\n\t\t}\n\n　　其中```auto func( ... ) -> return_type```是函数的拖尾声明方法，return_type是返回的数据类型，如果不使用decltype操作符，对于普通函数也可以这么做，例如``` int max(int a, int b)```也可以定义为```auto max(int a, int b) -> int```。因为此时不知道实参a和b的具体类型，也不知道(a*b)的具体类型，所以使用decltype操作符来指定函数的返回类型为(a*b)的类型。\n\n　　要注意的是，不可以直接这样定义函数mul：```decltype (a*b) mul(T1 a,T2 b) { ... }```,因为a和b在函数处理返回类型的时候尚未定义。使用decltype操作符也可以单独定义一个变量的类型，就向下面：\n\n\tdecltype (a*b) x = (a*b);\n\n　　则变量x的类型为(a*b)的类型，值为a与b的乘积。\n　　\n\n\n",
"first_figure": "/static/blog/img/preview_4.jpg"
},
"20150419": {
"create_time": "2015年4月19日",
"id": 20150419,
"content": "##C++中的基本类型\n　　在C++中基本数据类型除了最常用的int型，还有占用字节数为1的bool、char型，占用2个字节的wchar_t、short型，占用4个字节的int、long、float型，还有占8个字节的long long、double和long double型。从下图可得知visual C++中各种基本类型变量所支持的值域。\n\n##bool类型\n　　bool类型的变量只具有两个值，为true或者false。在C++中引入bool类型之前，常用int型变量来表示逻辑0和逻辑1，此时数值0为真，非零为假。如果尝试输出true和false所代表的数值，可以看到true代表1，false代表0，这样就统一了逻辑真的表示（如果用非零整数来表示真，则可以使用各种各样的非零值，这有时是不利的）。\n\n　　在编译器中输入这两个值时，true和false显示为关键字。而TRUE和FALSE是MFC定义的符号，并不是关键字，也不是合法的bool值，因此不能混淆大小写。\n\n##类型的确定\n　　typeid操作符可以确定表达式的类型。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tbool n = true;\n\t\t\tfloat pi = 3.14;\t\t\t\n\n\t\t\tcout<<typeid(n).name()\n\t\t\t\t<<endl\n\t\t\t\t<<typeid(pi).name()\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序在第一行输出“bool”，在第二行输出“float”。typeid操作符产生的结果是一个对象，因此只可以按照上述操作方式来使用。在后述章节来详细学习这种操作方法。\n\n##auto关键字\n　　可以在变量定义时使用auto关键字作为变量的类型，如```auto n = 10;``` ``` auto pi = 3.14;```等，这种情况下，变量类型是根据字面值来确定的，这时n为int型，pi为float型。这也就意味着，每次给auto型变量定义时，就要为其赋予初始值，否则无法编译通过。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tauto e = 2.71828L;\t\t\t\n\n\t\t\tcout<<typeid(e).name()\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出“long double”，这是因为字面值2.71828的后面附加了L，代表此字面值的数据类型为long double型。\n\n##类型的转换　　\n　　C++中的计算只能在相同类型的值中进行，如果一个表达式中使用不同类型的变量，则编译器会把某个操作数的类型转换为与另一个操作数相匹配的数据类型之后再行计算。整个过程是隐式进行的，因此有时候将发生意想不到的效果。\n\n　　将一种类型的变量转换为另一种类型，有可能造成信息丢失。为了避免这种危险情况的发生，应该避免数据类型的转换，或者在确定数据类型转换不会发生危险时，执行转换。在任何时候，都要尽量避免使用编译器来自动安排类型转换，因为编译器不能完全知晓编程者的意图，所以在需要转换某个数据类型时，尽量使用显示的类型转换，也叫强制类型转换。\n\n　　老式的强制类型转换的操作方式是，在表达式之前使用圆括号来指明强制转换后的数据类型，如：``` int a = 0; float pi = 3.14f; a = (int) pi;``` 。这时，变量a的值为3，即pi的整数部分。\n\n　　实际上，强制类型转换有很多种不同的情况，但老式的强制类型转换涵盖了所有情况，所以更容易出错。因此，新的C++标准定义了新的数据类型转换：```static_cast<要转换的数据类型>(表达式)```。用static_cast关键字是指明此强制类型转换在编译时检查，同样还有dynamic_cast，指在执行程序的时候检查转换，另外还有删除const属性的const_cast等。执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tdouble f1=1.5;\n\t\t\tdouble f2=2.0;\n\t\t\tint number = static_cast<int>(f1) + static_cast<int>(f2);\n\n\t\t\tcout<<number\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出3,恰好是f1和f2的整数部分。\n\n##lvalue和rvalue\n　　C++中每个表达式的结果，都是“lvalue”和“rvalue”中的一种，它们以不同的形式存贮在的计算机的内存当中，通常也写作“l-value”或“r-value”。“l”代表“左”的英文“left”，是因为所有产生lvalue的表达式都可以出现在赋值语句“=”的左边，它的结果会放置在内存中持续存储。与之相反的是rvalue，它只会被临时存储。例如：\n\n\t\tint a(0), b(1), c(2);\n\t\ta = b + c ;\n\t\tb = ++a;\n\t\tc = a++;\n\n　　其中第一句是定义三个整形变量a、b、c，并赋予初始值。第二条语句中“b+c”的结果被临时存储在内存的一个区域中，它的结果是一个rvalue，当把它的值赋予a之后，存储“b+c”结果的内存位置便被丢弃。需要注意的是，第三条语句中“++a”是一个lvalue，因为它的结果是递增之后的a，而第四条语句中的“a++”是rvalue。只包含一个命名变量的表达式永远是lvalue。",
"layout": "post",
"title": "学习C++之一：数据类型和转换",
"category": "学习笔记",
"description": "了解C++中的数据类型",
"preview": "在C++中基本数据类型除了最常用的int型，还有占用字节数为1的bool、char型，占用2个字节的wchar_t、short型，占用4个字节的int、long、float型，还有占8个字节的long long、double和long double型。从下图可得知visual C++中各种基本类型变量所支持的值域。\n\n##bool类型\n　　bool类型的变量只具有两个值，为true或者false。在C++中引入bool类型之前，常用int型变量来表示逻辑0和逻辑1，此时数值0为真，非零为假。如果尝试输出true和false所代表的数值，可以看到true代表1，false代表0，这样就统一了逻辑真的表示（如果用非零整数来表示真，则可以使用各种各样的非零值，这有时是不利的）。\n\n　　在编译器中输入这两个值时，true和false显示为关键字。而TRUE和FALSE是MFC定义的符号，并不是关键字，也不是合法的bool值，因此不能混淆大小写。\n\n##类型的确定\n　　typeid操作符可以确定表达式的类型。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tbool n = true;\n\t\t\tfloat pi = 3.14;\t\t\t\n\n\t\t\tcout<<typeid(n).name()\n\t\t\t\t<<endl\n\t\t\t\t<<typeid(pi).name()\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序在第一行输出“bool”，在第二行输出“float”。typeid操作符产生的结果是一个对象，因此只可以按照上述操作方式来使用。在后述章节来详细学习这种操作方法。\n\n##auto关键字\n　　可以在变量定义时使用auto关键字作为变量的类型，如```auto n = 10;``` ``` auto pi = 3.14;```等，这种情况下，变量类型是根据字面值来确定的，这时n为int型，pi为float型。这也就意味着，每次给auto型变量定义时，就要为其赋予初始值，否则无法编译通过。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tauto e = 2.71828L;\t\t\t\n\n\t\t\tcout<<typeid(e).name()\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出“long double”，这是因为字面值2.71828的后面附加了L，代表此字面值的数据类型为long double型。\n\n##类型的转换　　\n　　C++中的计算只能在相同类型的值中进行，如果一个表达式中使用不同类型的变量，则编译器会把某个操作数的类型转换为与另一个操作数相匹配的数据类型之后再行计算。整个过程是隐式进行的，因此有时候将发生意想不到的效果。\n\n　　将一种类型的变量转换为另一种类型，有可能造成信息丢失。为了避免这种危险情况的发生，应该避免数据类型的转换，或者在确定数据类型转换不会发生危险时，执行转换。在任何时候，都要尽量避免使用编译器来自动安排类型转换，因为编译器不能完全知晓编程者的意图，所以在需要转换某个数据类型时，尽量使用显示的类型转换，也叫强制类型转换。\n\n　　老式的强制类型转换的操作方式是，在表达式之前使用圆括号来指明强制转换后的数据类型，如：``` int a = 0; float pi = 3.14f; a = (int) pi;``` 。这时，变量a的值为3，即pi的整数部分。\n\n　　实际上，强制类型转换有很多种不同的情况，但老式的强制类型转换涵盖了所有情况，所以更容易出错。因此，新的C++标准定义了新的数据类型转换：```static_cast<要转换的数据类型>(表达式)```。用static_cast关键字是指明此强制类型转换在编译时检查，同样还有dynamic_cast，指在执行程序的时候检查转换，另外还有删除const属性的const_cast等。执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tdouble f1=1.5;\n\t\t\tdouble f2=2.0;\n\t\t\tint number = static_cast<int>(f1) + static_cast<int>(f2);\n\n\t\t\tcout<<number\n\t\t\t\t<<endl;\n\t\t}\n\n　　可以看到，程序输出3,恰好是f1和f2的整数部分。\n\n##lvalue和rvalue\n　　C++中每个表达式的结果，都是“lvalue”和“rvalue”中的一种，它们以不同的形式存贮在的计算机的内存当中，通常也写作“l-value”或“r-value”。“l”代表“左”的英文“left”，是因为所有产生lvalue的表达式都可以出现在赋值语句“=”的左边，它的结果会放置在内存中持续存储。与之相反的是rvalue，它只会被临时存储。例如：\n\n\t\tint a(0), b(1), c(2);\n\t\ta = b + c ;\n\t\tb = ++a;\n\t\tc = a++;\n\n　　其中第一句是定义三个整形变量a、b、c，并赋予初始值。第二条语句中“b+c”的结果被临时存储在内存的一个区域中，它的结果是一个rvalue，当把它的值赋予a之后，存储“b+c”结果的内存位置便被丢弃。需要注意的是，第三条语句中“++a”是一个lvalue，因为它的结果是递增之后的a，而第四条语句中的“a++”是rvalue。只包含一个命名变量的表达式永远是lvalue。",
"first_figure": "/static/blog/img/preview_3.jpg"
},
"20170407": {
"create_time": "2017年4月7日",
"id": 20170407,
"content": "<img src=\"/static/blog/img/blog/20170407/0.png\" style=\"width: 100%\">\n\n# 8 bit guy\n　　没错，这个频道讲述的是8位计算机兴起的那个80年代的故事。主播有个观点，就是那个年代不管是对个人计算机还是整个IT科技行业，都是一个黄金时代。虽然在现在看来8位的计算机性能相当差劲、几乎没办法做任何事情，但那是计算机科技真正蓬勃发展时代，不管硬件工业设计还是软件界的百花齐放的繁荣景象，只要经历过的人都印象深刻。举个例子，家喻户晓的《超级玛丽》就诞生于那个年代。刷一刷淘宝，你一定深有同感：那个时代就像被大屏智能手机洗牌之前的手机市场，摩托的刀锋系列、诺基亚的Ngage、7610、5700、N97等等就诞生在那个时代，同样出色的设计层出不穷；而现在给你一台撕掉LOGO的手机，你甚至一眼不能分辨不出来它是什么牌子。\n<!--more-->\n<img src=\"/static/blog/img/blog/20170407/1.png\" style=\"width: 100%\">\n　　同样这个频道带有非常强的科普性质，讲述老电脑的方方面面，我非常喜欢的几集有：《老显卡如何绘图》、《老式声卡如何渲染声音》、《使用软盘存储的数码相机》、《计算机存储系列（磁带篇、软盘篇、卡带篇）》等等。\n\n## 老派显卡如何绘图？\n　　说起显卡很多人都不陌生，但在80年代电脑还用的1MHz的6502处理器（比英特尔8086更早）、十几到几十KB的RAM，即使分辨率降到QVGA（320x240）级别，要想跑出《超级玛丽》这样的游戏也是相当困难的。那时候的显卡不能称之为GPU了，因为几乎它没有任何计算能力，它的作用仅限于把显存里的内容转换成复合电视信号传送到电视上——是的，那个时候的显示器大多就是CRT电视机，每行显示40列字母。说起显存，那时候的大多数电脑没有独立的显存，所谓的显存就是RAM中一块和CPU共用的内存，CPU可以通过指令直接读写那块区域。所以，计算机编程相当有挑战性，几乎不能容忍几行多余的代码，否则1MHz的CPU就会直接嗝屁。\n<img src=\"/static/blog/img/blog/20170407/2.png\" style=\"width: 100%\">\n\n　　做个简单计算，那时候采用低分辨率即320x200来运行图形程序，那么一帧图像就有6万4千个像素。存储一个没有灰度的黑白图层，就需要8KB的内存；如果使用16色模式，即每个像素占用半Byte的内存，那么一个图层就会耗掉32KB的空间。如果用256色，就会直接吃掉64KB内存，这是一个恐怖的数字，要知道那时候大多数电脑总共都只有几十KB的RAM。所以，必须采取某些措施来解决内存占用问题。不同的主机有不同的方法，比如任天堂的游戏主机通常是把横向分辨率减半再拉伸，也就是说横向方向两个像素一起渲染，这样每个全屏的图层占用4KB，即使使用16色模式也可以接受。所以你会看到很多这样的画面：\n<img src=\"/static/blog/img/blog/20170407/3.png\" style=\"width: 100%\">\n\n而对于Commodore主机则是另外一种做法，就是把屏幕按照8x8划分成一个个小的单元，每个单元共享一个调色板，可以定义一个前景色和背景色，这样8KB保存一屏的图像，再用1KB保存调色板信息，在16色的模式下只占用9KB。<img src=\"/static/blog/img/blog/20170407/4.png\" style=\"width: 100%\">当然这样做的结果就是，每个8x8的单元都只有两种颜色，设计师必须非常努力才能让作品看起来毫无违和感，比如下图：\n<img src=\"/static/blog/img/blog/20170407/5.png\" style=\"width: 100%\">\n<img src=\"/static/blog/img/blog/20170407/6.png\" style=\"width: 100%\">\n\n这张图非常震撼，下面这张是放大图，如果你不仔细看，真的很难意识到每个8x8方格只能有两种颜色的限制。而这种8x8方格统一绘图的方式，在很多设备上都沿用了下来，如果你做嵌入式，你会发现很多屏幕的底层操作和这种原理类似。\n\n## 计算机的存储\n<img src=\"/static/blog/img/blog/20170407/7.png\" style=\"width: 100%\">\n　　很小的时候，我在姐姐的计算机读物上看到，最初的电脑用磁带作为存储介质，直到看了这个频道才一睹真容，还真有这个东西。其实更早期的电脑是靠人的手工将代码敲进计算机的，那个时候没有硬盘、没有软盘，几乎没有很方便的可以持久存储信息的设备，以至于很多广播电台用广播来播放游戏（通常是试玩版），你在电脑另一端找一个收音机接上电脑，时间一到就能载入游戏和一些有趣的东西。<img src=\"/static/blog/img/blog/20170407/8.png\">这真的很神奇，当然学过通信原理之后就见怪不怪了，毕竟能传输模拟信号的信道都能传输数字信号，而且数字信号还更稳定，当然它是以浪费带宽为代价的。不过不管怎么样，这些都刷新了我的认知，后来古董电脑爱好者还开发了一个软件，把那些曾经的游戏转换成音乐格式放在智能手机中，把音频线连接上电脑，在手机上播放“音乐”，这些程序就被载入到了电脑当中！<img src=\"/static/blog/img/blog/20170407/9.png\" style=\"width: 100%\">\n\n\n　　磁带的发明是计算机进步的一大步，当然它只是作为穿孔纸带的改进版而存在的。想象一下穿孔纸带的应用场景，通常是商用环境下，一台计算机用打孔纸带输入程序，运行完成之后，驱动打孔机打下计算结果。这样也就意味着磁带存储系统有同样的弊端，那就是没有办法随机存储。它的磁头只能在一个方向上移动，而不是软盘或硬盘这种二维移动方式，也就没有办法随意的访问索引区和数据区。即使在80年代末，磁带技术的发展使得双面磁带能记录几MB的数据，这在当年可谓是海量的存储啊，但仍然被容量小但速度更快的软盘取代之。这有点像当今的机械硬盘和SSD，虽然SSD容量依然很小，但取代机械硬盘也将是迟早的事情。\n\n　　除了磁带，同样有趣的还有卡带，印象深刻的就是小霸王学习机上的那种卡带。当然拆开来看，通常就是一颗牛屎封装的芯片，或者普通的芯片。而那个时候我都不知道这个芯片其实是一片ROM。CPU可以直接访问ROM里面的数据，因为它同样是内存的一部分，只是不能写入，游戏厂商就是把游戏的代码烧录到了这些芯片当中。这也就解释了为什么我每次玩完《超级玛丽》想换玩《魂斗罗》都需要关机换卡，因为“内存条”当然是不支持热插拔的。\n<img src=\"/static/blog/img/blog/20170407/10.png\" style=\"width: 100%\">\n## 最早的网络摄像头\n<img src=\"/static/blog/img/blog/20170407/11.png\" style=\"width: 100%\">\n　　90年代使用摄像头是比较困难的，那时还没有互联网，网络视频什么的就不用想了，而且usb还没有诞生，外设和电脑通信就必须走串口。所以，不仅要安装烦人的驱动、解决各种IRQ冲突，还要忍受折磨人的缓慢的反应速度，但拥有一个能拍照的摄像头还是很酷。<img src=\"/static/blog/img/blog/20170407/12.png\" style=\"width: 100%\">主播在这一集介绍了最早的web摄像头，虽然只有80万像素、黑白的画面，但在当时却可以用惊艳来形容。当然令我感兴趣的是，有一个方法可以让黑白摄像头拍出彩色的照片。\n<img src=\"/static/blog/img/blog/20170407/13.gif\" style=\"width: 100%\">\n那就是，用红、绿、蓝三个滤光片放在摄像头前面，拍出3张照片，再用软件合成一张。看到这里你真的不得不佩服人们的聪明才智。其实现今的智能手机摄像头的原理也是这样，只不过滤光片被放在了感光元件的像素单元上，而不是外置。\n\n\n　　总之，这是一个非常有趣的频道，该主播还维护另一频道叫做“The 8 bit keys”，介绍80年代有趣的电子钢琴和声卡之类的东西，非常值得一看。地址如下：\n<a href=\"https://www.youtube.com/user/adric22\">https://www.youtube.com/user/adric22</a>。\n\n<img src=\"/static/blog/img/blog/20170407/14.png\" style=\"width: 100%\">\n",
"layout": "post",
"title": "The 8 bit guy - 一个有趣的频道",
"category": "观点",
"tags": [
"学习"
],
"preview": "没错，这个频道讲述的是8位计算机兴起的那个80年代的故事。主播有个观点，就是那个年代不管是对个人计算机还是整个IT科技行业，都是一个黄金时代。虽然在现在看来8位的计算机性能相当差劲、几乎没办法做任何事情，但那是计算机科技真正蓬勃发展时代，不管硬件工业设计还是软件界的百花齐放的繁荣景象，只要经历过的人都印象深刻。举个例子，家喻户晓的《超级玛丽》就诞生于那个年代。刷一刷淘宝，你一定深有同感：那个时代就像被大屏智能手机洗牌之前的手机市场，摩托的刀锋系列、诺基亚的Ngage、7610、5700、N97等等就诞生在那个时代，同样出色的设计层出不穷；而现在给你一台撕掉LOGO的手机，你甚至一眼不能分辨不出来它是什么牌子。\n",
"first_figure": "/static/blog/img/blog/20170407/0.png"
},
"20180625": {
"create_time": "2018年6月25日",
"id": 20180625,
"content": "<!--more-->\n\n### 生成器与协程\n　　当一个函数中包含yield关键字时，调用这个函数就会返回一个生成器。将这个生成器传入next()函数，就会获取一次yield产生的值，直到生成器结束，抛出StopIteration异常。例如下面就是一个生成器：\n\n```\n>>> def g():\n    for _ in \"abc\":\n        yield _\n        \n>>> s = g()\n>>> s\n<generator object g at 0x00000253B98B8F68>\n\n>>> next(s)\n'a'\n\n>>> next(s)\n'b'\n\n>>> next(s)\n'c'\n\n>>> next(s)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nStopIteration\n```\n\n　　在Python2.5的版本以后，yield 关键字可以在表达式中使用，而且生成器 API 中增加了```.send(value)```方以接收变量，使得生成器可以当做协程来使用。下面就是一个简单的协程：\n```\n>>> def simple_coroutine():\n    print('-> coroutine started')\n    x = yield \"ok\"\n    print('-> coroutine received:', x)\n\n>>> my_coro = simple_coroutine()\n>>> my_coro\n<generator object simple_coroutine at 0x10\n\n>>> next(my_coro)\n-> coroutine started\nok\n\n>>> my_coro.send(42)\n-> coroutine received: 42\nTraceback (most recent call last): # ➏\n ...\nStopIteration\n```\n\n　　得到一个生成器s之后，应调用一次next(s)或s.send(None)来激活它，此时生成器代码会运行到yield处挂起。之后调用者每发送一个值，都会使这个生成器重新从yield处往下执行。每次都要给一个初始化的生成器施以next函数，显得太过繁琐，有人实现了一个装饰器，作用在一个初始化的生成器上，可以不用再调用next()就能立即使用：\n```\nfrom functools import wraps\n\ndef coroutine(func): \n    \"\"\"装饰器：向前执行到第一个`yield`表达式，预激`func`\"\"\"\n    @wraps(func)\n    def primer(*args,**kwargs):\n        gen = func(*args,**kwargs)\n        next(gen)\n        return gen\n    return primer\n```\n\n　　用作的协程的生成器s如果发生异常，则会抛给调用者。同时，s还有两个方法，.throw()和.close()。前者用来给生成器传入一个异常，如果生成器处理了异常，则会顺利运行到下一次的yield处；反之，会重新抛出给调用者，进而协程结束。后者是用来显式的关闭一个生成器。\n\n　　用作的协程的生成器return了一个值，则会抛一个StopIteration的异常给调用者，而这个异常的value属性就是return的值。\n\n### yield from\n　　yield from功能强大，在生成器 gen 中使用 yield from subgen() 时，subgen 会获得控制权，把产出的值传给gen 的调用方，即调用方可以直接控制 subgen。与此同时，gen 会阻塞，等待 subgen 终止。\n\n　　所以yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来， 这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。\n\n\n",
"title": "Python生成器与协程",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "",
"first_figure": "/static/blog/img/preview_0.jpg"
},
"20160315": {
"create_time": "2016年3月15日",
"id": 20160315,
"content": "\n![编程](/static/blog/img/blog/20160315/2016031501.jpg)\n\n　　在我累积了一定代码量之后，突然有一天，开始关注逻辑、流程、项目、需求，而不再执着于特定语言，特定技术。应该关注那些抽象的，根本的，不易变动的东西。\n\n　　很多技术，我现在不会，也不熟悉，但大致了解。如果需要，我知道去哪里寻找资料，并很快上手。看到身边有人做一些我没研究过的技术时（如网站前端，微信开发，服务端，手机APP，树莓派，Unity3D……），不再害怕或羡慕。我了解大致涉及哪些技术栈，如果有必要，我可以立马开始练习。\n<!--more-->\n　　有一门自己特别喜欢的编程语言，并且能用它做很多事情。\n\n　　不因抽象层次高而自卑。曾经一段时间，我觉得越底层越厉害，越高层越垃圾。操作系统、编译器、嵌入式编程等开发工作，比做web开发、app开发牛逼多了。C/C++比Java和Python好太多，JS和PHP简直就是玩具，写Shell脚本也能叫编程？后来发现，其实是我当时太弱智。只看到程序设计的表象，而不见本质。代码是人思想的固化，重点是思想的表达，而不在于用什么符号。\n\n　　什么是“程序”？我的理解，它是用“代码”表达的一系列步骤序列。如果再抽象一点，不用“代码”来表达呢？菜谱，日程表，路书……这些也算是“程序”吧？只不过执行者是人，不是机器。\n\n　　编程离不开代码库和API。现实中也有各种“库”和API。对我来说，手机是一个库，可以打电话、发短信、刷微信、玩游戏；电脑是一个库，可以写程序、看动漫、编辑照片、逛网站；云服务器是一个库，可以搭网站、放爬虫、搭建VPN……淘宝是一个购物API，当当网是买书API，知乎是学习经验API，优酷是发布视频API，YouTube是寻找教程API……每一本书籍，每一位朋友，每一个群组，都是一个库或API。剩下的，无穷无尽，自行发挥。\n\n　　关注大情境。我打算或正在用技术做什么事？作为一颗螺丝钉（上班族），我的主体（公司）正在干什么？当我意识到国内主流手游公司的目的只是为了赚（keng）钱，而不是为了做出真正好玩的游戏时，我感到自己的游戏编程工作（仅仅实习）毫无意义。人生苦短，迟早有一天，要去做真正想做的事情，做振奋人心的事业。作为一名有理想有抱负的程序员，难道仅仅满足于出卖自己的手艺，为资本家牟利，然后领取一点可怜工资吗？\n\n　　我希望程序员们不要太局限。以编程之眼观大千世界，能看到怎样的景象？\n",
"layout": "post",
"title": "转载：当你学会了什么之后 感觉自己的编程算是入门了?",
"author": "plough@知乎 <a target=\"_blank\" href=\"https://www.zhihu.com/question/38992723/answer/89126936\">https://www.zhihu.com/question/38992723...</a>",
"category": "观点",
"description": "脚上的泡都是自己走的",
"preview": "\n![编程](/static/blog/img/blog/20160315/2016031501.jpg)\n\n　　在我累积了一定代码量之后，突然有一天，开始关注逻辑、流程、项目、需求，而不再执着于特定语言，特定技术。应该关注那些抽象的，根本的，不易变动的东西。\n\n　　很多技术，我现在不会，也不熟悉，但大致了解。如果需要，我知道去哪里寻找资料，并很快上手。看到身边有人做一些我没研究过的技术时（如网站前端，微信开发，服务端，手机APP，树莓派，Unity3D……），不再害怕或羡慕。我了解大致涉及哪些技术栈，如果有必要，我可以立马开始练习。\n",
"first_figure": "/static/blog/img/preview_4.jpg"
},
"20170928": {
"create_time": "2017年9月28日",
"id": 20170928,
"content": "\n## 引用\n\n一般来讲，Python的变量是绑定到一个对象的引用，而不是值或副本。要判断对象是否相等，使用“==”来对比他们的值，而用“is”来判断他们是否具有相同的id，主要用在变量和单例值之间比较时。\n<!--more-->\n\n执行 a == b，相当于调用```a.__eq__(b)```。object对象的```__eq__```方法是直接对比两个对象的id，所以如果继承自object的类没有特别实现```__eq__```方法，那么“==”与“is”的操作是相同的。\n但是多种内置数据类型特别的实现了```__eq__```方法，不再是简单的对比对象的id，而是去对比对象的值。\n\n## 元组的不可变性\n\n元组保存的是对象的引用。如果引用的元素是可变的，即便元组本身不可变，元素依然可变。通俗的说，元组的不可变性其实是指 tuple 中保存的元素的id不可变，与该元素引用的对象无关。例：\n\n```\n>>> t1 = (1, 2, [30, 40])\n>>> t2 = (1, 2, [30, 40])\n>>> t1 == t2\nTrue\n>>> id(t1[-1])\n4302515784\n>>> t1[-1].append(99)\n>>> t1\n(1, 2, [30, 40, 99])\n>>> id(t1[-1])\n4302515784\n>>> t1 == t2\nFalse\n```\n元组的值会随着引用的可变对象的变化而变，而元素的标识依然保持不变。\n\n## 一个关于元祖不可变性的有趣的例子\n\n执行下面的代码\n     >>> a = (1, [2, ])\n     >>> a[1] += [3, ]\n结果会发生什么事呢？a会变成 (1, [2, 3, ])？还是会因为元祖的不可变性导致抛出异常？\n\n令人出乎意料的是，这两种情况都会发生！在控制台中执行上述的代码，会有以下输出\n```\nTypeError: 'tuple' object does not support item assignment\n>>> a\n(1, [2, 3])\n```\n其实在```a[1] += [3, ]```这一步，发生了以下情况:\n1. 将 a[1] 的值入栈TOS\n2. 计算 TOS += [3, ]。这一步能够完成，是因为 TOS 指向的是一个可变对象\n3. a[1] = TOS 赋值。这一步失败，是因为 a 是不可变的元组\n\n上一个例子，使用append( )来改变来改变元组中的可变元素是可行的，但使用“+=”则在修改成功之后触发了异常，有着一些区别。这主要是因为+=操作在Python中并非一个原子操作。所以，__使用元组时，绝不应当把可变对象放在其中__。\n\n## Python函数的参数\n\nPython的参数传递模式是共享传参，也就是说，函数的各个形参是实参的别名。这样造成的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的id，即不能把一个对象替换成另一个对象。\n\n这种朴素的方式有时也会造成致命的bug，以下是我曾经遇到的诡异的问题。\n\n```\n……\nsrc_list = get_list()  # return： [ …… ]\nfinnal_list = calc(src_list, ……)  # calc( )在某些情况下会把src_list原样返回\n\nfor _ in finnal_list:\n    if ……：\n        del src_list[ exp... ]\n\nsave(src_list)\n```\n正常情况下，for循环里一定能够遍历完finnal_list中的所有元素，并对其逐一做处理。但事实上却不是这样，某些元素没有做任何处理！\n\n究其原因，是因为某些情况下，calc( )函数会把src_list返回。这样一来，finnal_list和scr_list都是同一个list对象的引用。这样在遍历自己的同时删除了自己包含的元素，导致下标移动，因此就跳过了某些未遍历的元素。\n\n所以除了__不要用可变类型作为函数的默认值__这种Pythonista基本都知道的原则，还更要提防可变参数对程序造成的影响。例如，如果函数接收一个字典，而且在处理的过程中要修改它，那么这个副作用要不要体现到函数外部?具体情况具体分析，这其实需要函数的编写者和调用方达成共识。\n\n",
"title": "Python对象可变性与引用",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "一般来讲，Python的变量是绑定到一个对象的引用，而不是值或副本。要判断对象是否相等，使用“==”来对比他们的值，而用“is”来判断他们是否具有相同的id，主要用在变量和单例值之间比较时。\n",
"first_figure": "/static/blog/img/preview_5.jpg"
},
"20120921": {
"create_time": "2012年9月21日",
"id": 20120921,
"content": "## 路的传说\n　　在理工大的生活区和教学区之间的马路旁，有一片茂密的枫树林。那枫树林很宽，中间有条小路，把它很整齐的一分为二。\n\n![xiaodao](/static/blog/img/blog/20120921/0.jpg)\n\n## 最美的迷\n　　小路很直很直，可是站在路口却看不到尽头。路的两边，是疯狂生长的杂草和荆棘，你会发现杂草丛中偶尔也会有一朵坚强着钻出来的、孤独的花。\n\n　　那条小路，没有人真正进去过。所以没有人知道，那条路通向哪里。\n\n　　有人说，路的尽头，是地狱的入口，那里面困着一个十恶不赦的魔头。一次在夜深的时候，他路过这里，曾听到里面慌乱的鸭叫和犬吠，甚至还有老女人凄惨至极的恸哭声。\n\n　　也有人告诉我，那路的尽头是万丈悬崖，顺着崖壁的缺口走过，你会见到一座壮丽的花园。因为在雪天的午后，风吹拂着光秃的枫树，你能闻到杜鹃花的香。\n\n　　可是，没有人真正进去过。那路的尽头埋藏着这世界上最大的迷。\n\n## 所谓不舍\n　　那条路前，人聚人散。那条路前，车来车往。\n\n　　每天太阳初升的时候，人们就背着背包，有些骑着单车，打它面前经过，奔赴一个很像教堂的地方。傍晚，所有人都回到了自己的住所，小路前的嘈杂也渐渐消散。日复一日，年复一年，他们都是这样匆匆。\n\n\n　　那是一支浩大的队伍，一群繁忙的人。后来，我终于也成了他们之中的一员。\n\n　　可我每次路过的时候，总会驻足弥留，深情的人总会依依不舍。\n\n## 寻梦旅程\n　　我曾多少次想踏进那小路，探寻背后的真相。因为没有人真正进去过。 \n\n　　在一个黄昏，下着小雨的天，我又一次来到了它的跟前。雨淅沥沥的洒在枫树林，沙沙的声音，暗藏着树多少年的喜悲和沧桑。我激动着拉起身边的她。我对她说，“相信我，跟我走。”\n\n　　可她突然拽开我的手，像个陌生人般毅然决然地逃离。我看到，雨幕中她的背影，那么坚决。我黯然神伤。\n\n　　她走后我却感到从未有过的慌张。我一个人徘徊了很久，终究也没有勇气走进去。\n\n\n",
"layout": "post",
"title": "理工大的传说",
"category": "观点",
"description": "理工大的生活区和学习区有条小道，小道的尽头藏着世界上最大的迷",
"tags": [
"诗和远方"
],
"preview": "在理工大的生活区和教学区之间的马路旁，有一片茂密的枫树林。那枫树林很宽，中间有条小路，把它很整齐的一分为二。\n\n![xiaodao](/static/blog/img/blog/20120921/0.jpg)\n\n## 最美的迷\n　　小路很直很直，可是站在路口却看不到尽头。路的两边，是疯狂生长的杂草和荆棘，你会发现杂草丛中偶尔也会有一朵坚强着钻出来的、孤独的花。\n\n　　那条小路，没有人真正进去过。所以没有人知道，那条路通向哪里。\n\n　　有人说，路的尽头，是地狱的入口，那里面困着一个十恶不赦的魔头。一次在夜深的时候，他路过这里，曾听到里面慌乱的鸭叫和犬吠，甚至还有老女人凄惨至极的恸哭声。\n\n　　也有人告诉我，那路的尽头是万丈悬崖，顺着崖壁的缺口走过，你会见到一座壮丽的花园。因为在雪天的午后，风吹拂着光秃的枫树，你能闻到杜鹃花的香。\n\n　　可是，没有人真正进去过。那路的尽头埋藏着这世界上最大的迷。\n\n## 所谓不舍\n　　那条路前，人聚人散。那条路前，车来车往。\n\n　　每天太阳初升的时候，人们就背着背包，有些骑着单车，打它面前经过，奔赴一个很像教堂的地方。傍晚，所有人都回到了自己的住所，小路前的嘈杂也渐渐消散。日复一日，年复一年，他们都是这样匆匆。\n\n\n　　那是一支浩大的队伍，一群繁忙的人。后来，我终于也成了他们之中的一员。\n\n　　可我每次路过的时候，总会驻足弥留，深情的人总会依依不舍。\n\n## 寻梦旅程\n　　我曾多少次想踏进那小路，探寻背后的真相。因为没有人真正进去过。 \n\n　　在一个黄昏，下着小雨的天，我又一次来到了它的跟前。雨淅沥沥的洒在枫树林，沙沙的声音，暗藏着树多少年的喜悲和沧桑。我激动着拉起身边的她。我对她说，“相信我，跟我走。”\n\n　　可她突然拽开我的手，像个陌生人般毅然决然地逃离。我看到，雨幕中她的背影，那么坚决。我黯然神伤。\n\n　　她走后我却感到从未有过的慌张。我一个人徘徊了很久，终究也没有勇气走进去。\n\n\n",
"first_figure": "/static/blog/img/preview_3.jpg"
},
"20170202": {
"create_time": "2017年2月2日",
"id": 20170202,
"content": "\n## PostgreSQL与MySQL对比\n\n相较于M有SQL，PostgreSQL有以下优势：\n\n* MySQL不支持“hash join”和“sort merge join”以及很多其他的SQL语法，子查询性能低\n* 不支持sequence\n* 在线操作功能性弱，如建立索引锁表，增加列基本上是新建表等\n* 性能优化工具和度量信息不足\n\n<!--more-->\n### 分组查询\n\n典型场景，对于一个2列选课表，分别为课程名称和学生id，需要统计选课人数最多的表，使用分组查询，关键字为“GROUP BY”。\n```\npostgres=# \\d curriculum_schedule\n                 Table \"public.curriculum_schedule\"\n   Column   |         Type\n------------+-----------------------\n class_name | character varying(20)\n student_no | integer\n\npostgres=# select * from curriculum_schedule ;\n class_name | student_no\n------------+------------\n a          |          1\n a          |          2\n a          |          3\n b          |          4\n c          |          5\n c          |          6\n(6 rows)\n\npostgres=# select class_name, count(class_name) from curriculum_schedule group by class_name order by count(class_name);\n class_name | count\n------------+-------\n b          |     1\n c          |     2\n a          |     3\n(3 rows)\n```\n### 关联查询\n\n关联查询一般用于多张表联合查询。对于上述的例子，假如还有一张student的表，将学号映射到学生姓名上，需要查出学生姓名所选的课程，则使用关联查询。\n```\npostgres=# \\d student\n                     Table \"public.student\"\n Column |         Type\n--------+-----------------------\n no     | integer\n name   | character varying(40)\n\npostgres=# select * from student ;\n no | name\n----+-------\n  1 | a_stu\n  2 | b_stu\n  3 | c_stu\n  4 | d_stu\n  5 | e_stu\n  6 | f_stu\n(6 rows)\n\npostgres=# select class_name, name from curriculum_schedule c, student s where c.student_no=s.no;\n class_name | name\n------------+-------\n a          | a_stu\n a          | b_stu\n a          | c_stu\n b          | d_stu\n c          | e_stu\n c          | f_stu\n(6 rows)\n\npostgres=# select class_name, name from curriculum_schedule c left join student s on c.student_no=s.no;\n class_name | name\n------------+-------\n a          | a_stu\n a          | b_stu\n a          | c_stu\n b          | d_stu\n c          | e_stu\n c          | f_stu\n(6 rows)\n```\n\nPostgreSQL的join分为5种形式：\n\n1. inner join   返回的结果：两个表的交集行\n2. left join   是left outer join的简写，返回结果：左表的所有记录，右表中字段相等的行，不相等的部分为NULL\n3. right Join  是 right outer Join的简写，返回结果：右表的所有记录，左表中字段相等的行，不相等的部分为NULL\n4. full join  是 full outer join的简写，返回结果：两个表的并集 连接字段不相等的部分为NULL\n5. cross join 返回结果：把两个表进行一个n*m的组合即笛卡尔积\n\n\n",
"title": "PostgreSQL的分组查询和关联查询",
"category": "学习笔记",
"tags": [
"MySQL",
"PostgreSQL"
],
"preview": "相较于M有SQL，PostgreSQL有以下优势：\n\n* MySQL不支持“hash join”和“sort merge join”以及很多其他的SQL语法，子查询性能低\n* 不支持sequence\n* 在线操作功能性弱，如建立索引锁表，增加列基本上是新建表等\n* 性能优化工具和度量信息不足\n\n",
"first_figure": "/static/blog/img/preview_4.jpg"
},
"20160821": {
"create_time": "2016年8月21日",
"id": 20160821,
"content": "\n<img src=\"/static/blog/img/project/20160821/0.jpg\" alt=\"released\" style=\"width:100%;\"/>\n\n　　2011年底，浙江公司分管支撑的杨剑宇副总在支撑内部召集了一次头脑风暴，要求部门里各位主管和骨干轮流发言，不讲成绩，只讲问题和思路，一圈人一个一个轮流讲过来：\n\n1. 负责开发的主管说现在业务部门的需求经常考虑不清楚，而上线的时间压力很大，风险也很大，匆忙上线很容易把现有的业务弄乱，同时，上线后往往要在业务规则、操作便捷性上做多次修改，形成了很多不必要的二次开发，因此要求业务部门和需求管理员加大需求分析的力度，尽早明确需求，降低上线风险，减少二次开发。\n2. 负责产品配置的同事说新增产品现在只能在测试环境上进行验证，发布后即为生产环境，很难分析新产品上线带来的影响，以及评估对现有产品模型、资费体系的冲击。建议增加一套类生产的环境，进行全量模拟验证。\n3. 负责测试发布的同事说目前回归测试案例集不全，有些前台功能使用的场景只有一线营业员才知晓，一旦在上线前的回归测试有遗漏，上线后2个小时的核心功能回归并不能保证系统正常。要求加强自动化测试范围，完善回归测试案例集。\n4. 负责投诉处理的同事说上线后的功能不稳定导致的前台保障、批量客户投诉对日常的运维工作的冲击很大。要求提高需求分析和上线质量，避免故障和批量差错的发生。\n   \n　　那为什么会有这么多的事情呢，这一切都是因为2011年浙江移动新版本的CRM割接上线后各类事件、问题非常多，对于割接前已经稳定了很多年的开发、运维体系造成了极大的冲击。\n<!--more-->\n####割接，是一场战争\n\n　　割接，尤其是核心系统的割接，对支撑，对前台，就是一场战争，因为每一次的系统割接，基本就等同于第二天系统无法使用、或者用户的批量投诉。\n\n　　先来回顾一下什么是割接。2003年刚毕业，我就赶上了浙江移动第一次全省集中BOSS系统的割接。我和同批进公司的朱骏一起问当时的BOSS项目经理罗文模（现福建移动支撑的副总）：什么是割接，他说：割接，就是把老系统割下来，把新系统接上去，哈哈，非常形象吧。后来，百度了一下“割接”，发现这是一个从网络专业延伸到支撑网的名词：传统的割接是指使用一种新的事物替换原有旧的事物，也指将一种业务或流量从一个网中移植到另一外网络中。现在，凡是以新的系统替换旧的系统的行为都称为割接。\n\n　　在通信行业，割接是一件很慎重的事情，凡是割接，都是在晚上进行，要求进行周密的测试、数据的备份、以及失败紧急回退方案演练等等，不管是正向，还是反向，都要有充足的准备和演练，才能保证割接的成功。同时，一般在临晨5、6点前要求割接完毕，完成业务验证，不能影响第二天的运营，因此，留给真正开始割接的时间并不多，对各配合方要求都非常高。浙江移动CRM割接步骤当时专门印发成了一本小册子，A4的打印纸，100多页，详细到每一个人、每一个时间点、每一个步骤、每一个命令。\n\n　　割接方案中，最难的就是涉及数据模型升级的地方了。现在的割接方案都是先把老的数据模型在系统升级前，通过批量操作方式，“一次性转换”成新版本的数据模型。我们做过软件开发的朋友们都很清楚，做正向的升级比逆向的降级要简单，就好像连微软等这些传统的大软件开发商都没有提供这样的服务：我们把OFFICE软件从2003升级到2010，用了一段觉得不爽，不用卸载而直接回退到2003再使用。从正向考虑把老的模型升级到新模型，大家都认为是理所当然要做的事情，从项目建设之初就考虑的很清楚，在准备割接脚本时也很充分。但反过来，从新模型降级回老模型，绝大部分开发人员都是从内心拒绝这个事情的，人的思维中总是存在侥幸心理，万一不成功才用到的脚本，为了这个“万一”值得么，有这功夫还不如好好想想怎么确保成功呢，所以，最容易出问题的地方往往就在这些回退的脚本上。而且，因为都是批量操作，极易出错，且要消耗大量的时间，这样，把本来就很紧张的升级时间压缩的更短，因为割接计划中还要预留出足够的回退时间。\n\n####灰度，是一种策略\n\n　　这里打断一下，最近这几年您听说过淘宝升级么？如果没有记错，最近的一次淘宝发公告要暂停业务进行系统升级是2008年，之后再也没有听说过淘宝通过半夜停业务的方式来做系统升级的事情了。您听说过QQ升级么，事实上QQ从最开始的只能有500个好友到现在支持上亿的好友，经历过大大小小上千次的升级，从来没有停业务这一说法，为什么啊？因为互联网产品有一个特点，为了减少甚至避免系统升级对用户使用造成影响，在升级的过程中都采用了灰度发布的策略。\n   \n　　什么是灰度发布，这里引用一下百度百科的内容。\n   \n> 灰度发布，是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。-- 百度百科\n\n　　哦，原来灰度发布就是保持两份不同的版本，让一小撮用户先在新版本上尝鲜，等这部分小白鼠用户稳定了，在把绝大部分的用户迁移到新版本上来。别的先不说，就针对之前我们部门那么多领导提出来的问题，一一解答下：\n\n* 上线前需要明确业务主线，如果业务规则、操作上存在纰漏，出问题的范围也可控。而且，现在市场部门做推业务前，采用的也是先挑一个中等营业厅先操作试点，整理出业务规范，确定没问题再大规模推广，灰度发布正好就能适应这种节奏和方式。\n* 可以控制在灰度环境上验证新产品的准确性，验证各种订购、计费、查询等场景。\n* 在灰度环境上观察、收集营业员的操作，并录制成自动化测试的脚本，可以快速提高自动化测试的比例。\n* 前台的影响范围可控，也就是几个台席、百十个客户，完全可以避免上线故障和批量差错的产生。\n\n　　这么一圈分析下来，灰度发布真是个令人激动的好东西啊！接下来，部门内针对灰度发布的事情组织一拨人讨论，论证我们的CRM系统是否适合做灰度发布。\n\n　　当前系统典型的分层架构都是三层结构，在WEB层、APP层做灰度发布很容易，只需要搭建两套不同版本的生产环境，然后从WEB层控制访问的源头即可。但是服务总要收敛到数据层，因为客户的数据只能保留一个版本才能保证最小粒度（单客户级）的对外服务一致性，所以，一旦要在这个层上做灰度，不但要保留两个不同版本的数据，而且在程序控制、代码逻辑上会非常困难。\n\n　　最后的结论是如果只有WEB层的功能上线，做灰度是合适的，但我们每次上线都涉及都后台表的变化，无法承担两份数据的差异，所以无法实施灰度发布。\n\n　　这事就一直搁置在这里了。\n   \n　　是不是在运营商里，真的就不适合用灰度呢？\n\n####灰度，更是一种思想\n\n　　如果真的能通过在WEB层、APP层的灰度发布控制影响的话，为什么一定要提前批量把数据转换过去呢，为什么不能在客户访问到系统，要用到数据的时候，才把客户数据从老模型转换成新模型呢？\n\n　　也就是说，除了系统层面、数据层面能做灰度这种选择，我们在过程上为什么不能同样采用灰度呢？\n\n　　具体的说，就是把以前批量的数据割接和回退的脚本“单元化”，封装成一个个针对单独数据来源的小脚本。不管你做没做过DBA，我想这类针对单客户的数据迁移，您一定会使用到索引，执行效率非常高，这样，单个数据迁移完成后再调用新版本的服务，对客户感知基本没有什么影响。\n\n　　这样，前端的灰度发布，加上后端数据的即时转换，我们就能做到每次升级后的版本至开放到一两家营业厅、几个台席，控制较少量的用户使用，同时，采取动态数据迁移的方式，把这些台席上受理的客户数据动态升级到新的数据模型，前台只要加上个“数据转换中，请等待”的提示，前台人员一定能够理解，对这些“小白鼠”客户持续跟踪，等系统稳定了再逐步放开台席，放开试点数量，这不就是一个完整的灰度发布么？\n\n　　事情就是这样，只要你持续在一个问题上深入想下去，总会有解决的办法。2013年初去广东公司交流的时候，他们正在做CRM系统的割接，因为地市公司担心割接带来的业务影响，配合意愿不强，而且在第一次割接的时候确实是因为系统问题产生了一些影响，被地市公司把问题放大，给了支撑很大的压力。如果广东公司能考虑下灰度的策略，在地市只挑1、2个营业厅，让他们先感受新系统，接受新系统，后续的割接应该会顺畅很多。即使是新系统有问题，一两家营业厅、几个台席的失败，对地市公司都是可以承受的。所以，灰度发布看似一个加长系统升级的过程，其实是一个有效减低风险，加快割接进度的好策略呢。\n\n　　灰度部署典型的框架如下图，供参考：\n<img src=\"/static/blog/img/project/20160821/1.png\" alt=\"released\"/> \n\n\n####小结\n\n　　2011年亚信在浙江割接，2012年在上海、北京、辽宁割接，亚信的余鹏武总还计划写一本移动CRM割接的书，说要把这些经历和痛苦都写出来，虽然我相信这本书里一定有很多的内容和趣闻，但我个人还是不赞成这种宣扬靠人堆、靠硬干蛮干的工作方法。\n\n　　真心希望移动公司以后的上线不再有“割接”这样的词，而都是采用“灰度”的方式，大家轻装上阵，不用提心吊胆、不用熬夜干活，大家白天里轻轻松松就把事情做掉了。",
"layout": "post",
"title": "转载：聊聊灰度发布",
"author": "Aresiii @CSDN博客 （<a target=\"_blank\" href=\"http://blog.csdn.net/aresiii/article/details/49125369\">http://blog.csdn.net/aresiii/article/details/49125369</a>）",
"category": "学习笔记",
"tags": [
"编程"
],
"preview": "\n2011年底，浙江公司分管支撑的杨剑宇副总在支撑内部召集了一次头脑风暴，要求部门里各位主管和骨干轮流发言，不讲成绩，只讲问题和思路，一圈人一个一个轮流讲过来：\n\n1. 负责开发的主管说现在业务部门的需求经常考虑不清楚，而上线的时间压力很大，风险也很大，匆忙上线很容易把现有的业务弄乱，同时，上线后往往要在业务规则、操作便捷性上做多次修改，形成了很多不必要的二次开发，因此要求业务部门和需求管理员加大需求分析的力度，尽早明确需求，降低上线风险，减少二次开发。\n2. 负责产品配置的同事说新增产品现在只能在测试环境上进行验证，发布后即为生产环境，很难分析新产品上线带来的影响，以及评估对现有产品模型、资费体系的冲击。建议增加一套类生产的环境，进行全量模拟验证。\n3. 负责测试发布的同事说目前回归测试案例集不全，有些前台功能使用的场景只有一线营业员才知晓，一旦在上线前的回归测试有遗漏，上线后2个小时的核心功能回归并不能保证系统正常。要求加强自动化测试范围，完善回归测试案例集。\n4. 负责投诉处理的同事说上线后的功能不稳定导致的前台保障、批量客户投诉对日常的运维工作的冲击很大。要求提高需求分析和上线质量，避免故障和批量差错的发生。\n   \n　　那为什么会有这么多的事情呢，这一切都是因为2011年浙江移动新版本的CRM割接上线后各类事件、问题非常多，对于割接前已经稳定了很多年的开发、运维体系造成了极大的冲击。\n",
"first_figure": "/static/blog/img/preview_5.jpg"
},
"20170203": {
"create_time": "2017年2月3日",
"id": 20170203,
"content": "\n## 索引\n　　索引是数据库中一种快速查询数据的方法。索引中记录了表中一列或多列的值与其物理位置之间的对应关系。\n\n　　索引本身也是数据库中读写均衡的一个体现，一般来讲，__建立索引能够加快对数据表中的记录的查找和排序，但它同时也拖慢了写入和更新数据的操作，因为此时也需要对索引作相应的更新__。此外，建立索引也会额外增加数据库的存储空间。\n\n## 索引的种类\n\n　　PG支持以下几种索引：\n\n* B-tree：常用。适合处理等值查询和范围查询。\n* Hash：只能处理简单的等值查询。\n* GiST：一种架构，在此之上可以实现多种不同的索引策略。它定义的特定的操作符（如一个图形包含另一个图形的“@>”）使用特定的索引策略。\n* SP-GiST：从9.2版本引入，提供了一种新索引类型，通过一些新的索引算法提高GiST在某个情况下的性能。\n* GIN：翻转索引，可以处理包含多个键的值，如数组等。\n\n　　通常在创建索引的时候，PG会锁定表防止写入，然后对全表扫描以完成索引建立。如果此表过大，或更新频繁，则可能阻塞操作导致结果不能接受。所以此时可以并发创建索引。\n\n　　通过在CREATE INDEX命令中添加CONCURRENTLY参数，告知PG创建索引采用并发创建索引方式。此时PG会执行两次全表扫描，因此需要更长的时间，但此时不会长时间阻塞写入。\n\n　　并发创建索引时，如果在过程中被取消，可能会留下一个“INVALID”索引，这会导致更新变慢；若此索引为唯一索引，还可能导致插入重复值造成更新失败。此时，只需要删除掉INVALID索引即可。\n\n## 事务\n\n　　数据库的ACID性质让开发人员的工作得到最大限度的简化。其中ACID分别为原子性、一致性、隔离性、持久性，具体如下：\n\n* 原子性：对于数据的修改，多个插入或更新要么全部成功，要么全部失败，并在失败后可以回滚到之前的状态\n* 一致性：事务完成之后所有数据保持一致的状态\n* 隔离性：事务查看数据的状态，要么是操作之前的状态，要么是更新之后的状态，不查看中间状态\n* 持久性：事务完成之后，对系统的影响是永久性的，即使发生断电等故障，数据也一直保持\n\n　　在PG中，采用多版本并发控制（MVCC）来维护数据的一致性，主要优点是在MVCC中对读数据的锁请求和写数据的锁请求不冲突，即读不会阻塞写，写也不会阻塞读。PG中提供了表和行级别的锁定语句，让应用能够方便的操作并发数据。\n\n　　PG中大多数DDL可以包含在一个事务中，而且是可以回滚的。所以PG非常合适被用在Sharding的分布式系统底层数据库。譬如有时需要在多个节点建立相同的表，这时可以考虑把建表语句放在同一个事务当中，这样可以在各个节点中先启动一个事务，然后执行建表语句。如果某个节点建立失败，则可以回滚操作，也就不会出现部分节点建表成功，而部分节点建表失败的情况。\n",
"title": "PostgreSQL的索引与事务",
"category": "学习笔记",
"tags": [
"MySQL",
"PostgreSQL"
],
"preview": "索引是数据库中一种快速查询数据的方法。索引中记录了表中一列或多列的值与其物理位置之间的对应关系。\n\n　　索引本身也是数据库中读写均衡的一个体现，一般来讲，__建立索引能够加快对数据表中的记录的查找和排序，但它同时也拖慢了写入和更新数据的操作，因为此时也需要对索引作相应的更新__。此外，建立索引也会额外增加数据库的存储空间。\n\n## 索引的种类\n\n　　PG支持以下几种索引：\n\n* B-tree：常用。适合处理等值查询和范围查询。\n* Hash：只能处理简单的等值查询。\n* GiST：一种架构，在此之上可以实现多种不同的索引策略。它定义的特定的操作符（如一个图形包含另一个图形的“@>”）使用特定的索引策略。\n* SP-GiST：从9.2版本引入，提供了一种新索引类型，通过一些新的索引算法提高GiST在某个情况下的性能。\n* GIN：翻转索引，可以处理包含多个键的值，如数组等。\n\n　　通常在创建索引的时候，PG会锁定表防止写入，然后对全表扫描以完成索引建立。如果此表过大，或更新频繁，则可能阻塞操作导致结果不能接受。所以此时可以并发创建索引。\n\n　　通过在CREATE INDEX命令中添加CONCURRENTLY参数，告知PG创建索引采用并发创建索引方式。此时PG会执行两次全表扫描，因此需要更长的时间，但此时不会长时间阻塞写入。\n\n　　并发创建索引时，如果在过程中被取消，可能会留下一个“INVALID”索引，这会导致更新变慢；若此索引为唯一索引，还可能导致插入重复值造成更新失败。此时，只需要删除掉INVALID索引即可。\n\n## 事务\n\n　　数据库的ACID性质让开发人员的工作得到最大限度的简化。其中ACID分别为原子性、一致性、隔离性、持久性，具体如下：\n\n* 原子性：对于数据的修改，多个插入或更新要么全部成功，要么全部失败，并在失败后可以回滚到之前的状态\n* 一致性：事务完成之后所有数据保持一致的状态\n* 隔离性：事务查看数据的状态，要么是操作之前的状态，要么是更新之后的状态，不查看中间状态\n* 持久性：事务完成之后，对系统的影响是永久性的，即使发生断电等故障，数据也一直保持\n\n　　在PG中，采用多版本并发控制（MVCC）来维护数据的一致性，主要优点是在MVCC中对读数据的锁请求和写数据的锁请求不冲突，即读不会阻塞写，写也不会阻塞读。PG中提供了表和行级别的锁定语句，让应用能够方便的操作并发数据。\n\n　　PG中大多数DDL可以包含在一个事务中，而且是可以回滚的。所以PG非常合适被用在Sharding的分布式系统底层数据库。譬如有时需要在多个节点建立相同的表，这时可以考虑把建表语句放在同一个事务当中，这样可以在各个节点中先启动一个事务，然后执行建表语句。如果某个节点建立失败，则可以回滚操作，也就不会出现部分节点建表成功，而部分节点建表失败的情况。\n",
"first_figure": "/static/blog/img/preview_2.jpg"
},
"20170312": {
"create_time": "2017年3月12日",
"id": 20170312,
"content": "<img src=\"/static/blog/img/blog/20161211/0.jpg\" style=\"width: 100%\">\n\n### 代码规范\n　　谈及Python编程，《PEP 8》总是说不过去的，它是比较官方的代码风格的规范和建议。除此之外，还有《Google编程风格指导》之类的文档等，都是非常不错的文档。代码规范的重要性不言而喻，但这也是人们学习编程时最常忽略的章节。\n\n　　在我读过的入门Python书籍里，中这部分的内容都比较少。但在进阶的书籍中，有的不惜用上两个章节专门讲述，如何写出遵循PEP 8规范的Python代码，并介绍各种工具来审查代码、管理项目结构和文档。当然，事情也没这么复杂，很多时候只要配置一个顺手的IDE就够了。这里我非常推荐PyCharm，它是一款非常优秀的IDE，而且提供免费的社区版。\n<!--more-->\n<img src=\"https://www.caoliang.net/static/thrdfiles/i@caoliang.netQQ%E6%88%AA%E5%9B%BE20170311233522.png\" style=\"width:100%;\"/>\n\n　　PyChram安装之时就自带PEP 8检查，但不应把代码格式化依赖于快捷键和autopep8之类的工具进行。合格的程序员能潜移默化、自然而然的写出规整的代码。当他成为习惯时你会发现，这不是所谓的细枝末节，而且并不会拖累写代码的速度，相反，带有这种习惯会使码代码这件事更加惬意。\n\n### 变量的命名\n　　除了基本的代码规范，比如Java推荐的驼峰式命名法，Python推荐小写字母加下划线的命名法则之外，一个同样重要的原则就是，让看这份代码的人读出变量名就能知道它的含义。\n\n* 尽量使用明确含义的变量名\n\n 除非是特别抽象的库和公用方法，变量命名要就事论事，带上要处理的数据的含义。这样在维护起来，看到变量名就知道其代表的什么，脑海里不会有一个“翻译过程”。例如：\n\t\tdef find_target_screen(query, spec):\n\t\t    for element in query:\n\t\t        if element.specifications == spec:\n\t\t            return element\n\t\t        else:\n\t\t            pass\n 它显然不如下面：\n\t\tdef find_target_screen(screen_list, spec):\n\t\t    for screen in screen_list:\n\t\t        if screen.specifications == spec:\n\t\t            return screen\n\t\t        else:\n\t\t            pass\n 另外，有些人喜欢用数字2代表英文的“to”，数字4代表英文的“for”，比如```link2screen```、```ready4play```，这些都是很恶劣的习惯。且不说阿拉伯数字混淆在拉丁字母里很难辨认，即使英文水平很高的人，看到这样的变量名往往也需要停顿思考一下，这样就打断了分析代码者的思绪。所以，时刻谨记“效率第一”的原则，不要写这样的劣化代码。\n* 不要害怕过长的变量名\n\n 为了方便阅读，长的变量名是必要的。在Nginx源码中，有非常多的超过40个字符的变量名，所以完全没有必要单纯因为长度的原因而过分缩写。其次，如果不得不缩写，Python建议的原则是去掉单词的元音部分的字母，比如“count”缩写为“cnt”。一定要确认缩写后的单词是否会造成混淆，比如有人把“direction”缩写为“dire”，这绝对会让后来维护这份代码的人感到莫名其妙。\n\n\n### 编程方法\n\n * 不要滥用“奇技淫巧”\n\n 编写代码不仅要考虑简洁，更要可维护性。有些奇技淫巧确实能使你用简短的代码实现某些功能，但也要权衡是否值得这么做，因为它有时会带来的可阅读性下降。比如：```example_list[::-1]```这样的操作，好多老鸟有时也要百度一下才知道什么含义，而它等同于```example_list.reverse()```，后者其实是一种更好的方法。\n\n* 不要滥用“assert”\n\n Python中提供了断言语句，当条件不为真时抛出AssertionError的异常。很多人使用它作为输入参数的检查、用户输入的检查等，但这是不合适的。assert最初的目的用于调试，典型的场合就是单元测试。它的原则是检查用户定义的约束，而不是程序运行时错误，所以在使用assert时谨记以下几点：\n\t* 断言失败代表程序存在bug\n\n\t\t这是最基本的原则。如果你认为断言引发的错误不是bug，应该使用if等语句替换断言的逻辑\n\n\t* Python本身的异常能够捕获相关错误，就无须断言\n\n\t\t比如数组越界、除数为0、类型不匹配等，能够在操作时抛出Python自带的ValueError、TypeError等异常，就不要再操作前用assert。\n\n\t* 不要用于检查用户输入\n\t\t应当使用if等条件判断来检测用户输入。否则与第一点相违背。\n\n 断言适用的典型场景如下：\n\t* 检查函数返回值是否合理时\n\t* 当条件是业务逻辑继续下去的先决条件时\n\t\t比如业务进行下去需要两个list完全相等，而由于不可控的因素可能导致两个list不等，此时业务进行下去必然会造成错误。这时，可以使用断言。\n\n* 不要滥用\\*args和**kwargs\n\n 对于Python的位置参数和关键字参数，很多人都会用这么用：\n\t\tdef func(*args):\n\t\t    if isinstance(args[0], ExampleClassA):\n\t\t        # do something\n\t\t        pass\n\t\t    if isinstance(args[1], ExampleClassB):\n\t\t        # do something\n\t\t        pass\n\t\t    ...\n\n\t\tdef func_b(**kwargs):\n\t\t    if key_a in kwargs:\n\t\t        param_a = kwargs[key_a]\n\t\t    else:\n\t\t        return False\n\n\t\t    if key_b in kwargs:\n\t\t        param_b = kwargs[key_b]\n\t\t    else:\n\t\t        return False\n\t\t    ...\n\n 但这么做事不合理的。它违背了Pythonic原则，把参数传入到函数当中，不应该因为无名参数和关键字参数的引入而增加解析参数包的负担。如果每个函数都要对传入参数再检查，只能说明函数栈的设计存在缺陷。编写代码应该把参数检查放在一两个层级之内，而其他层级如果产生错误，应该从代码逻辑入手，而不是强制检查传入参数。\n\n 所以，位置参数和关键字参数更适合下面的场合：\n\t\tdef func(*args):\n\t\t    for object in args:\n\t\t        object.do_some_thing()\n\t\t    ...\n\n\t\tdef func_b(**kwargs):\n\t\t    direction = kwargs.get(\"direction\", \"h\")\n\t\t    user_group = kwargs.get(\"user_group\", \"normal\")\n\t\t    ...\n* 优化代码分支\n\n Python使用缩进替代大括号来区分代码块，所以，代码分支不合理，会使得Python代码混乱不堪，毫无优美可言。比如：\n\t\tif some_case:\n\t\t    ...\n\t\t    if some_case_2:\n\t\t        ...\n\t\t        if some_case_3:\n\t\t           ...\n\t\t    else:\n\t\t        ....\n\t\telse:\n\t\t    ....\n 上述的代码存在的问题是，用省略号代替的代码块比较长，而且实际的分支肯定多于上面的示例，这种情况下，当阅读者把代码滚动到下面查看else时，他可能忘记了代码块所在层。所以，他不得不滚动到开始的位置，来寻找对应的if的层级。事实上，多数情况下都可以优化成下面的结构：\n\t\tif some_case:\n\t\t    ...\n\t\telse:\n\t\t    ...\n\t\t    if some_case_2:\n\t\t        ...\n\t\t    else:\n\t\t        ...\n\t\t        if some_case_3:\n\t\t            ...\n\t\t        else:\n\t\t            ....\n\n\t\treturn\n 或者：\n\t\tif not some_case:\n\t\t    ...\n\t\t    return\n\t\t...\n\n\t\tif not some_case_2:\n\t\t    ...\n\t\t    return\n\t\t...\n\n\t\tif not some_case_3:\n\t\t    ...\n\t\t    return\n\t\t...\n\t\treturn\n 一个很典型的例子是，刚学编程时老师让我们写一个程序，用户输入三个数代表三角形的三条边，系统输出这三条边能组成什么三角形，比如直角三角形、钝角三角形等。有的人if条件嵌套的了很多层，前面有N多个判定的条件来确定这是什么三角形，但却在最后一层处理不能组成三角形的case。老师告诉我们，应当首先判断这个条件，如果不能组成三角形，就直接返回；如果满足，再按照优先级逐一判断，这样的程序条理清晰、层级分明。所以，上述两个实例就是这一编程思想的体现。\n\n 当然有些情况不能优化成2的结构，不论哪个分之下都有复杂的流。这时，就应该把这个大的函数切分成小函数。要时刻谨记同一个方法缩进的层级不能太深，哪怕函数的行数并不长，也应当保持简洁。\n",
"layout": "post",
"title": "Pythonic",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "谈及Python编程，《PEP 8》总是说不过去的，它是比较官方的代码风格的规范和建议。除此之外，还有《Google编程风格指导》之类的文档等，都是非常不错的文档。代码规范的重要性不言而喻，但这也是人们学习编程时最常忽略的章节。\n\n　　在我读过的入门Python书籍里，中这部分的内容都比较少。但在进阶的书籍中，有的不惜用上两个章节专门讲述，如何写出遵循PEP 8规范的Python代码，并介绍各种工具来审查代码、管理项目结构和文档。当然，事情也没这么复杂，很多时候只要配置一个顺手的IDE就够了。这里我非常推荐PyCharm，它是一款非常优秀的IDE，而且提供免费的社区版。\n",
"first_figure": "/static/blog/img/blog/20161211/0.jpg"
},
"20150424": {
"create_time": "2015年4月24日",
"id": 20150424,
"content": "##指针\n　　任何存储在内存中的数据都有地址编号，通过地址可以来访问具体数据。这种地址被存储在指针变量当中，所以指针也具有名称，也具有不同的类型。\n\n##定义和使用指针\n　　执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tint\tnumber(100);\n\t\t\tint* pnumber(nullptr);\n\n\t\t\tpnumber = &number;\n\n\t\t\t*pnumber += 10; \n\n\t\t\tcout<<number\n\t\t\t\t<<endl\n\t\t\t\t<<pnumber\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序会在第一行输出110，这是通过指针pnumber来访问number之后加10的结果，第二行输出number的地址编号，这个值是随机的。\n\n　　需要注意的是，在C++引入nullptr之前，通常用0或者NULL来初始化指针，这是老式的写法，至今仍可沿用，但不够好。因为nullptr确定了作为指针的0，它不同于作为数值的0和代替0的宏NULL，nullptr不会与任何其他类型的值混淆。\n\n##指向char类型的指针\n　　如果执行下面语句：```char* HelloWorld(\"hellow world !\");```，会发生什么结果呢？当然，这条语句初始了一个char型的数组，数组的首地址为指针HelloWorld所指向的地址。如果再执行语句```cout<<HelloWorld[1] ;```可以看到程序输出了字母e，这是这个数组的第二个字符。但需要注意的是，这时的数组HelloWorld是一个常量，因此我们不能再为其赋予另外的值。\n\n##指针数组\n　　可以使用声明指针的方式，来声明一个指针数组。执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tchar * pstr[]={\n\t\t\t\"apple\",\n\t\t\t\"orange\",\n\t\t\t\"banana\",\n\t\t\t\"watermelon\"\n\t\t\t};\n\n\t\t\tcout<<sizeof(pstr) <<endl\n\t\t\t\t<<*(pstr[0]+1) <<endl\n\t\t\t\t<<*(&pstr[0]+1)\t<<endl;\n\t\t}\n\n　　程序输出：\n\n\t\t16\n\t\tp\n\t\torange\t\t\n\n　　第一行的16是指针数组pstr[]所占用的内存大小，为16个字节。这是因为在32位的操作系统中，每个指针变量时钟占用4个字节的内存空间，我们声明的指针数组有四个元素，所以占用16个字节。\n\n　　声明数组指针pstr[]之后，pstr[0]包含的指针指向“apple”，pstr[1]指向“orange”,以此类推。所以，pstr[0]所包含的地址就是数组“apple”的首地址，也就是字符'a'所在的地址。(pstr[0]+1)是在数组apple中第二个元素的地址，即'p'所在的地址，在前面添加星号以解除地址引用，否则将输出串地址编号。所以程序在第二行输出‘p’。\n\n　　取出数组中第一个元素“pstr[0]”的地址再加1，则结果是数组pstr中的下一个元素，即“pstr[1]”，而pstr[1]所指向的位置是字符数组“orange”的首地址，所以程序在第三行输出orange。\n\n　　使用指针数组在某种情况下可以大大节约内存。因为定义二维数组时，为了使内存对齐，必然浪费掉很多内存空间，但使用指针数组就不必这样。\n\n##常量指针和指向常量的指针\n　　应当区分三种情况：\n\n> 1. 指向常量的指针\n> 2. 指向某个对象的常量指针\n> 3. 指向常量对象的常量指针\n\n　　对于第一种情况，如：\n\n\t\tconst char* pstring = \"some text\";\n\t\tpstring = \"another text\";\n\n\t\tcout<<pstring\n\t\t\t<<endl;\n\n　　程序输出：another text。这是因为在这种情况下，我们不能修改指针指向的对象，但可以修改指针使其指向另一个对象。通过把字符数组“another text”的首地址赋给pstring，来达到修改指针的目的，程序可以正常运行。\n\n　　对于第二种情况，我们不能修改指针，使它指向另外一个对象，但可以修改它指向的对象。执行下面程序：\n\n\tint count = 20;\n\tint * const pcount = &count;\n\t\t\t\n\tcount = 30;\n\n\tcout<<*pcount\n\t\t<<endl;\n\n　　程序输出30。\n\n　　第三种情况，既不可以修改指针，也不能修改指针指向的对象。\n\n\n##多维数组的指针\n　　可以使用数组名的指针来引用数组的元素。如果定义了一个数组fruit[][],则引用某个元素时```fruit[i][j]```和```*(*(fruit + i) + j)```的效果是一样的。这是由数组在内存中存储方式来决定的。具体工作过程，可参见上文。\n\n##new和delete操作符\n　　在程序正常运行的时候，计算机中往往有未使用的内存空间，这部分内存空间称作“堆”，有时也称为空闲存储器。在某些时候，程序在执行时需要创建不确定数量的变量，这取决于实际情况。如果没有动态内存分配的功能，则在程序运行之初就要为其分配足够多的空间，以适应各种情况，但这样往往造成内存的浪费。因此，动态的为变量开辟空间是非常必要的。\n\n　　new是C++中的一种新的操作符，它可以在空闲存储器中为特定类型的新变量分配内存空间，并且可以用delete操作符来释放用new分配的内存。可以像下面这样使用new 和delete：\n\n\t\tint* pvalue = nullptr;\n\t\tpvalue = new int (10);\n\n\t\tcout<<*pvalue\n\t\t\t<<endl;\n\n\t\tdelete pvalue;\n\t\tpvalue = nullptr;\n\n　　程序输出结果：10。并在随后释放pvalue所指向的内存空间。应该注意到，最后一行也是比不可少的。\n\n##为数组动态分配内存\n　　可以这样为数组分配内存，并随后释放内存：```pstr = new char[20]; delete [] pstr;```使用方括号是表示此时是删除一个数组，不管pstr指向的数组是多少维，只需要添加一对方括号即可。如果要为一个5*6的数组动态分配内存，可以这样定义：```pstr = new char[5][6]；```,更多维的情况以此类推。但需要注意的是，除了最左边的方括号里可以是一个变量，其他的方括号里必须为常量或者常量表达式。\n",
"layout": "post",
"title": "学习C++之三：指针与动态内存分配",
"category": "学习笔记",
"description": "学习扩展程序功能和灵活性的强大武器",
"preview": "任何存储在内存中的数据都有地址编号，通过地址可以来访问具体数据。这种地址被存储在指针变量当中，所以指针也具有名称，也具有不同的类型。\n\n##定义和使用指针\n　　执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\n\t\t\tint\tnumber(100);\n\t\t\tint* pnumber(nullptr);\n\n\t\t\tpnumber = &number;\n\n\t\t\t*pnumber += 10; \n\n\t\t\tcout<<number\n\t\t\t\t<<endl\n\t\t\t\t<<pnumber\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序会在第一行输出110，这是通过指针pnumber来访问number之后加10的结果，第二行输出number的地址编号，这个值是随机的。\n\n　　需要注意的是，在C++引入nullptr之前，通常用0或者NULL来初始化指针，这是老式的写法，至今仍可沿用，但不够好。因为nullptr确定了作为指针的0，它不同于作为数值的0和代替0的宏NULL，nullptr不会与任何其他类型的值混淆。\n\n##指向char类型的指针\n　　如果执行下面语句：```char* HelloWorld(\"hellow world !\");```，会发生什么结果呢？当然，这条语句初始了一个char型的数组，数组的首地址为指针HelloWorld所指向的地址。如果再执行语句```cout<<HelloWorld[1] ;```可以看到程序输出了字母e，这是这个数组的第二个字符。但需要注意的是，这时的数组HelloWorld是一个常量，因此我们不能再为其赋予另外的值。\n\n##指针数组\n　　可以使用声明指针的方式，来声明一个指针数组。执行下面程序：\n\n\t\t#include<iostream>\n\t\tusing namespace std;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tchar * pstr[]={\n\t\t\t\"apple\",\n\t\t\t\"orange\",\n\t\t\t\"banana\",\n\t\t\t\"watermelon\"\n\t\t\t};\n\n\t\t\tcout<<sizeof(pstr) <<endl\n\t\t\t\t<<*(pstr[0]+1) <<endl\n\t\t\t\t<<*(&pstr[0]+1)\t<<endl;\n\t\t}\n\n　　程序输出：\n\n\t\t16\n\t\tp\n\t\torange\t\t\n\n　　第一行的16是指针数组pstr[]所占用的内存大小，为16个字节。这是因为在32位的操作系统中，每个指针变量时钟占用4个字节的内存空间，我们声明的指针数组有四个元素，所以占用16个字节。\n\n　　声明数组指针pstr[]之后，pstr[0]包含的指针指向“apple”，pstr[1]指向“orange”,以此类推。所以，pstr[0]所包含的地址就是数组“apple”的首地址，也就是字符'a'所在的地址。(pstr[0]+1)是在数组apple中第二个元素的地址，即'p'所在的地址，在前面添加星号以解除地址引用，否则将输出串地址编号。所以程序在第二行输出‘p’。\n\n　　取出数组中第一个元素“pstr[0]”的地址再加1，则结果是数组pstr中的下一个元素，即“pstr[1]”，而pstr[1]所指向的位置是字符数组“orange”的首地址，所以程序在第三行输出orange。\n\n　　使用指针数组在某种情况下可以大大节约内存。因为定义二维数组时，为了使内存对齐，必然浪费掉很多内存空间，但使用指针数组就不必这样。\n\n##常量指针和指向常量的指针\n　　应当区分三种情况：\n\n> 1. 指向常量的指针\n> 2. 指向某个对象的常量指针\n> 3. 指向常量对象的常量指针\n\n　　对于第一种情况，如：\n\n\t\tconst char* pstring = \"some text\";\n\t\tpstring = \"another text\";\n\n\t\tcout<<pstring\n\t\t\t<<endl;\n\n　　程序输出：another text。这是因为在这种情况下，我们不能修改指针指向的对象，但可以修改指针使其指向另一个对象。通过把字符数组“another text”的首地址赋给pstring，来达到修改指针的目的，程序可以正常运行。\n\n　　对于第二种情况，我们不能修改指针，使它指向另外一个对象，但可以修改它指向的对象。执行下面程序：\n\n\tint count = 20;\n\tint * const pcount = &count;\n\t\t\t\n\tcount = 30;\n\n\tcout<<*pcount\n\t\t<<endl;\n\n　　程序输出30。\n\n　　第三种情况，既不可以修改指针，也不能修改指针指向的对象。\n\n\n##多维数组的指针\n　　可以使用数组名的指针来引用数组的元素。如果定义了一个数组fruit[][],则引用某个元素时```fruit[i][j]```和```*(*(fruit + i) + j)```的效果是一样的。这是由数组在内存中存储方式来决定的。具体工作过程，可参见上文。\n\n##new和delete操作符\n　　在程序正常运行的时候，计算机中往往有未使用的内存空间，这部分内存空间称作“堆”，有时也称为空闲存储器。在某些时候，程序在执行时需要创建不确定数量的变量，这取决于实际情况。如果没有动态内存分配的功能，则在程序运行之初就要为其分配足够多的空间，以适应各种情况，但这样往往造成内存的浪费。因此，动态的为变量开辟空间是非常必要的。\n\n　　new是C++中的一种新的操作符，它可以在空闲存储器中为特定类型的新变量分配内存空间，并且可以用delete操作符来释放用new分配的内存。可以像下面这样使用new 和delete：\n\n\t\tint* pvalue = nullptr;\n\t\tpvalue = new int (10);\n\n\t\tcout<<*pvalue\n\t\t\t<<endl;\n\n\t\tdelete pvalue;\n\t\tpvalue = nullptr;\n\n　　程序输出结果：10。并在随后释放pvalue所指向的内存空间。应该注意到，最后一行也是比不可少的。\n\n##为数组动态分配内存\n　　可以这样为数组分配内存，并随后释放内存：```pstr = new char[20]; delete [] pstr;```使用方括号是表示此时是删除一个数组，不管pstr指向的数组是多少维，只需要添加一对方括号即可。如果要为一个5*6的数组动态分配内存，可以这样定义：```pstr = new char[5][6]；```,更多维的情况以此类推。但需要注意的是，除了最左边的方括号里可以是一个变量，其他的方括号里必须为常量或者常量表达式。\n",
"first_figure": "/static/blog/img/preview_2.jpg"
},
"20170410": {
"create_time": "2017年4月10日",
"id": 20170410,
"content": "<img src=\"/static/blog/img/blog/20161231/0.jpeg\" style=\"width: 100%\">\n\n　　Python装饰器是Python高级特性中相当重要的一部分，但由于涉及函数式编程、闭包等概念，所以相对难以理解。包括廖雪峰的教程在内，很多教程讲述的都十分晦涩，甚至有很多帖子只是贴出大量没有意义的代码，完完全全是电子垃圾。关于编程，__我们的目的是理解它的原理而写出代码，而不是通过看代码来推敲它的原理__，可偏就有很多人喜欢反其道而行。\n\n<!--more-->\n## 两种装饰器，一个本质\n　　对于装饰器，我觉得官方文档用了简短的2、30行就已经描述的非常详尽明了了，有意思的一段是下面：\n```\n@dec2\n@dec1\ndef func(arg1, arg2, ...):\n    pass\n\n# This is equivalent to:\n\ndef func(arg1, arg2, ...):\n    pass\nfunc = dec2(dec1(func))\n\n# ----------------------------------------------\n\n@decomaker(argA, argB, ...)\ndef func(arg1, arg2, ...):\n    pass\n    \n# This is equivalent to:\n\ndef func(arg1, arg2, ...):\n    pass\nfunc = decomaker(argA, argB, ...)(func)\n```\n　　可以知道，装饰器只是一种语法糖的存在，装饰器的代码会在被装饰的函数定义的时候执行，也就是被import后载入内存时生效。装饰器分两种，具体如下：\n1. __不带参数的装饰器：接收一个函数f作为参数，返回另一个函数fd，在调用函数f的地方，用fd取而代之。__\n1. __带参数的装饰器：接收设定的参数，返回一个装饰器。返回这个装饰器可以是带参数的，也可以不带参数。但如果它带参数，这个返回的装饰器就必须再返回一个装饰器。直到最后返回的装饰器是不带参数的，也就是上面这种装饰器，就进入1的逻辑。__\n\n　　先说第一种。由于Python没有switch……case……的支持，所以可以借助装饰器来实现类似的作用。\n```\n_case_map = {}\n\ndef supported_case(f):\n    _case_map[f.__name__] == f\n    return f\n\n@supported_case\ndef load_data():\n    return \"load\"\n\n@supported_case\ndef parse_data():\n    return \"parse\"\n\ndef switch(case):\n    proc_func = _case_map.get(case)\n    if proc_func:\n        result = proc_func()\n    else:\n        result = None\n\n    return result\n\nif __name__ == \"__main__\":\n    case = \"load_data\"\n    print switch(case)\n\n运行结果：\n[out]: load\n```\n这是最常见的用法了：supported_case接收一个函数，将它的名字注册到_case_map字典中，然后原封不动的把这个函数返回（暂时先不对接受到的这个函数做魔改，以简化问题。对其魔改的事宜，稍后再论）。也就是说，这里选择的依据，是函数名。如果不根据函数名而指定case，那就要用到第二种装饰器——带参数的装饰器：\n```\ndef supported_case(case):\n    def non_param_decoretor(f):\n        _case_map[case] = f\n        return f\n\n    return non_param_decoretor\n\n@supported_case(case=\"load\")\ndef load_data():\n    return \"load\"\n\n...\n```\n如上，装饰器supported_case中返回了一个不带参数的装饰器non_param_decoretor，对load_data函数的装饰工作（注册到_case_map）就是由这个不带参数的装饰器进行的。而外层的装饰器supported_case，它的存在就是接收case参数，再通过局部变量的方式，传递给内层。\n\n可以猜想，如过内层的装饰器可以通过某种方式接收case参数，是不是它就不用在supported_case中定义了呢？是的，根据总结的第二点，带参数的装饰器只要它最终返回一个I类装饰器就OK，而不必要关心它在哪里定义。所以上面的```supported_case```装饰器可以改写成下面的样子：\n```\n__current_case = None\n\n\ndef non_param_decoretor(f):\n    _case_map[_current_case] = f\n    return f\n\n\ndef supported_case(case):\n    global __current_case\n    __current_case = case\n\n    return non_param_decoretor\n\n```\n这段代码与上一段代码作用完全相同，但展示了一点，__装饰器完全可以不用嵌套很多层，一层足矣__。新手惧怕装饰器的重要原因之一就是，装饰器往往嵌套很多层，让人摸不着头脑。事实上，嵌套多层显著的优点是可以自然而然的向内层的代码块传送变量，因为变量的作用域就是嵌套的，而这段代码只要有一个地方修改了\\__current_case，那么程序就会出错，因为它共享了__current_case变量，变得不安全。\n\n所以，搞懂了装饰器中每一层定义的函数的功用，就算真正理解了装饰器了。所以下面可以对函数进行魔改了，比如做参数检查等。这一步总结起来如下：\n1. 已经知道了要魔改的函数名，假设为function_watting_to_be_modified\n2. 已经知道要魔改的参数（如果不知道或者为不定参数，则使用\\*args替代位置参数，\\**kwargs代替键值参数，当然args和kwargs的名字可以自定义）\n3. 定义一个函数，函数名随意（假定为modified_function），但是和要魔改的函数接收相同的参数\n4. 首先对参数做一些操作，比如参数检查、预先打印日志等，然后用操作之后的参数来调用要魔改的函数，记录结果，并对结果做一些操作，比如合理性检查、打印日志等，再返回魔改的结果\n\n那么可以这么写：\n```\ndef modified_function(*args, **kwargs):\n    # 做参数检查，log等\n    if kwargs.get(\"data_langth\", 0) <= ……\n        ……\n\n    # 记录结果\n    result = function_watting_to_be_modified(*args, **kwargs)\n\n    # 对结果检查等 \n    if not result...\n\n    return result\n```\n\n那么， 依照之前的思路，再用一个全局变量来保存要魔改的函数，完成最终的魔改。假设有前面定义的“load_data”、“parse_data”这两个函数，不接受任何参数，返回它们的函数名，我们要把它魔改成这样：在它们返回的结果追加字符串“decoretor”。然后根据指定的case来选择执行哪个函数，那么完整的代码如下：\n```\n_case_map = {}\n__current_case = None\n__function_watting_to_be_modified = None\n\ndef modified_function():\n    result = __function_watting_to_be_modified()\n    return str(result) + \"decoretor\"\n\ndef non_param_decoretor(f):\n    global __function_watting_to_be_modified\n    __function_watting_to_be_modified = f\n    _case_map[__current_case] = modified_function\n    return modified_function\n\ndef supported_case(case):\n    global __current_case\n    __current_case = case\n    return non_param_decoretor\n\n@supported_case(case=\"load\")\ndef load_data():\n    return \"load_data\"\n\n@supported_case(case=\"parse\")\ndef parse_data():\n    return \"parse_data\"\n\ndef switch(case):\n    proc_func = _case_map.get(case)\n\n    return proc_func() if proc_func else None\n\nif __name__ == \"__main__\":\n    case = \"load\"\n    print switch(case)\n```\n注意，这里使用了三个函数来完成一个装饰器，这三个函数由上到下分别的作用是：\n* 魔改原函数，在其结果后追加“decoretor”字符串\n* 将魔改后的函数注册到_case_map中，以便后续的switch搜索\n* 接收指定的case参数，将其传递给一个无法接受参数的装饰器\n\n那么，这个实例的目的，就是为了说明一点__无论多么复杂的装饰器，都可以写在一层。而付出的代价是，失去了函数式编程优点，重度依赖的变量的作用域无法完全把控，从而带来极大的安全风险，也使得代码失去了简洁性__。所以，用标准的装饰器写法改写上述的三个函数：\n```\ndef supported_case(case):  # 接收指定的case参数，将其传递给一个无法接受参数的装饰器\n    def non_param_decoretor(f):  # 将魔改后的函数注册到_case_map中，以便后续的switch搜索\n        def modified_function(*args, **kwargs):  # 魔改原函数，在其结果后追加“decoretor”字符串\n            result = f(*args, **kwargs)\n            modified_result = str(result) + \"decoretor\"\n            return modified_result\n\n        _case_map[case] = modified_function\n        return modified_function\n\n    return non_param_decoretor\n```\n以上就是精彩的Python装饰器，关于函数被装饰后，内置属性__name__、__doc__等发生改变所造成的一些问题的解决方法，网络上教程众多，在此不赘述。Python装饰器的强大，远不止于此。总的来讲，OOP的装饰模式需要通过继承和组合来实现，而Python的decorator直接从语法层次支持装饰模式。Python的decorator可以用函数实现，也可以用类实现。\n\n## 用类实现的装饰器\n　　参见一个高水平的装饰器，这是Django的一段源代码：\n```\nclass cached_property(object):\n    \"\"\"\n    Decorator that converts a method with a single self argument into a\n    property cached on the instance.\n\n    Optional ``name`` argument allows you to make cached properties of other\n    methods. (e.g.  url = cached_property(get_absolute_url, name='url') )\n    \"\"\"\n    def __init__(self, func, name=None):\n        self.func = func\n        self.__doc__ = getattr(func, '__doc__')\n        self.name = name or func.__name__\n\n    def __get__(self, instance, cls=None):\n        if instance is None:\n            return self\n        res = instance.__dict__[self.name] = self.func(instance)\n        return res\n\n```\n这段代码看doc就知道，是将一个类实例的一个只接受self的方法，转换成该实例的属性并缓存。这段代码用途广泛，典型的就是服务器收到一个http请求之后缓存request的cache、GET的QUERY_STRING、POST的文件流等。使用方法如下：\n```\nclass Test(object):\n    @cached_property\n    def test_property(self):\n        print \"calc\"\n        return 1\n\na = Test()\na.test_property\n[out]: calc\n1\n\na.test_property\n[out]: 1\n```\n可以看到，只要被装饰的方法运行过一次，就再也不调用它，而是直接读取缓存的结果。神奇的代码在这一句```res = instance.__dict__[self.name] = self.func(instance)```，它用被装饰的函数的运行结果，替换实例的内置属性\\__dict\\__中的“test_property”的值。所以在之后访问这个属性，就直接取\\__dict\\__中缓存的结果，访问不到test_property函数。所以，用类实现的装饰器与用函数实现的装饰器的区别，就是前者可以借助类的属性来保存一些中间变量，虽然实现起来更加繁琐，但功能也更加强大。",
"layout": "post",
"title": "Pythonic - 装饰器正解",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "Python装饰器是Python高级特性中相当重要的一部分，但由于涉及函数式编程、闭包等概念，所以相对难以理解。包括廖雪峰的教程在内，很多教程讲述的都十分晦涩，甚至有很多帖子只是贴出大量没有意义的代码，完完全全是电子垃圾。关于编程，__我们的目的是理解它的原理而写出代码，而不是通过看代码来推敲它的原理__，可偏就有很多人喜欢反其道而行。\n\n",
"first_figure": "/static/blog/img/blog/20161231/0.jpeg"
},
"20170919": {
"create_time": "2017年9月19日",
"id": 20170919,
"content": "<img src=\"/static/blog/img/project/20160826/0.jpg\" style=\"width: 100%\">\n\n　　中间件就是一个介于web框架和业务代码之间处理request或response的中间层执行逻辑，例如记录一个网站请求的IP和pv的组件等。在Django中，最常见的就是CSRF以及错误收集页面等组件，他们都被放置在了MIDDLEWARE_CLASSES配置项里，在每个请求到达后被调用。<!--more-->1.9以下的版本，定制一个中间件的格式如下：\n```\nclass CommonMiddleware(object):\n    def process_request(self, request):\n        return None\n\n    def process_response(self, request, response):\n        return response\n```\n很容易理解，`CommonMiddleware`的两个方法`process_request`和`process_response`分别在请求对象被传入view层处理逻辑前和view层处理request并抛出response之后被调用。\n\n在Django 1.10之后，采用了一种新的写法，如下：\n```\nclass SimpleMiddleware(object):\n    def __init__(self, get_response):\n        self.get_response = get_response\n        # One-time configuration and initialization.\n \n    def __call__(self, request):\n        # Code to be executed for each request before\n        # the view (and later middleware) are called.\n \n        response = self.get_response(request)\n \n        # Code to be executed for each request/response after\n        # the view is called.\n \n        return response\n```\n在Django加载完所有的中间件之后，会首先用基础的`get_response`方法初始化一个中间件，再取其`__call__`属性，取代之前的get_response方法，以此类推，最终得到一个层层包装的总处理函数。那么当一个请求到达之后，会传给这个层层包装的处理函数，逐层穿过嵌套的中间件，被处理之后，内层逻辑抛出response，然后逐层穿出，完成一次响应。\n\n这里的```SimpleMiddleware```就是一个装饰器，而且是用类实现的。换做函数，写法也很明了：\n```\ndef smple_middleware(get_response):\n    def wrap_get_response(request):\n        # Do something for each request before\n        # the view (and later middleware) are called. \n        \n        response = get_response(request)\n        \n        # Code to be executed for each request/response after\n        # the view is called.\n        \n        return response\n    return wrap_get_response\n```\n装饰器代码是在被装饰的函数定义的时候被执行的，用类实现的装饰器可以借助类的属性保存一些全局的信息，实现更多的奇技淫巧。\n",
"layout": "post",
"title": "从Django中间件的设计再谈装饰器",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "中间件就是一个介于web框架和业务代码之间处理request或response的中间层执行逻辑，例如记录一个网站请求的IP和pv的组件等。在Django中，最常见的就是CSRF以及错误收集页面等组件，他们都被放置在了MIDDLEWARE_CLASSES配置项里，在每个请求到达后被调用。",
"first_figure": "/static/blog/img/project/20160826/0.jpg"
},
"20150629": {
"create_time": "2015年6月29日",
"id": 20150629,
"content": "\n![raspberrypi](/static/blog/img/project/20150629/raspberrypi.jpg)\n\n　　树莓派非常流行的原因之一，就是它在提供了强悍性能的同时还保持着白菜般的价格。官方的指导售价是35美刀，显然这个价格是不包括显示器的。如果你真的要把它当做一台纯粹的电脑来用，那你不免要买键鼠、显示器之类的东西，这个开销就远不止35美元了。为了发挥它最大的价值，下面就来说说抛开显示器，如何来使用树莓派。\n<!--more-->\n　　步骤是：\n\n　　1、安装树莓派操作系统\n\n　　2、将树莓派接入网络，得知树莓派的IP地址\n\n　　3、通过ssh工具、远程桌面等软件连接树莓派\n\n##安装树莓派系统\n　　首先安装系统。在树莓派官网https://www.raspberrypi.org/downloads/ 下载raspbian系统镜像。点击“Download ZIP”，下载完成后解压，得到img镜像。\n\n![raspberrypi](/static/blog/img/project/20150629/raspdownload.jpg)\n\n　　然后在网络上下载“Win32DiskImager”工具，插入内存卡（无需提前格式化），运行Win32DiskImager.exe。如下所示：\n\n![raspberrypi](/static/blog/img/project/20150629/raspimg.jpg)\n\n　　首先选择系统镜像，打开刚才解压的系统镜像，然后在右侧选定插入的内存卡，最后点击“写”，系统会提示此操作将格式化内存卡，点击“确定”，就开始烧录系统了。镜像烧录成功之后，点击安全删除硬件来安全弹出内存卡，即可插入到树莓派上电开机。\n\n　　需要注意的是，安装完系统镜像后，内存卡的可用空间和总空间变为了几十MB，这是正常的现象，因为linux下的分区方式和windows的并不一样。所以，想要往树莓派里传文件的时候，不能直接往内存卡里复制东西，而需要借助U盘等煤质，或者通过网络来传输。\n\n##获取树莓派ip地址\n　　将树莓派接入网络是非常简单的，直接连接到路由器的LAN口就行了。如果网络已连接，则网口上的的绿灯将点亮。\n\n　　此时最头疼的问题是，怎么获取树莓派的IP地址呢？因为要远程访问树莓派，ip地址是必知的参数。这里有两个办法.\n\n　　其一，通过串口来访问树莓派。树莓派的开发者可能早就考虑到有相当多的人会不接显示器来使用树莓派，所以树莓派默认就可以通过串口来控制。不过个人不推荐这种方法，因为你需要有一个USB转串口的转换器，如下所示：\n\n![raspberrypi](/static/blog/img/project/20150629/uart.jpg)\n\n　　这个东西十几块钱就可以在淘宝上买到，需要注意的是，有的Usb转串口模块输出的是5V电压，这种转换器和树莓派不兼容，应购买3.3V的。下面把串口转换器和树莓派进行连接。\n\n![raspberrypi](/static/blog/img/project/20150629/gpios.png)\n\n　　在树莓派的GPIO上找到上图对应的三个引脚。（翻转到树莓派背面，第一个GPIO管脚的焊盘是正方形的，找到了第一个引脚的位置，其他对应的引脚也就随之确定）将串口转换器的G与树莓派的Ground引脚相连，然后将串口的TXD连接到树莓派的RXD，再把串口模块的RXD连接到树莓派的TXD。在上电之前需要再三检查，因为新手很有可能因为接线错误导致短路而烧毁整个树莓派。\n\n![raspberrypi](/static/blog/img/project/20150629/connect.jpg)\n\n　　检查无误后，将Usb转串口插入到电脑。从网络上下载SecureCRT软件并安装，单击“File”，选择“Quick Connect”,弹出下面的窗口。\n\n![raspberrypi](/static/blog/img/project/20150629/crtuart1.jpg)\n\n　　选择正确的串口号之后，设置“波特率 115200 无奇偶校验”，开启串口。随便给树莓派发送几个字符，通信正常的话，会收到树莓派的提示：\n\n![raspberrypi](/static/blog/img/project/20150629/uartcon.jpg)\n\n　　这个时候，需要输入用户名和密码来登陆树莓派啦。用户名是“pi”，密码是“raspberry”。进入linux系统之后，输入“ifconfig”，即可看到树莓派的当前地址，这个是内网地址：\n\n![raspberrypi](/static/blog/img/project/20150629/netcon2.jpg)\n\n　　可以看到，ip为192.168.1.102 。\n\n　　第二种获取树莓派ip地址的办法十分简单粗暴，直接登陆路由器的设置页“192.168.1.1”（有的是192.168.0.1），在DHCP服务器栏查看客户端列表，可以看到：\n\n![raspberrypi](/static/blog/img/project/20150629/dhcplist.jpg)\n\n　　其中最后一项客户端名为“raspberry”，地址为192.168.1.102 。（需要注意的是，因为我之前已经将树莓派绑定至静态ip，所以在最后一项有效时间显示为“永久”，如果没有设置，则会显示一个具体的倒计时）\n\n##连接树莓派\n　　SSH是一种加密的远程传输协议，可以使用ssh工具来远程访问树莓派。有些linux版本默认是不开启SSH的，但树莓派的开发者可能考虑到很多玩家只有裸机，所以官方系统是开启ssh的，这样给了我们这些没有显示器的玩家极大的方便。这里使用secureCRT软件来连接树莓派。打开secureCRT，单击“File”，选择“Quick Connect”,弹出下面的窗口。\n\n![raspberrypi](/static/blog/img/project/20150629/secureCRT1.jpg)\n\n　　填写树莓派的ip地址与端口号，树莓派ssh连接的端口号默认为22 。单击“connect”，在弹出的“New Host Key”对话框中，选择“accept&save”。然后输入用户名和密码，就可以登陆上树莓派了。\n\n![raspberrypi](/static/blog/img/project/20150629/secureCRT2.jpg)\n\n　　为了让secureCRT更好的显示linux，需要作两项设置：\n\n　　1、设置编码方式UTF-8，以更好兼容中文：Options -> Session Options -> Emulation -> Terminal -> appearance ，在右侧选项框中将Charactor coding由default改为UTF8 。\n\n　　2、设置linux显示格式：Options -> Session Options -> Emulation -> Terminal ->Linux,勾选上ANSI-color。\n\n　　设置完成后，重新连接，就有下面的效果：\n\n![raspberrypi](/static/blog/img/project/20150629/secureCRT3.jpg)\n\n　　这样，就可以通过secureCRT远程来访问树莓派啦！\n\n##使用远程桌面来连接树莓派\n　　使用secureCRT只能通过命令行来操作树莓派，因为无法启动x-window所以不能看到图形界面。尽管这样已经足够了，但偶尔还是要用到树莓派的图形界面的，这时候可以使用一款叫VNC的远程桌面软件来连接树莓派。首先需要安装树莓派端的vnc server。\n\n　　secureCRT中输入“sudo apt-get update”更新软件源。然后输入“sudo apt-get install tightvncserver”安装vncserver。安装过程中按y来确定。\n\n　　安装完成后输入“tightvncserver”来启动vnc服务，系统会要求输入密码，再校验一次密码，这个密码是远程桌面的密码。输入两次密码后，会再次询问你是否允许外部控制。如果输入“y”，那么远程桌面就不能控制树莓派，仅仅只是投射树莓派的桌面。所以这里选择“n”，表示允许外部控制。\n\n![raspberrypi](/static/blog/img/project/20150629/vnc1.jpg)\n\n　　注意其中一行：“New \"X\" desktop is raspberrypi:1 ”，冒号后面所跟的就是通过vnc来访问树莓派的端口，这里是1。在电脑上启动vnc，输入树莓派的ip地址和前面的端口号。\n\n![raspberrypi](/static/blog/img/project/20150629/vnc2.jpg)\n\n　　点击连接，输入刚才输入的密码，即可登录到树莓派桌面。\n\n![raspberrypi](/static/blog/img/project/20150629/vnc3.jpg)\n\n　　树莓派相较于桌面电脑性能低，而且是通过网络来投射的远程桌面，所以使用vnc来访问树莓派给人的感受只有一个字：慢！但其中也有很多有意思的东西，比方说系统自带的几个Python写的小游戏：\n![raspberrypi](/static/blog/img/project/20150629/vnc4.jpg)\n![raspberrypi](/static/blog/img/project/20150629/vnc5.jpg)\n![raspberrypi](/static/blog/img/project/20150629/vnc6.jpg)\n\n　　是不是挺有意思呢？\n\n",
"layout": "post",
"title": "树莓派之无显示器使用",
"category": "学习笔记",
"description": "没有显示器怎么办？别担心，建立远程连接",
"tags": [
"编程",
"树莓派"
],
"preview": "\n![raspberrypi](/static/blog/img/project/20150629/raspberrypi.jpg)\n\n　　树莓派非常流行的原因之一，就是它在提供了强悍性能的同时还保持着白菜般的价格。官方的指导售价是35美刀，显然这个价格是不包括显示器的。如果你真的要把它当做一台纯粹的电脑来用，那你不免要买键鼠、显示器之类的东西，这个开销就远不止35美元了。为了发挥它最大的价值，下面就来说说抛开显示器，如何来使用树莓派。\n",
"first_figure": "/static/blog/img/preview_5.jpg"
},
"20180401": {
"create_time": "2018年4月1日",
"id": 20180401,
"content": "## 自增主键和uuid\n\n　　在IT服务当中，数据库主键一般有两种选择，分别为uuid和自增两种形式。\n\n　　自增主键性能高，占用空间少，但在重要业务当中不适合暴露给外部，因为值是连续的，很容易通过猜测和暴力枚举来破解真实业务情况，甚至带来安全性问题。\n\n　　uuid则一般为随机字符串，具有一定的业务保密性，但不管是性能还是存储占用，都相对差点意思。MySQL中innodb存储引擎的主键是聚簇索引，会把相邻主键的数据安放在相邻的物理存储上。如果主键不是自增，而是随机的，那么频繁的插入会使 innodb 频繁地移动磁盘块，而影响写入性能。\n\n<!--more-->\n\n## hashids\n　　hashids是一个跨平台的类似hashlib的小巧库，用来把一个数值映射成另一个值，但整个过程是可逆的，可以用在不想暴露内部数据库id时使用。\n\n　　Python安装：\n```\npip install hashids\n\n```\n　　从```hashids```模块中import构造器，并初始化一个实例：\n```\nfrom hashids import Hashids\nhashids = Hashids()\n\n# 编码一个数\nhashid = hashids.encode(123)\n>>>: 'Mj3'\n\n# 解码一个数\nhashids.decode('xoz')\n>>>: (456, )\n\n# 编码一系列数\nhashid = hashids.encode(123, 456, 789)\n>>>: 'El3fkRIo3'\n\n# 解码\nhashids.decode('1B8UvJfXm')\n>>>: (517, 729, 185)\n\n```\n　　当然，在初始化构造器的时候可以传入自定义的盐，使得生成的映射值具有更高的安全性。此外还可以控制生成字符串的最小长度，以及自定义的字符表。\n\n```\nHashids(salt=\"fake salt\").encode(1)\n>>>: '8N'\n\nHashids(salt=\"true salt\").encode(1)\n>>>: 'Wz'\n\nHashids(salt=\"true salt\", min_length=10).encode(1)\n>>>: 'R4jlWzEOk8'\n\nHashids(salt=\"true salt\", min_length=10, alphabet=\"abcdefg1234567890\").encode(1)\n>>>: '92g3586570'\n```\n　　可惜的是，这个库不支持定义生成字符串的精确长度。官方文档也没有这方面说明。个人猜测，如果传入的min_length长度足够大的话，在编码的值的范围内，生成映射的字符串的位数将保持不变。譬如，假设可以预知要编码的值在10 000 ~ 1 000 000之间，那么min_length可以设定为编码1 000 000生成的字符串的length，这样整个区间的值编码后的位数都不会溢出。\n\n　　下面测试：\n```\ns = Hashids(salt=\"true salt\", alphabet=\"abcdefg1234567890\")\nlen(s.encode(1000000))\n>>> 7\n\ns = Hashids(salt=\"true salt\", alphabet=\"abcdefg1234567890\", min_length=7)\nr = sorted([len(s.encode(_)) for _ in range(10000, 1000001)])\nr[0]\n>>>: 7\nr[-1]\n>>>: 7\n```\n　　关于性能，做了一个不严谨的测试：\n```\ndef test():\n    s = Hashids(salt=\"true salt\", min_length=20, alphabet=\"abcdefg1234567890\")\n    start_time = time.time()\n    for _ in range(100000000, 110000000):\n        s.encode(_)\n    print time.time() - start_time\n\ntest()\n>>>: 185.553853035\n\n\"%.8f\" % (185.55/10000000)\n>>>: '0.00001856'\n\ndef test():\n    s = Hashids(salt=\"true salt\", min_length=20, alphabet=\"abcdefg1234567890\")\n    start_time = time.time()\n    s.encode(110000000)\n    print \"%.8f\" % (time.time() - start_time)\n\ntest()\n>>>: 0.00002789\n```\n　　可以看到，在i7 7700HQ @2.6GHz + 16G  RAM的测试平台下，批量编码1千万个key，耗时185秒，平均每个值18.5微秒，编码单个值时耗时28微秒。对于解码速度并未测试，考虑到这几乎就是真实业务中遇到的极端情况，总体性能是非常令人满意的。",
"title": "一个小巧的编解码id库",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "在IT服务当中，数据库主键一般有两种选择，分别为uuid和自增两种形式。\n\n　　自增主键性能高，占用空间少，但在重要业务当中不适合暴露给外部，因为值是连续的，很容易通过猜测和暴力枚举来破解真实业务情况，甚至带来安全性问题。\n\n　　uuid则一般为随机字符串，具有一定的业务保密性，但不管是性能还是存储占用，都相对差点意思。MySQL中innodb存储引擎的主键是聚簇索引，会把相邻主键的数据安放在相邻的物理存储上。如果主键不是自增，而是随机的，那么频繁的插入会使 innodb 频繁地移动磁盘块，而影响写入性能。\n\n",
"first_figure": "/static/blog/img/preview_4.jpg"
},
"20150628": {
"create_time": "2015年6月28日",
"id": 20150628,
"content": "##树莓派\n\n![raspberrypi](/static/blog/img/project/20150628/raspberrypi.jpg)\n\n　　如果你是一位极客，那你必然听说过“树莓派”这个名词。我记得第一次听说树莓派的时候，是在网络上看到一段关于它的视频，开发者拿一块和身份证差不多大的电路板做演示，接上键盘和显示器，在英国就登陆了中国网络电视台的官网，这段视频还介绍了一些其他的功能。但当时我并不觉得它有多么神秘，不久就淡忘了。那是在2012年。\n\n　　如今三年过去了。一次翻看论坛，偶然看到了关于树莓派的帖子，才发现它在国内以野火燎原的速度流行起来，已经不可同日而语。从网上获取的对它的评价，也是一边倒的好评，这让我开始了重新认识它的旅程。\n\n　　树莓派最初的目的是教育用途的，开发者希望任何人通过树莓派都可以学会编程，同时也是开源的项目。所以树莓派必须要在易用性、性价比等方面做得非常优秀。它是这样的，而这也是它如此流行的重要原因。通过这两天使用，我也发现它相较于单片机、arduino等硬件最大的不同是，树莓派是真正的电脑，而其他的却是“伪”电脑。给你一台电脑，然后配上和外界沟通的接口（GPIO），你就可以用最简单、最接近人的思维的方式来实现你的想法，烦人的细节被完全过滤和屏蔽，这是树莓派的思路。我想每个用过树莓派的人都会有这种感受。\n\n　　下面是一个老外把树莓派用热气球送到太空后拍到的照片，事后还成功的进行了回收（好屌的说）。\n\n![space](/static/blog/img/project/20150628/space.jpg)",
"layout": "post",
"title": "树莓派之初见",
"category": "学习笔记",
"description": "乐于去改变，让事情变得更简单",
"tags": [
"编程",
"树莓派"
],
"preview": "![raspberrypi](/static/blog/img/project/20150628/raspberrypi.jpg)\n\n　　如果你是一位极客，那你必然听说过“树莓派”这个名词。我记得第一次听说树莓派的时候，是在网络上看到一段关于它的视频，开发者拿一块和身份证差不多大的电路板做演示，接上键盘和显示器，在英国就登陆了中国网络电视台的官网，这段视频还介绍了一些其他的功能。但当时我并不觉得它有多么神秘，不久就淡忘了。那是在2012年。\n\n　　如今三年过去了。一次翻看论坛，偶然看到了关于树莓派的帖子，才发现它在国内以野火燎原的速度流行起来，已经不可同日而语。从网上获取的对它的评价，也是一边倒的好评，这让我开始了重新认识它的旅程。\n\n　　树莓派最初的目的是教育用途的，开发者希望任何人通过树莓派都可以学会编程，同时也是开源的项目。所以树莓派必须要在易用性、性价比等方面做得非常优秀。它是这样的，而这也是它如此流行的重要原因。通过这两天使用，我也发现它相较于单片机、arduino等硬件最大的不同是，树莓派是真正的电脑，而其他的却是“伪”电脑。给你一台电脑，然后配上和外界沟通的接口（GPIO），你就可以用最简单、最接近人的思维的方式来实现你的想法，烦人的细节被完全过滤和屏蔽，这是树莓派的思路。我想每个用过树莓派的人都会有这种感受。\n\n　　下面是一个老外把树莓派用热气球送到太空后拍到的照片，事后还成功的进行了回收（好屌的说）。\n\n![space](/static/blog/img/project/20150628/space.jpg)",
"first_figure": "/static/blog/img/preview_0.jpg"
},
"20151026": {
"create_time": "2015年10月26日",
"id": 20151026,
"content": "##寻找子串\n　　寻找子串操作在文字处理中非常常用。假设目的字符串如“hello world”，要寻找子串“llo”第一次出现的位置，最直观的做法就是暴力匹配算法，算法思想是从目的串起始的0号位置与子串逐个字符匹配，如果成功返回0，若失败则再从目的串的1号位置与子串匹配，直到在目的串中找到子串，或者由于顺次后移使子串的尾巴超出目的串的尾巴而停止，前者返回正确的位置，后者则表示匹配失败，目的串中不含子串。\n\n　　暴力匹配的算法易于理解，但效率不高。如果目的串长度为m，子串长为n，则最坏的情况下要进行m*n次操作才能完成求解。<!--more-->因为它浪费了已经匹配过的结论，子串每次只顺次移动一位，而且目的串的指针回回朔，这在某些情况下是不必要的。比如：\n\n```\n第n次：\naaadbaac\n  |\naac\n\n第n+1次\naaadbaac\n |\n aac\n\n 第n+2次\naaadbaac\n  |\n aac\n\n...\n```\n\n　　首先在匹配之前我们已经得知子串的前2个字符相等，而在第一次匹配的时候发现子串和目的串的前2个字符也相等，也就是说，目的串的第2个字符显然等于子串的第1个字符。所以在目的串的第3个字符已经和子串比较了之后，再退回去重复比较目的串第2个字符和子串的第1个字符，这显然是冗余的操作。也就是说，上述“第n+1次”的操作是没有意义的。\n\n　　而kmp算法解决了这一问题，它预先对子串进行处理，获得一个next数组，保存了与子串结构相关的一些信息，在匹配的时利用子串的结构特点，避免目的串指针的回朔。对于上面的例子，kmp算法在第n次匹配失败后，目的串的指针为3（假设从1开始），此时可以从next数组中推算出一个重要信息：目的串的第2个字符和子串的第1个字符相同，也就是说此时要跳过“第n+1次”比较操作，而是直接将子串的第2个字符和目的串的第3个字符进行匹配。\n\n　　对于上述的例子，虽然kmp算法只跳过了一步，看起来优化效果微乎其微，但当串的长度为几百或者几千的时候，kmp算法将大大降低时间复杂度，提高程序运行效率。\n\n　　kmp算法博大精深，而我个人的水平有限，很多细节不能完整、通俗的表述，如有错误之处请不吝指正。kmp算法晦涩难懂，我曾看了好几本书都久久不能理解其先进之处，直到观看了《小甲鱼老师讲KMP》视频之后，大惑初解。小甲鱼老师讲KMP:\n\n<center>\n\t<iframe height=498 width=510 src=\"http://player.youku.com/embed/XNTg3MDkzNzY4\" frameborder=0 allowfullscreen></iframe>\n</center>\n\n下面给出kmp算法参考程序代码。\n\n![C](/static/blog/img/project/20151026/2015102601.png)\n",
"layout": "post",
"title": "KMP算法",
"category": "学习笔记",
"preview": "寻找子串操作在文字处理中非常常用。假设目的字符串如“hello world”，要寻找子串“llo”第一次出现的位置，最直观的做法就是暴力匹配算法，算法思想是从目的串起始的0号位置与子串逐个字符匹配，如果成功返回0，若失败则再从目的串的1号位置与子串匹配，直到在目的串中找到子串，或者由于顺次后移使子串的尾巴超出目的串的尾巴而停止，前者返回正确的位置，后者则表示匹配失败，目的串中不含子串。\n\n　　暴力匹配的算法易于理解，但效率不高。如果目的串长度为m，子串长为n，则最坏的情况下要进行m*n次操作才能完成求解。",
"first_figure": "/static/blog/img/preview_2.jpg"
},
"20170307": {
"create_time": "2017年3月7日",
"id": 20170307,
"content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n### wsgiref.simple_server\n　　这个模块实现了一个基于__BaseHTTPServer__的轻量级WSGI应用程序的服务器。每个server实例只能在设定的主机和端口上调用一个单一的WSGI应用程序，如果要想调用多个WSGI应用程序，必须手动解析PATH_INFO来给每个request做路由，然后决定调用哪个应用程序。\n\n* wsgiref.simple_server.__make_server(*host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler*)__\n\n\t创建一个WSGI server 来监听主机的端口，给*app*接收请求。返回的是*server_class *的实例，并且用指定的*handler_class *来处理request。app必须为PEP 333中定义的WSGI 应用程序对象。\n\n\t示例用法：\n\n\t\tfrom wsgiref.simple_server import make_server, demo_app\n\n\t\thttpd = make_server('', 8000, demo_app)\n\t\tprint \"Serving HTTP on port 8000...\"\n\n\t\t# Respond to requests until process is killed\n\t\thttpd.serve_forever()\n\n\t\t# Alternative: serve one request, then exit\n\t\thttpd.handle_request()\n\n* wsgiref.simple_server.__demo_app(*environ, start_response*)__\n\n\t一个小但完整的WSGI应用程序，返回一个text的页面包含“Hello world!”和一个在*environ *中提供的键值对构成的list，这个主要用来测试WSGI 服务器能否正确的运行一个WSGI应用程序。\n\n* __class__ wsgiref.simple_server.__WSGIServer(*server_address, RequestHandlerClass*)__\n\n\t创建一个WSGIServer的实例，*server_address*必须为(host, port)的元组，并且*RequestHandlerClass*也必须为__BaseHTTPServer.BaseHTTPRequestHandler__的派生类，否则不能正确的处理请求。\n\n\t通常这个方法不需要被调用，因为*make_server()*方法可以处理所有的细节。\n\n\t__WSGIServer__是以__BaseHTTPServer.HTTPServer__为基类的，所以所有BaseHTTPServer.HTTPServer支持的方法都是可用的，比如*server_forever()*、*handle_request()*。__WSGIServer__也提供了专有的方法，比如：\n\n\t* __get_environ()__\n\n\t\t返回WSGI环境变量的dict。默认的实现是，拷贝WSGIServer对象的base_environ dict的内容，然后加上HTTP请求Header导出来的变量再返回。每次请求都会返回PEP 333中定义的包含全部CGI相关的环境变量的全新的dict。\n\n\t* __get_stderr()__\n\n\t\t返回必须用wsgi.errors流的对象。默认的实现其实就是返回__sys.stderr__。\n\n\t* __handle()__\n\n\t\t处理HTTP请求。默认的实现是创建一个句柄实例使用__wsgiref.handlers__类来实际的WSGI API。\n\n### wsgiref.validate\n　　这个模块主要用来检查代码与规范的的一致性。它创建一个在服务器或者网关和应用程序之间检查一致性的function，用以确保两边都相符。\n\n　　需要注意的是，这个模块并不能保证全部的的PEP 333的规范，它没有报错并不意味错误不存在。但一旦它抛出错误，则服务器或者应用程序端必有错误。\n\n　　这个模块基于Ian Bicking的 “Python Paste” 库中的__parse.lint__扩展的。\n\n* wsgiref.validate.__validator(*application*)__\n\n\t装饰一个*application*并且返回一个新的application，返回的application会跟随原application所有的request，并且检查两边的处理是否都符合WSGI和 RFC 2616 中的定义。\n\n\t任何检测到的不服从一致性的错误都将以AssertionError抛出来，但需要注意的是，怎么抛出错误和处理是取决于服务器的。比如__simple_server__和其他基于__handlers__的服务器在错误发生时，会输出一个简单的消息，但如果其他的覆盖了错误处理和做了类似处理的服务器就可能不会抛出。\n\n\t这个装饰器也会用__warnings__模块生成警告，来标识没有明确在PEP 333中禁止但存在问题的行为。除非这些警告被命令行或者__warnings__ API禁止，否则都会被写入到__sys.stderr__。\n\n\t示例用法：\n\n\t\tfrom wsgiref.validate import validator\n\t\tfrom wsgiref.simple_server import make_server\n\n\t\t# Our callable object which is intentionally not compliant to the\n\t\t# standard, so the validator is going to break\n\t\tdef simple_app(environ, start_response):\n\t\t    status = '200 OK'  # HTTP Status\n\t\t    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n\t\t    start_response(status, headers)\n\n\t\t    # This is going to break because we need to return a list, and\n\t\t    # the validator is going to inform us\n\t\t    return \"Hello World\"\n\n\t\t# This is the application wrapped in a validator\n\t\tvalidator_app = validator(simple_app)\n\n\t\thttpd = make_server('', 8000, validator_app)\n\t\tprint \"Listening on port 8000....\"\n\t\thttpd.serve_forever()\n\n\n　",
"layout": "post",
"title": "Web Server Gateway Interface (simple_server和validate部分)",
"category": "学习笔记",
"tags": [
"编程",
"Python",
"WSGI"
],
"preview": "这个模块实现了一个基于__BaseHTTPServer__的轻量级WSGI应用程序的服务器。每个server实例只能在设定的主机和端口上调用一个单一的WSGI应用程序，如果要想调用多个WSGI应用程序，必须手动解析PATH_INFO来给每个request做路由，然后决定调用哪个应用程序。\n\n* wsgiref.simple_server.__make_server(*host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler*)__\n\n\t创建一个WSGI server 来监听主机的端口，给*app*接收请求。返回的是*server_class *的实例，并且用指定的*handler_class *来处理request。app必须为PEP 333中定义的WSGI 应用程序对象。\n\n\t示例用法：\n\n\t\tfrom wsgiref.simple_server import make_server, demo_app\n\n\t\thttpd = make_server('', 8000, demo_app)\n\t\tprint \"Serving HTTP on port 8000...\"\n\n\t\t# Respond to requests until process is killed\n\t\thttpd.serve_forever()\n\n\t\t# Alternative: serve one request, then exit\n\t\thttpd.handle_request()\n\n* wsgiref.simple_server.__demo_app(*environ, start_response*)__\n\n\t一个小但完整的WSGI应用程序，返回一个text的页面包含“Hello world!”和一个在*environ *中提供的键值对构成的list，这个主要用来测试WSGI 服务器能否正确的运行一个WSGI应用程序。\n\n* __class__ wsgiref.simple_server.__WSGIServer(*server_address, RequestHandlerClass*)__\n\n\t创建一个WSGIServer的实例，*server_address*必须为(host, port)的元组，并且*RequestHandlerClass*也必须为__BaseHTTPServer.BaseHTTPRequestHandler__的派生类，否则不能正确的处理请求。\n\n\t通常这个方法不需要被调用，因为*make_server()*方法可以处理所有的细节。\n\n\t__WSGIServer__是以__BaseHTTPServer.HTTPServer__为基类的，所以所有BaseHTTPServer.HTTPServer支持的方法都是可用的，比如*server_forever()*、*handle_request()*。__WSGIServer__也提供了专有的方法，比如：\n\n\t* __get_environ()__\n\n\t\t返回WSGI环境变量的dict。默认的实现是，拷贝WSGIServer对象的base_environ dict的内容，然后加上HTTP请求Header导出来的变量再返回。每次请求都会返回PEP 333中定义的包含全部CGI相关的环境变量的全新的dict。\n\n\t* __get_stderr()__\n\n\t\t返回必须用wsgi.errors流的对象。默认的实现其实就是返回__sys.stderr__。\n\n\t* __handle()__\n\n\t\t处理HTTP请求。默认的实现是创建一个句柄实例使用__wsgiref.handlers__类来实际的WSGI API。\n\n### wsgiref.validate\n　　这个模块主要用来检查代码与规范的的一致性。它创建一个在服务器或者网关和应用程序之间检查一致性的function，用以确保两边都相符。\n\n　　需要注意的是，这个模块并不能保证全部的的PEP 333的规范，它没有报错并不意味错误不存在。但一旦它抛出错误，则服务器或者应用程序端必有错误。\n\n　　这个模块基于Ian Bicking的 “Python Paste” 库中的__parse.lint__扩展的。\n\n* wsgiref.validate.__validator(*application*)__\n\n\t装饰一个*application*并且返回一个新的application，返回的application会跟随原application所有的request，并且检查两边的处理是否都符合WSGI和 RFC 2616 中的定义。\n\n\t任何检测到的不服从一致性的错误都将以AssertionError抛出来，但需要注意的是，怎么抛出错误和处理是取决于服务器的。比如__simple_server__和其他基于__handlers__的服务器在错误发生时，会输出一个简单的消息，但如果其他的覆盖了错误处理和做了类似处理的服务器就可能不会抛出。\n\n\t这个装饰器也会用__warnings__模块生成警告，来标识没有明确在PEP 333中禁止但存在问题的行为。除非这些警告被命令行或者__warnings__ API禁止，否则都会被写入到__sys.stderr__。\n\n\t示例用法：\n\n\t\tfrom wsgiref.validate import validator\n\t\tfrom wsgiref.simple_server import make_server\n\n\t\t# Our callable object which is intentionally not compliant to the\n\t\t# standard, so the validator is going to break\n\t\tdef simple_app(environ, start_response):\n\t\t    status = '200 OK'  # HTTP Status\n\t\t    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n\t\t    start_response(status, headers)\n\n\t\t    # This is going to break because we need to return a list, and\n\t\t    # the validator is going to inform us\n\t\t    return \"Hello World\"\n\n\t\t# This is the application wrapped in a validator\n\t\tvalidator_app = validator(simple_app)\n\n\t\thttpd = make_server('', 8000, validator_app)\n\t\tprint \"Listening on port 8000....\"\n\t\thttpd.serve_forever()\n\n\n　",
"first_figure": "/static/blog/img/project/20160811/0.jpg"
},
"20160811": {
"create_time": "2016年8月11日",
"id": 20160811,
"content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n　　Django项目不像PHP等有着好用的LNMP一键安装包，并且由于Django版本更新迭代较快，版本间有诸多不兼容，导致部署到生产服务器的这一工作变得比较棘手。我在网上找了各种教程，大多是7、8年前甚至十几年前的例子，几乎不可用。折腾了一番，最终在Django中国社区找到一篇比较新的帖子，并照着教程终于部署成功。\n<!--more-->\n　　于是对照此帖进行整理，留备复阅。点此访问原帖：\n\n　　· <a  target='_blank'href=\"http://www.django-china.cn/topic/101/\">五步教你实现使用Nginx+uWSGI+Django方法部署Django程序（上）</a><br />　　· <a  target='_blank'href=\"http://www.django-china.cn/topic/124/\">五步教你实现使用Nginx+uWSGI+Django方法部署Django程序（下）</a> \n\n　　我使用的环境是：\n\n* Ubuntu 16.04 LTS\n* Django 1.9.4\n* python 2.7.11\n* nginx  1.10.0\n* uwsgi  2.0.13.1\n\n一、安装Django，使其能正常工作。此处创建一个名为webapp的Django项目，目录树为：\n```\n/\n└── home\n    ├── wwwroot\n    │   └── webapp\n            ├── manage.py\n            ├── webapp\n            │   └── ...            \n            ...\n...\n```\n　　此时在工程根目录/home/wwwroot/webapp/下运行```python manage.py runserver 0.0.0.0:8000```，访问服务器（端口号8000）可以看到Django默认的首页。\n\n二、安装pip。Ubuntu使用命令```apt install python-pip```即可。\n\n三、安装uWSGI。 \n```\nexport LDFLAGS=\"-Xlinker --no-as-needed\"\npip install uwsgi\n```\n　　这一步是最坑的。之前使用debian7 32位的系统，使用pip安装完成之后，运行uWSGI竟然说找不到命令。于是使用apt-get安装，有多个包可选，我选择了uwsgi、uwsgi-core、uwsgi-plugin-python三个包，多次试验最后始终遇到一个问题，就是运行时报错：\n```\nuwsgi: option ...\n    getopt_long() error.\n```\n　　多篇帖子指明，此类错误是因为没有安装libxml库导致，因此我重新安装libxml2，结果依然报错。个人臆断（没有任何根据）getopt_long()可能跟机子的位数有关，于是打算安一个64位的系统再试试。换上Ubuntu 16.04，重新执行上述步骤，没有再报错。\n\n四、测试uWSGI\n\n　　在某个目录创建下述文件，保存为test.py。然后shell执行```uwsgi --http :8001 --wsgi-file test.py```命令。不要怀疑你看错了或者我写错了，参数确实是```--wsgi-file```。\n\n```\ndef application(env, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\n    return \"Hello World\"\n```\n　　如果此时访问服务器（端口号8001），返回“hello world”则uWSGI正常运作。\n\n五、配置Django\n\n　　原帖的做法是在Django工程根目录下创建django_wsgi.py，但对于1.9.4版本的django来讲，这一步不需要。它已经自动生成了wsgi.py，保存在工程根目录下跟工程同名的文件夹中，对于此例，它位于：/home/wwwroot/webapp/webapp/。所以直接执行```uwsgi --http :8000 --chdir /home/wwwroot/webapp/ --module webapp.uwsgi```。若一切正常，访问服务器（端口号8000），就能看到django默认的首页。\n\n六、配置uWSGI\n\n　　在工程根目录下创建djangochina_socket.xml。文件名可以随意起。uWSGI启动时将读取此配置文件，与nginx协同工作。\n```\n<uwsgi>\n    <socket>:8077</socket>\n    <chdir>/home/wwwroot/webapp/</chdir>\n    <module>webapp.wsgi</module>\n    <processes>1</processes>\n    <daemonize>uwsgi.log</daemonize>\n</uwsgi>\n```\n　　参数的含义：\n\n- socket： nginx与uWSGI通信的端口号\n- chdir: Django工程根目录\n- module：指定uwsgi文件\n- processes：同时处理进程数\n- daemonize：日志文件\n\n七、配置nginx\n\n　　Ubuntu下使用apt安装nginx，默认配置文件在/etc/nginx/nginx.conf。编辑该文件：\n\n```\nserver {\n        \n        # web服务端口号\n        listen   80;\n\n        # 域名\n        server_name caoliang.net;\n\n        # 日志文件\n        access_log /home/log/access.log;\n        error_log /home/log/error.log;\n\n        location / {\n            include        uwsgi_params;\n\n            # 与uWSGI通信的端口号\n            uwsgi_pass     127.0.0.1:8077;\n        }\n\n        error_page  404              /404.html;\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # 静态文件路径\n        location /static/ {\n            alias  /home/wwwroot/webapp/books/static/;\n            index  index.html index.htm;\n        }\n\n        # media文件路径\n        location /media/ {\n            alias  /home/work/src/sites/testdjango1/testdjango/public/media/;\n        }\n}\n```\n\n八、运行\n\n　　运行```nginx -s  reload```重新载入nginx配置文件。然后启动uWSGI：```uwsgi -x /home/wwwroot/webapp/djangochina_socket.xml```。访问域名，正常的话就可以看到Django的默认首页了。\n\n　　结束uWSGI只需杀死进程即可。上传html和静态文件到服务器，不需要重启django服务。此时需要做的就是关闭Django的Debug模式，以免暴露敏感信息。\n\n　　再次感谢<a href=\"http://www.django-china.cn/user/1/\" target='_blank'>Django中国社区</a>。\n",
"layout": "post",
"title": "借助Nginx+uWSGI，部署Django项目到生产环境",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "Django项目不像PHP等有着好用的LNMP一键安装包，并且由于Django版本更新迭代较快，版本间有诸多不兼容，导致部署到生产服务器的这一工作变得比较棘手。我在网上找了各种教程，大多是7、8年前甚至十几年前的例子，几乎不可用。折腾了一番，最终在Django中国社区找到一篇比较新的帖子，并照着教程终于部署成功。\n",
"first_figure": "/static/blog/img/project/20160811/0.jpg"
},
"20150128": {
"create_time": "2015年1月28日",
"id": 20150128,
"content": "\n## MySQL的常用查询方法\n\nMySQL的查询语句主要以select为主。下面为主要的查询语句。\n\n基本语法：\n\n```\nSELECT * FROM tb_name [WHERE CONDITION] \n```\n\n1、将表的数据全部列出\n\n```\nSELECT * FROM tb_name\n```\n\n2、列出表的部分字段\n\n```\nSELECT field_1,field_2 ... FROM tb_name\n```\n例如：\n```\nmysql> desc main_info;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| id       | int(2)      | YES  |     | NULL    |       |\n| name     | varchar(10) | YES  |     | NULL    |       |\n| age      | int(2)      | YES  |     | NULL    |       |\n| birthday | date        | YES  |     | NULL    |       |\n| workyear | int(2)      | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n\nmysql> select id,name from main_info;\n+------+----------+\n| id   | name     |\n+------+----------+\n|    1 | caoliang |\n|    2 | liang    |\n|    3 | zhangsan |\n+------+----------+\n```\n\n3、查询不重复的记录\n```\nSELECT DISTINCT field FROM tb_name\n```\n\n4、排序和限制\n\n\n```\nSELECT * FROM tb_name [WHERE CONDITION] [ORDER BY field_1 [DESC/ASC],feild_2 [DESC/ASC] ... ]\n```\n\n其中DESC 为降序排列，ASC为升序排列，不指定则默认升序。后面可以跟多个字段，当有多条记录的第一个字段的值相同时，则按照语句规定的第二个字段的规则进行排序，否则这些记录将随机排序。例如：(注意id和workyear的排序)\n\n```\nmysql> select * from main_info ;                \n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n+------+----------+------+------------+----------+\n\nmysql> select * from main_info order by id desc,workyear asc;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n+------+----------+------+------------+----------+\n\nmysql> select * from main_info order by id desc,workyear desc;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n+------+----------+------+------------+----------+\n```\n\n5、隐藏部分记录\n\n```\nSELECT * FROM tb_name [LIMIT offset_start,row_count]\n```\nLIMIT的第一个参数为起始的行，默认为0，显示从起始行开始row_count行的记录。需要注意的是，它通常搭配ORDER BY命令一起使用，提供分页浏览的功能。\n\n6、聚合操作\n```\nSELECT field_1,field_2 ... fun_name FROM tb_name\n[WHERE CONDITION]\n[GROUP BY field_1,field_2 ... [WITH ROLLUP] ]\n[HAVING CONDITION]\n```\n\n上述的```fun_name```是聚合操作函数，例如求和操作```sum```，记录数```count```等。\n\"GROUP BY\"表示分类的字段，比如统计相同姓名的人：\n```\nmysql> select  name,count(1) from main_info group by name WITH ROLLUP;\n+----------+----------+\n| name     | count(1) |\n+----------+----------+\n| caoliang |        1 |\n| liang    |        2 |\n| lisi     |        1 |\n| zhangsan |        1 |\n| NULL     |        5 |\n+----------+----------+\n```\n而```WITH ROLLUP```表示在分类之后，将数据再聚合。可以看到上述最后一行，就是```WITH ROLLUP```输出的结果。\n\n",
"layout": "post",
"title": "MySQL(4):常用查询方法",
"category": "学习笔记",
"description": "MySQL的常用查询方法",
"tags": [
"MySQL"
],
"preview": "MySQL的查询语句主要以select为主。下面为主要的查询语句。\n\n基本语法：\n\n```\nSELECT * FROM tb_name [WHERE CONDITION] \n```\n\n1、将表的数据全部列出\n\n```\nSELECT * FROM tb_name\n```\n\n2、列出表的部分字段\n\n```\nSELECT field_1,field_2 ... FROM tb_name\n```\n例如：\n```\nmysql> desc main_info;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| id       | int(2)      | YES  |     | NULL    |       |\n| name     | varchar(10) | YES  |     | NULL    |       |\n| age      | int(2)      | YES  |     | NULL    |       |\n| birthday | date        | YES  |     | NULL    |       |\n| workyear | int(2)      | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n\nmysql> select id,name from main_info;\n+------+----------+\n| id   | name     |\n+------+----------+\n|    1 | caoliang |\n|    2 | liang    |\n|    3 | zhangsan |\n+------+----------+\n```\n\n3、查询不重复的记录\n```\nSELECT DISTINCT field FROM tb_name\n```\n\n4、排序和限制\n\n\n```\nSELECT * FROM tb_name [WHERE CONDITION] [ORDER BY field_1 [DESC/ASC],feild_2 [DESC/ASC] ... ]\n```\n\n其中DESC 为降序排列，ASC为升序排列，不指定则默认升序。后面可以跟多个字段，当有多条记录的第一个字段的值相同时，则按照语句规定的第二个字段的规则进行排序，否则这些记录将随机排序。例如：(注意id和workyear的排序)\n\n```\nmysql> select * from main_info ;                \n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n+------+----------+------+------------+----------+\n\nmysql> select * from main_info order by id desc,workyear asc;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n+------+----------+------+------------+----------+\n\nmysql> select * from main_info order by id desc,workyear desc;\n+------+----------+------+------------+----------+\n| id   | name     | age  | birthday   | workyear |\n+------+----------+------+------------+----------+\n|    4 | liang    |   21 | 2015-09-16 |       12 |\n|    3 | lisi     |   25 | 2015-09-16 |       11 |\n|    3 | zhangsan |   25 | 2015-09-16 |        9 |\n|    2 | liang    |   21 | 2015-09-16 |       10 |\n|    1 | caoliang |   22 | 2015-09-16 |       10 |\n+------+----------+------+------------+----------+\n```\n\n5、隐藏部分记录\n\n```\nSELECT * FROM tb_name [LIMIT offset_start,row_count]\n```\nLIMIT的第一个参数为起始的行，默认为0，显示从起始行开始row_count行的记录。需要注意的是，它通常搭配ORDER BY命令一起使用，提供分页浏览的功能。\n\n6、聚合操作\n```\nSELECT field_1,field_2 ... fun_name FROM tb_name\n[WHERE CONDITION]\n[GROUP BY field_1,field_2 ... [WITH ROLLUP] ]\n[HAVING CONDITION]\n```\n\n上述的```fun_name```是聚合操作函数，例如求和操作```sum```，记录数```count```等。\n\"GROUP BY\"表示分类的字段，比如统计相同姓名的人：\n```\nmysql> select  name,count(1) from main_info group by name WITH ROLLUP;\n+----------+----------+\n| name     | count(1) |\n+----------+----------+\n| caoliang |        1 |\n| liang    |        2 |\n| lisi     |        1 |\n| zhangsan |        1 |\n| NULL     |        5 |\n+----------+----------+\n```\n而```WITH ROLLUP```表示在分类之后，将数据再聚合。可以看到上述最后一行，就是```WITH ROLLUP```输出的结果。\n\n",
"first_figure": "/static/blog/img/preview_4.jpg"
},
"20150428": {
"create_time": "2015年4月28日",
"id": 20150428,
"content": "##函数的指针\n　　在我们使用指针时，通常使用的是另一个变量的地址值，这样可以在不同的时间使用同一个指针来访问不同的变量。除此之外，指针还可以指向函数的地址，这也就意味着，我们也可以通过指针来调用函数。指针是不是很强大？\n\n　　我们可以这样声明一个函数，并声明一个函数的指针来指向这个函数,并通过调用函数的指针来调用该函数：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tdouble sum(int a, double b)\n\t\t{\n\t\t\treturn (static_cast<double>(a) + b) ;\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tdouble (*psum)(int , double) = sum;\n\n\t\t\tcout<<psum(3,6)\n\t\t\t\t<<endl;\n\t\t}\n\n\n　　程序输出结果9。需要注意的是，声明函数sum的指针psum时，用圆括号把*psum包含起来。如果不这么做，则实际上是在声明一个函数的原型，而不是在声明指针。还可以利用一个更简单的方法来声明函数指针，就是利用auto关键字，如：```auto psum = sum ;```只要之前定义了sum的函数原型，编译器就能够理解编程者的意图，自动将psum设定为sum函数的指针类型。另外，如果给函数指针赋予一个与声明时的函数原型不相同的函数，编译将不会通过，所以函数指针的声明要和指向函数的原型保持一致。\n\n##为什么要用函数的指针\n　　如同使用变量的指针一样，使用函数的指针可以利用一个函数指针，在不同的时候调用不同的函数。假如要编写这样一个函数：在某些情况下，该函数要产生数组中所有元素的平方和，而另一些情况下需要产生它们的立方和。一种实现方法是，利用函数的指针来作为实参。程序如下：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tdouble squared(double a){\n\t\t\treturn (a*a);\n\t\t}\n\n\t\tdouble\tcubed(double a){\n\t\t\treturn (a*a*a);\n\t\t}\n\n\t\tdouble sumarray(double count[], int length, double (*pfunction)(double)){\n\t\t\tdouble\ttotal(0);\n\n\t\t\tfor (int i = 0; i<length; i++)\n\t\t\t\ttotal += pfunction(count[i]) ;\n\n\t\t\treturn\ttotal;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tdouble\tdata[]={2.0, 4.0, 6.0, 8.0};\n\t\t\tint len = (sizeof(data) / sizeof(data[0]));\n\n\t\t\tcout<<\"squared:\"<<sumarray(data,len,squared)<<endl\n\t\t\t\t<<\"cubed:\"<<sumarray(data,len,cubed)<<endl;\n\t\t}\n\n　　其中```int len = (sizeof(data) / sizeof(data[0]));```的作用是计算出数组data[]中元素的个数，给sizeof操作符传递数组名作为实参，则它会返回该数组占用的所有内存，再除以单个元素占用的空间，便不难得出数组元素的个数。程序的结果是在第一行输出squared:120，在第二行输出cubed:800。这恰好分别是数组data各元素的平方和和立方和。这里把函数的指针作为实参来传递给另一个函数供其调用，传递不同函数指针来执行不同的函数。当然可以用更简单的办法来实现，但在某些非常复杂的情况下，使用函数指针来处理事情显得更加方便。\n\n##函数指针的数组\n　　如同常规指针一样，可如下来使用函数指针数组：\n\n\t\tdouble fun1(double );\n\t\tdouble fun2(double );\n\t\tdouble fun3(double );\n\n\t\tdouble (*pfun[])(double ) = {fun1, fun2, fun3};\n\n　　此时不能通过auto关键字来推测数组的类型，所以必须向上述一样声明函数指针的数组。数组的各个元素分别初始化为大括号里对应的函数的地址，数组长度由列表中的初始值的个数来决定。此时如果要调用数组中第二个元素，可以这样写：```pfun[1](a);```，其中a为double型的实参。\n\n##为函数形参设定默认值\n　　在声明函数时，可以给括号内的形参赋予初始值。如果在调用函数时没有填入参数，则函数按照默认值来执行，如果填入参数，则默认值将丢弃。例如 ```int sum(int a=30, int b=20){return (a+b);}```,如果执行```sum();```,则能得到返回值50。\n\n　　如果在调用时省略形参，则只可以从右往左省略。例如，```int do(int a=1, int b=2, int c=3)```,如果要省略c，则只可以省略最后一个c，```do(4,5,)；```是一个正确的使用方法；如果要省略b，则c也必须省略，```do(3,,8);```是错误的使用方法，应该改写为：```do(3,,);```。",
"layout": "post",
"title": "学习C++之五：函数的指针",
"category": "学习笔记",
"description": "让函数做更多的事情",
"preview": "在我们使用指针时，通常使用的是另一个变量的地址值，这样可以在不同的时间使用同一个指针来访问不同的变量。除此之外，指针还可以指向函数的地址，这也就意味着，我们也可以通过指针来调用函数。指针是不是很强大？\n\n　　我们可以这样声明一个函数，并声明一个函数的指针来指向这个函数,并通过调用函数的指针来调用该函数：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tdouble sum(int a, double b)\n\t\t{\n\t\t\treturn (static_cast<double>(a) + b) ;\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tdouble (*psum)(int , double) = sum;\n\n\t\t\tcout<<psum(3,6)\n\t\t\t\t<<endl;\n\t\t}\n\n\n　　程序输出结果9。需要注意的是，声明函数sum的指针psum时，用圆括号把*psum包含起来。如果不这么做，则实际上是在声明一个函数的原型，而不是在声明指针。还可以利用一个更简单的方法来声明函数指针，就是利用auto关键字，如：```auto psum = sum ;```只要之前定义了sum的函数原型，编译器就能够理解编程者的意图，自动将psum设定为sum函数的指针类型。另外，如果给函数指针赋予一个与声明时的函数原型不相同的函数，编译将不会通过，所以函数指针的声明要和指向函数的原型保持一致。\n\n##为什么要用函数的指针\n　　如同使用变量的指针一样，使用函数的指针可以利用一个函数指针，在不同的时候调用不同的函数。假如要编写这样一个函数：在某些情况下，该函数要产生数组中所有元素的平方和，而另一些情况下需要产生它们的立方和。一种实现方法是，利用函数的指针来作为实参。程序如下：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tdouble squared(double a){\n\t\t\treturn (a*a);\n\t\t}\n\n\t\tdouble\tcubed(double a){\n\t\t\treturn (a*a*a);\n\t\t}\n\n\t\tdouble sumarray(double count[], int length, double (*pfunction)(double)){\n\t\t\tdouble\ttotal(0);\n\n\t\t\tfor (int i = 0; i<length; i++)\n\t\t\t\ttotal += pfunction(count[i]) ;\n\n\t\t\treturn\ttotal;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tdouble\tdata[]={2.0, 4.0, 6.0, 8.0};\n\t\t\tint len = (sizeof(data) / sizeof(data[0]));\n\n\t\t\tcout<<\"squared:\"<<sumarray(data,len,squared)<<endl\n\t\t\t\t<<\"cubed:\"<<sumarray(data,len,cubed)<<endl;\n\t\t}\n\n　　其中```int len = (sizeof(data) / sizeof(data[0]));```的作用是计算出数组data[]中元素的个数，给sizeof操作符传递数组名作为实参，则它会返回该数组占用的所有内存，再除以单个元素占用的空间，便不难得出数组元素的个数。程序的结果是在第一行输出squared:120，在第二行输出cubed:800。这恰好分别是数组data各元素的平方和和立方和。这里把函数的指针作为实参来传递给另一个函数供其调用，传递不同函数指针来执行不同的函数。当然可以用更简单的办法来实现，但在某些非常复杂的情况下，使用函数指针来处理事情显得更加方便。\n\n##函数指针的数组\n　　如同常规指针一样，可如下来使用函数指针数组：\n\n\t\tdouble fun1(double );\n\t\tdouble fun2(double );\n\t\tdouble fun3(double );\n\n\t\tdouble (*pfun[])(double ) = {fun1, fun2, fun3};\n\n　　此时不能通过auto关键字来推测数组的类型，所以必须向上述一样声明函数指针的数组。数组的各个元素分别初始化为大括号里对应的函数的地址，数组长度由列表中的初始值的个数来决定。此时如果要调用数组中第二个元素，可以这样写：```pfun[1](a);```，其中a为double型的实参。\n\n##为函数形参设定默认值\n　　在声明函数时，可以给括号内的形参赋予初始值。如果在调用函数时没有填入参数，则函数按照默认值来执行，如果填入参数，则默认值将丢弃。例如 ```int sum(int a=30, int b=20){return (a+b);}```,如果执行```sum();```,则能得到返回值50。\n\n　　如果在调用时省略形参，则只可以从右往左省略。例如，```int do(int a=1, int b=2, int c=3)```,如果要省略c，则只可以省略最后一个c，```do(4,5,)；```是一个正确的使用方法；如果要省略b，则c也必须省略，```do(3,,8);```是错误的使用方法，应该改写为：```do(3,,);```。",
"first_figure": "/static/blog/img/preview_1.jpg"
},
"20180101": {
"create_time": "2018年1月1日",
"id": 20180101,
"content": "<img src=\"/static/blog/img/blog/20180101/1.jpg\" style=\"width: 100%\">\n\n　　离职后的第二天，窗外的阳光洒了一地，我情不自禁地想去外面透透气。西安沣惠南路的公园里，它流质的光束在我脚下倾泻，从来没有哪个冬日让我感到如此惬意。\n\n<!--more-->\n<img src=\"/static/blog/img/blog/20180101/2.jpg\" style=\"width: 100%\">\n　　这个公园的名字叫牡丹庄园，可惜这是万籁俱寂的冬天，所有的花都已经凋零，这里除了一些四季常青的灌木和松树，再也没有其他的颜色。\n\n　　我往园子中间走了几步，发现一个紧闭的铁门，铁门两侧是古风的对联，可惜这种文字我只字不识。还有一个小牌子，写道\"茶艺、书吧、简餐\"，我走进看了看，里面有一列小桌子和隔断，看起来是一个宁静祥和的场所。门前还有一把撑开的大伞，伞下的吊扇已经没有的叶片，年久失修，呈现出一片破败，也让我感到一丝悲凉。\n\n<img src=\"/static/blog/img/blog/20180101/3.jpg\" style=\"width: 50%;float:left;margin-right: 1px;\">\n<img src=\"/static/blog/img/blog/20180101/4.jpg\" style=\"width: calc(50% - 1px);float:left;\">\n\n\n　　如果这个书吧没有关闭多好。一盏清茗，品读一本自己喜欢的书卷，身旁环绕的都是鸟鸣和朝阳，而不再有什么项目的进度和各种会议……即使什么也不做，在暖人的阳光下小觑一会，也是一段多么难得的时光。\n\n　　可这样的生活毕竟太理想化了。有些东西之所以迷人，就因为它实在难得获得。过着城市快节奏的生活，谁会常有这样的闲情雅致去探寻生活本来的样子呢？顶多也就是凌晨夜深人静时感慨一下，原来这一天又像重复着的昨天一样默默无闻的过去了…… 也正是因为这样的书吧难以为继，它才能这么迷人，成为人的心中所向往的地方吧。\n\n\n<img src=\"/static/blog/img/blog/20180101/5.jpg\" style=\"width: 100%\">\n<img src=\"/static/blog/img/blog/20180101/6.jpg\" style=\"width: 100%\">",
"title": "遗忘的书吧",
"category": "观点",
"tags": [
"生活"
],
"preview": "离职后的第二天，窗外的阳光洒了一地，我情不自禁地想去外面透透气。西安沣惠南路的公园里，它流质的光束在我脚下倾泻，从来没有哪个冬日让我感到如此惬意。\n\n",
"first_figure": "/static/blog/img/blog/20180101/1.jpg"
},
"20150508": {
"create_time": "2015年5月8日",
"id": 20150508,
"content": "##复制构造函数\n　　构造函数是在创建一个类对象的时候，由系统自动调用的，复制构造函数也可以理解为构造函数一种，因为他们不仅有共同的函数名，而且他们的目的也十分相似。而复制构造函数是在复制一个对象时调用的。如果不去手动编写复制构造函数，系统会自动提供一个，但只是简单的复制类的各个成员。下面是一个实例：\n\n\t\tclass CMassage\n\t\t{\n\t\tprivate:\n\t\t\tchar* pMassage;\n\t\tpublic:\n\t\t\tCMassage(const char* text = \"some massage.\"){\n\t\t\t\tpMassage = new char[strlen(text) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(text) + 1, text);\n\t\t\t}\n\n\t\t\tCMassage(const CMassage & aMsg){\n\t\t\t\tpMassage = new char [strlen(aMsg.pMassage) + 1];\n\t\t\t\tstrcpy_s(pMassage,strlen(aMsg.pMassage) + 1,aMsg.pMassage);\n\t\t\t}\n\n\t\t\t~CMassage(){\n\t\t\t\tdelete [] pMassage;\n\t\t\t}\n\n\t\t\tvoid Show() const {\n\t\t\t\tcout << pMassage << endl;\n\t\t\t}\n\t\t};\n\n\n　　其中第一个函数是带有默认形参值的构造函数，初始化具体类对象时，如果不带形参就会把对象初始化为“some massage.”。第二个是复制构造函数，需要注意的是实参类型为const的类对象的引用。使用const是因为复制构造函数不需要修改类对象的值，如果不这么做，则在复制const型的类对象时，编译无法通过；使用引用的目的是，防止在给函数传递实参时，为了复制实参而对复制构造函数无休止的调用。\n\n　　上述最后一个函数是该类的析构函数。在类对象到达作用域的结束位置时，系统调用析构函数释放为成员分配的内存空间。通常析构函数也做一些收尾工作，在程序结束后由系统调用。如果析构函数发生异常错误，有可能导致程序崩溃，所以我们也曾遇到过这种情况，在关闭某个软件后，还会弹出一个错误提示。\n\n　　大多数人都知道，当类中含有指针或者数组类型的数据成员时，如果使用系统提供的默认复制构造函数就会发生潜在的危险。因为默认的构造函数会把两个对象的数据成员，也就是两个指针赋成同一个值，当其中一个类对象被析构后，如果还要使用另一个对象，就会发生一些异常状况，因为它的指针指向的空间已经被释放，可能是别的程序正在使用的一块空间。那么，如果在程序中不去复制两个同类的对象时，是否不再需要编写复制构造函数呢？看下面的实例：\n\n\t\tvoid DisplayMsg(CMassage X){\n\t\t\tX.Showit();\n\t\t};\n\n\t\tCMassage aMsg(\"hello world !\");\n\t\tDisplayMsg(aMsg);\n\n　　当没有编写复制构造函数时，上述函数在调用CMassage的具体对象X作为实参时，编译器会复制一个X的副本，因为实参的传递是按值传递进行的。当```DisplayMsg()```函数执行完毕后，系统会调用CMassage的析构函数，来释放副本的指针。需要注意的是，X的副本和X本身的成员指针都指向同一区域，因此只是调用了显示的函数```DisplayMsg()```，就同时把X的空间给删除掉了。\n\n　　所以，当动态的给类中的成员分配内存时，必须编写复制构造函数。\n\n##重载赋值运算符“=”\n　　记得在之前的类构造函数中有提到，如果构造函数只有一个参数，而且没有指定为explicit方式来构造类对象，则可以使用“=”来初始化类的成员，但需要注意的是，在此过程中有可能涉及隐式的类型转换。可以运行下面的程序：\n\n\t\t#include<iostream>\n\t\t#include<cstring>\n\n\t\tusing namespace std;\n\n\t\tclass CMassage\n\t\t{\n\t\tprivate:\n\t\t\tchar* pMassage;\n\t\tpublic:\n\t\t\tCMassage(const char * text = \"some massage.\"){\n\t\t\t\tcout << \"Construstor ... \";\n\t\t\t\tpMassage = new char[strlen(text) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(text) + 1, text);\n\t\t\t\tcout << \"called !\" << endl;\n\t\t\t}\n\n\t\t\tCMassage(const CMassage & aMsg){\t\t\n\t\t\t\tif (pMassage != nullptr)  delete[] pMassage;\n\t\t\t\tpMassage = new char[strlen(aMsg.pMassage) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(aMsg.pMassage) + 1, aMsg.pMassage);\n\t\t\t\tcout << \"Copy construstor called !\" << endl;\n\t\t\t}\n\n\t\t\t~CMassage(){\t\t\n\t\t\t\tcout << \"Disconstrustor ... \";\n\t\t\t\tdelete[] pMassage;\n\t\t\t\tpMassage = nullptr;\n\t\t\t\tcout << \"called !\" << endl;\n\t\t\t}\n\n\t\t\tvoid Showit() const {\n\t\t\t\tcout << pMassage << endl;\n\t\t\t}\n\t\t};\n\t\tvoid main()\n\t\t{\n\t\t\t{\n\t\t\t\tconst char* const  p = \"how are you?\";\n\t\t\t\tCMassage aMsg = p;\n\t\t\t\tCMassage bMsg;\n\t\t\t\tbMsg = p;\n\t\t\t\taMsg.Showit();\n\t\t\t\tbMsg.Showit();\n\t\t\t}\n\t\t\t\twhile (true);\n\t\t}\n\n　　先来分析一下上面的程序：先定义了指向常量字符串数组的常量指针p，然后用p来初始化aMsg，接着初始化bMsg，然后使bMsg等于p，最后显示输出。程序的构造函数中，一开始就输出“Construstor ...”，结束时输出“called!”，这有利于直观的观察构造函数执行的情况——如果函数执行到一半，就不会输出“called!”。析构函数也以同样的方式编写。如果按照我们的所想象的，程序应该输出：\n\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\thow are you?\n\t\thow are you?\n\t\tDisconstrustor ... called !\n\t\tDisconstrustor ... called !\n\n但事实上，程序的输出是这样的：\n\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\tDisconstrustor ... called !\n\t\thow are you?\n\t\t[乱码]\n\t\tDisconstrustor ...\n\n其中“[乱码]”表示程序在此处输出的是一串乱码。伴随而来的是，弹出一个debug的错误。而程序编译并没有任何错误和警告，在运行时却发生错误，为什么呢？\n\n　　仔细分析程序的输出，发现有两点可疑的地方：一是，在整个过程中竟然调用了三次构造函数，在第三次构造函数调用完成后，紧接着又调用了一次析构函数；二是，程序在第二次调用析构函数的时候，崩溃了，此时析构函数尚未执行完毕。\n\n　　首先说第一个可疑的地方。我们在main()函数中只声明了两个类对象实例，而第三次调用构造函数是什么作用呢？可能是用来给bMsg的pMassage来实现赋值。通过调试发现第三次的构造函数发生在语句```bMsg = p;```，因此这么推测貌似有一定道理。但是，为什么接着又调用一次析构函数呢？如果仅仅是给bMsg来赋值的话，是没有必要调用析构函数的——析构函数仅仅在一个类实例完成作用域后使用的，而此处的aMsg和bMsg显然没有到达作用域的结尾。没有新的对象产生，就不会调用析构函数。所以，此处的解释就是：在执行```bMsg = p;```的时候，一定产生了一个新的类对象，而且在这一句运行结束之后，新的对象的作用域也就结束了。\n\n　　此时不难想到，在函数调用的时候，是“按值传递”的，它会创建一个实参的副本。所以，此处一定是创建了类对象的副本，恰好在```bMsg = p;```执行完毕后，副本的作用域也结束，正好符合上述的情况。但此处创建的副本，是谁的副本呢？显然，是指针p的副本，只不过在创建p的副本之后，系统又进行了一次隐式的类型转换，将“cont char *”转化为“CMassage”类型，第三次调用构造函数也就发生在此时。为了验证类型的转换也会调用类构造函数，可以运行下面的程序：\n\n\t\tvoid main()\n\t\t{\n\t\t\t{\n\t\t\t\tconst char* const  p = \"how are you?\";\n\t\t\t\tstatic_cast<CMassage>(p);\n\t\t\t}\n\t\t\t\twhile (true);\n\t\t}\n\n可以看到，程序输出：\n\n\t\tConstrustor ... called !\n\t\tDisconstrustor ... called !\n\n　　接着分析。这时```bMsg = p;```并未执行完毕。它不去调用复制构造函数，而是调用赋值运算符“=”，来使得副本p的类实例的pMassage的值与bMsg的pMassage的值相等。此时，这两个指针指向同一块区域，内容是“how are you?”。然后副本p的类实例完成使命，调用析构函数将其删除。而此时，悲剧发生，因为bMsg.pMassage指向的空间也被释放了。\n\n　　到了此时，第二个问题也迎刃而解，报告的错误是：\n\n\n<img style =\"max-width: 90%;display: block;margin: 20px auto;border: 1px solid #E2E2E2;padding: 5px;\" src=\"/images/project/cpp1.jpg\" alt=\"error1\">\n\n\n错误类型为_BLOCK_TYPE_IS_VAILD(pHead->nBlockUse)，可能正是因为一块内存在被释放的时候，它的头部里面的信息已经被改掉了，和预期的不一样。内存分配的程序往往在被分配出的内存块头部放上一些校验信息。这个信息内存的用户是不知道也不应该修改的。这样，在内存被释放的时候，内存分配程序就可以验对这个头部信息是否被改过了。若被改过，就说明发生了内存corruption. 这种corruption有两种可能性：要么是有人在内存越界写东西；要么就是这块内存已经被释放了，又被重复释放了一次。这与之前的推论非常吻合。\n\n　　根据先创建的类对象后析构的原则，第二次调用析构函数显然是析构bMsg对象，正式因为它的内存已经被释放掉了，此处报告错误。到此为止，一切水落石出。\n\n　　总结起来就是：\n\n　　1、单独使用“=”为类对象赋值，就不会调用复制构造函数，而是调用赋值运算符来操作。\n\n　　2、当一个实例转换为一个类类型实例时，会调用该类的构造函数。\n\n　　3、函数按值传递时，会复制实参的副本。如果副本是一个类对象，在函数结束后，又会调用析构函数删除副本。\n\n　　避免这种错误应该怎么做呢？前面说到，可以在构造函数钱添加“explicit”关键字，这样可以阻止运行```CMassage aMsg = p;```这样的语句，而只能使用函数表示法来初始化一个类对象（因为这时调用的不是赋值操作，而是类构造函数），如```CMassage aMsg(p);```。而使用```bMsg = p;```也同样非法，错误信息是“没有与这些操作数相匹配的运算符‘=’”。使用explicit会阻止隐式的转换，所有涉及隐式转换的语句都需要显示的指定，否则编译器报告为错误。\n\n　　但这样做只能阻止```CMassage aMsg = p;```这样的语句，当程序中出现的时候报告为错误。有时候确实需要使用“=”来进行赋值，应该怎么做呢？此时，可以编写重载赋值运算符的成员函数，在类中添加：\n\n\t\tCMassage& operator=(const CMassage& xMsg)\n\t\t\t{\n\t\t\t\tif (this != &xMsg)\n\t\t\t\t{\n\t\t\t\t\tdelete[] pMassage;\n\t\t\t\t\tpMassage = new char[strlen(xMsg.pMassage) + 1];\n\t\t\t\t\tstrcpy_s(pMassage, strlen(xMsg.pMassage) + 1, xMsg.pMassage);\n\t\t\t\t}\n\t\t\t\treturn *this;\n\t\t\t}\n\n　　这样就定义了重载赋值运算符的函数，其中operator是关键字。这样一来，可以执行下面的语句：\n\n\t\tCMassage bMsg;\n\t\tbMsg = p;\n\n　　如果还指定explicit的调用构造函数，则需要把```bMsg = p;```替换成```bMsg = static_cast<CMassage>(p);```，这样显式的将p转化为CMassage的类对象。否则，编译器告知没有与之匹配的操作符“=”。\n\n\n##其他运算符的重载\n　　。\n",
"layout": "post",
"title": "学习C++之九：对象复制问题",
"category": "学习笔记",
"description": "组织数据的一种方式",
"preview": "构造函数是在创建一个类对象的时候，由系统自动调用的，复制构造函数也可以理解为构造函数一种，因为他们不仅有共同的函数名，而且他们的目的也十分相似。而复制构造函数是在复制一个对象时调用的。如果不去手动编写复制构造函数，系统会自动提供一个，但只是简单的复制类的各个成员。下面是一个实例：\n\n\t\tclass CMassage\n\t\t{\n\t\tprivate:\n\t\t\tchar* pMassage;\n\t\tpublic:\n\t\t\tCMassage(const char* text = \"some massage.\"){\n\t\t\t\tpMassage = new char[strlen(text) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(text) + 1, text);\n\t\t\t}\n\n\t\t\tCMassage(const CMassage & aMsg){\n\t\t\t\tpMassage = new char [strlen(aMsg.pMassage) + 1];\n\t\t\t\tstrcpy_s(pMassage,strlen(aMsg.pMassage) + 1,aMsg.pMassage);\n\t\t\t}\n\n\t\t\t~CMassage(){\n\t\t\t\tdelete [] pMassage;\n\t\t\t}\n\n\t\t\tvoid Show() const {\n\t\t\t\tcout << pMassage << endl;\n\t\t\t}\n\t\t};\n\n\n　　其中第一个函数是带有默认形参值的构造函数，初始化具体类对象时，如果不带形参就会把对象初始化为“some massage.”。第二个是复制构造函数，需要注意的是实参类型为const的类对象的引用。使用const是因为复制构造函数不需要修改类对象的值，如果不这么做，则在复制const型的类对象时，编译无法通过；使用引用的目的是，防止在给函数传递实参时，为了复制实参而对复制构造函数无休止的调用。\n\n　　上述最后一个函数是该类的析构函数。在类对象到达作用域的结束位置时，系统调用析构函数释放为成员分配的内存空间。通常析构函数也做一些收尾工作，在程序结束后由系统调用。如果析构函数发生异常错误，有可能导致程序崩溃，所以我们也曾遇到过这种情况，在关闭某个软件后，还会弹出一个错误提示。\n\n　　大多数人都知道，当类中含有指针或者数组类型的数据成员时，如果使用系统提供的默认复制构造函数就会发生潜在的危险。因为默认的构造函数会把两个对象的数据成员，也就是两个指针赋成同一个值，当其中一个类对象被析构后，如果还要使用另一个对象，就会发生一些异常状况，因为它的指针指向的空间已经被释放，可能是别的程序正在使用的一块空间。那么，如果在程序中不去复制两个同类的对象时，是否不再需要编写复制构造函数呢？看下面的实例：\n\n\t\tvoid DisplayMsg(CMassage X){\n\t\t\tX.Showit();\n\t\t};\n\n\t\tCMassage aMsg(\"hello world !\");\n\t\tDisplayMsg(aMsg);\n\n　　当没有编写复制构造函数时，上述函数在调用CMassage的具体对象X作为实参时，编译器会复制一个X的副本，因为实参的传递是按值传递进行的。当```DisplayMsg()```函数执行完毕后，系统会调用CMassage的析构函数，来释放副本的指针。需要注意的是，X的副本和X本身的成员指针都指向同一区域，因此只是调用了显示的函数```DisplayMsg()```，就同时把X的空间给删除掉了。\n\n　　所以，当动态的给类中的成员分配内存时，必须编写复制构造函数。\n\n##重载赋值运算符“=”\n　　记得在之前的类构造函数中有提到，如果构造函数只有一个参数，而且没有指定为explicit方式来构造类对象，则可以使用“=”来初始化类的成员，但需要注意的是，在此过程中有可能涉及隐式的类型转换。可以运行下面的程序：\n\n\t\t#include<iostream>\n\t\t#include<cstring>\n\n\t\tusing namespace std;\n\n\t\tclass CMassage\n\t\t{\n\t\tprivate:\n\t\t\tchar* pMassage;\n\t\tpublic:\n\t\t\tCMassage(const char * text = \"some massage.\"){\n\t\t\t\tcout << \"Construstor ... \";\n\t\t\t\tpMassage = new char[strlen(text) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(text) + 1, text);\n\t\t\t\tcout << \"called !\" << endl;\n\t\t\t}\n\n\t\t\tCMassage(const CMassage & aMsg){\t\t\n\t\t\t\tif (pMassage != nullptr)  delete[] pMassage;\n\t\t\t\tpMassage = new char[strlen(aMsg.pMassage) + 1];\n\t\t\t\tstrcpy_s(pMassage, strlen(aMsg.pMassage) + 1, aMsg.pMassage);\n\t\t\t\tcout << \"Copy construstor called !\" << endl;\n\t\t\t}\n\n\t\t\t~CMassage(){\t\t\n\t\t\t\tcout << \"Disconstrustor ... \";\n\t\t\t\tdelete[] pMassage;\n\t\t\t\tpMassage = nullptr;\n\t\t\t\tcout << \"called !\" << endl;\n\t\t\t}\n\n\t\t\tvoid Showit() const {\n\t\t\t\tcout << pMassage << endl;\n\t\t\t}\n\t\t};\n\t\tvoid main()\n\t\t{\n\t\t\t{\n\t\t\t\tconst char* const  p = \"how are you?\";\n\t\t\t\tCMassage aMsg = p;\n\t\t\t\tCMassage bMsg;\n\t\t\t\tbMsg = p;\n\t\t\t\taMsg.Showit();\n\t\t\t\tbMsg.Showit();\n\t\t\t}\n\t\t\t\twhile (true);\n\t\t}\n\n　　先来分析一下上面的程序：先定义了指向常量字符串数组的常量指针p，然后用p来初始化aMsg，接着初始化bMsg，然后使bMsg等于p，最后显示输出。程序的构造函数中，一开始就输出“Construstor ...”，结束时输出“called!”，这有利于直观的观察构造函数执行的情况——如果函数执行到一半，就不会输出“called!”。析构函数也以同样的方式编写。如果按照我们的所想象的，程序应该输出：\n\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\thow are you?\n\t\thow are you?\n\t\tDisconstrustor ... called !\n\t\tDisconstrustor ... called !\n\n但事实上，程序的输出是这样的：\n\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\tConstrustor ... called !\n\t\tDisconstrustor ... called !\n\t\thow are you?\n\t\t[乱码]\n\t\tDisconstrustor ...\n\n其中“[乱码]”表示程序在此处输出的是一串乱码。伴随而来的是，弹出一个debug的错误。而程序编译并没有任何错误和警告，在运行时却发生错误，为什么呢？\n\n　　仔细分析程序的输出，发现有两点可疑的地方：一是，在整个过程中竟然调用了三次构造函数，在第三次构造函数调用完成后，紧接着又调用了一次析构函数；二是，程序在第二次调用析构函数的时候，崩溃了，此时析构函数尚未执行完毕。\n\n　　首先说第一个可疑的地方。我们在main()函数中只声明了两个类对象实例，而第三次调用构造函数是什么作用呢？可能是用来给bMsg的pMassage来实现赋值。通过调试发现第三次的构造函数发生在语句```bMsg = p;```，因此这么推测貌似有一定道理。但是，为什么接着又调用一次析构函数呢？如果仅仅是给bMsg来赋值的话，是没有必要调用析构函数的——析构函数仅仅在一个类实例完成作用域后使用的，而此处的aMsg和bMsg显然没有到达作用域的结尾。没有新的对象产生，就不会调用析构函数。所以，此处的解释就是：在执行```bMsg = p;```的时候，一定产生了一个新的类对象，而且在这一句运行结束之后，新的对象的作用域也就结束了。\n\n　　此时不难想到，在函数调用的时候，是“按值传递”的，它会创建一个实参的副本。所以，此处一定是创建了类对象的副本，恰好在```bMsg = p;```执行完毕后，副本的作用域也结束，正好符合上述的情况。但此处创建的副本，是谁的副本呢？显然，是指针p的副本，只不过在创建p的副本之后，系统又进行了一次隐式的类型转换，将“cont char *”转化为“CMassage”类型，第三次调用构造函数也就发生在此时。为了验证类型的转换也会调用类构造函数，可以运行下面的程序：\n\n\t\tvoid main()\n\t\t{\n\t\t\t{\n\t\t\t\tconst char* const  p = \"how are you?\";\n\t\t\t\tstatic_cast<CMassage>(p);\n\t\t\t}\n\t\t\t\twhile (true);\n\t\t}\n\n可以看到，程序输出：\n\n\t\tConstrustor ... called !\n\t\tDisconstrustor ... called !\n\n　　接着分析。这时```bMsg = p;```并未执行完毕。它不去调用复制构造函数，而是调用赋值运算符“=”，来使得副本p的类实例的pMassage的值与bMsg的pMassage的值相等。此时，这两个指针指向同一块区域，内容是“how are you?”。然后副本p的类实例完成使命，调用析构函数将其删除。而此时，悲剧发生，因为bMsg.pMassage指向的空间也被释放了。\n\n　　到了此时，第二个问题也迎刃而解，报告的错误是：\n\n\n错误类型为_BLOCK_TYPE_IS_VAILD(pHead->nBlockUse)，可能正是因为一块内存在被释放的时候，它的头部里面的信息已经被改掉了，和预期的不一样。内存分配的程序往往在被分配出的内存块头部放上一些校验信息。这个信息内存的用户是不知道也不应该修改的。这样，在内存被释放的时候，内存分配程序就可以验对这个头部信息是否被改过了。若被改过，就说明发生了内存corruption. 这种corruption有两种可能性：要么是有人在内存越界写东西；要么就是这块内存已经被释放了，又被重复释放了一次。这与之前的推论非常吻合。\n\n　　根据先创建的类对象后析构的原则，第二次调用析构函数显然是析构bMsg对象，正式因为它的内存已经被释放掉了，此处报告错误。到此为止，一切水落石出。\n\n　　总结起来就是：\n\n　　1、单独使用“=”为类对象赋值，就不会调用复制构造函数，而是调用赋值运算符来操作。\n\n　　2、当一个实例转换为一个类类型实例时，会调用该类的构造函数。\n\n　　3、函数按值传递时，会复制实参的副本。如果副本是一个类对象，在函数结束后，又会调用析构函数删除副本。\n\n　　避免这种错误应该怎么做呢？前面说到，可以在构造函数钱添加“explicit”关键字，这样可以阻止运行```CMassage aMsg = p;```这样的语句，而只能使用函数表示法来初始化一个类对象（因为这时调用的不是赋值操作，而是类构造函数），如```CMassage aMsg(p);```。而使用```bMsg = p;```也同样非法，错误信息是“没有与这些操作数相匹配的运算符‘=’”。使用explicit会阻止隐式的转换，所有涉及隐式转换的语句都需要显示的指定，否则编译器报告为错误。\n\n　　但这样做只能阻止```CMassage aMsg = p;```这样的语句，当程序中出现的时候报告为错误。有时候确实需要使用“=”来进行赋值，应该怎么做呢？此时，可以编写重载赋值运算符的成员函数，在类中添加：\n\n\t\tCMassage& operator=(const CMassage& xMsg)\n\t\t\t{\n\t\t\t\tif (this != &xMsg)\n\t\t\t\t{\n\t\t\t\t\tdelete[] pMassage;\n\t\t\t\t\tpMassage = new char[strlen(xMsg.pMassage) + 1];\n\t\t\t\t\tstrcpy_s(pMassage, strlen(xMsg.pMassage) + 1, xMsg.pMassage);\n\t\t\t\t}\n\t\t\t\treturn *this;\n\t\t\t}\n\n　　这样就定义了重载赋值运算符的函数，其中operator是关键字。这样一来，可以执行下面的语句：\n\n\t\tCMassage bMsg;\n\t\tbMsg = p;\n\n　　如果还指定explicit的调用构造函数，则需要把```bMsg = p;```替换成```bMsg = static_cast<CMassage>(p);```，这样显式的将p转化为CMassage的类对象。否则，编译器告知没有与之匹配的操作符“=”。\n\n\n##其他运算符的重载\n　　。\n",
"first_figure": "/static/blog/img/preview_0.jpg"
},
"20150910": {
"create_time": "2015年9月10日",
"id": 20150910,
"content": "\n![C](/static/blog/img/project/20150910/2015091001.jpg)\n\n　　尽管C语言作为绝大多数开发者学习的第一门编程语言，但它非常难以掌握是一个不争的事实。抛开高深精妙的指针、结构体等用法不谈，单是最基础的数据的操作，也暗藏诸多陷阱。下面简单总结一些易犯的错误和解决办法。\n<!--more-->\n## 1、数据类型与赋值\n\n　　（1）未赋予初值的变量，它的值是多少？答案是取决于变量定义的位置。在程序代码调入内存时，如果变量被调入堆中，那么初始值为0。而如果在栈中，它的值为随机值。总结就是：**全局变量未赋初值，它的值为0，静态static变量也是如此。而未赋初值的局部变量，它的值是随机的。**\n在Visual Stidio 2015的编译环境下，如果在变量使用之前未赋予初值，将会报告一个错误，明确指出该错误。\n\n　　（2）给一个结构体的部分元素赋值，那么另一部分的元素的值是多少？仍然与（1）所述的情况相同，**取决于结构体实例化的位置。**\n\n　　（3）**给变量赋值，会将该变量转换为补码存入内存。用作变量输出时，会根据是否带有符号输出原码。**补码定义如下：\n\n* 无符号数： 补码为其自身\n* 有符号数： 该数的符号位保持不变，其余部分取反再+1\n\n所以：\n```\nunsigned char a = -1;\n\t// -1的原码：0b1000 0001，补码为0b1111 1110 + 1 = 0xFF。 此时a存储的是0xFF\n\t// 在无符号数中，0xFF的值为255  故，a = 255\n\nchar b = 0xFF;\n\t// 0xFF即 255，正数的补码为其自身，即0xFF\n\t// 因为b带有符号，0b 1111 1111 - 1 =  0b1111 1110，\n\t// 符号位不变其余位求反为0b 1000 0001，即原码为-1\n\nunsigned char c = -257;\n\t// -257为0x 8101， 即0b1000 0001  0000 0001\n\t// 补码为0b 1111 1110  1111 1110 + 1, 取后8位即为0xFF 即c存储的是255\n\t// 无符号char类型，原码为其自身即为255\n\nchar d = -257\n\t// 同上，因为d存储的是0xFF，而0xFF的原码为-1，所以d = -1\n```\n　　（4）符号位扩展：**将一个无符号char型变量转换成int型变量，直接在高位填充0。若为有符号char，则int变量的第8位至第32位均为符号位。**\n\n　　（5）**局部变量和全局变量是可以重名的，而且一般来说在某个函数体内，局部变量是会覆盖全局变量。**\n\n## 2、字符串操作\n\n　　（1）**strlen()函数返回值，不包含'\\0'。**\n\n　　（2）**sizeof()函数的返回值，如果传入sizeof函数的参数为数组名，则返回数组的定义时的长度；如果为指针，则范围指针占用的字节数。**另外，**给函数传递参数的时候，数组名将退化为指针，即使将函数声明为```fun(char a[])```,在fun()函数内部a也将退化为指针，函数内sizeof(a)的值仍然是4或者8。**\n",
"layout": "post",
"title": "C的陷阱",
"category": "学习笔记",
"description": "从另一个角度探讨C语言",
"preview": "\n![C](/static/blog/img/project/20150910/2015091001.jpg)\n\n　　尽管C语言作为绝大多数开发者学习的第一门编程语言，但它非常难以掌握是一个不争的事实。抛开高深精妙的指针、结构体等用法不谈，单是最基础的数据的操作，也暗藏诸多陷阱。下面简单总结一些易犯的错误和解决办法。\n",
"first_figure": "/static/blog/img/preview_2.jpg"
},
"20170626": {
"create_time": "2017年6月26日",
"id": 20170626,
"content": "<img src=\"/static/blog/img/blog/20161231/0.jpeg\" style=\"width: 100%\">\n\n　　Python装饰器应用广泛，在之前的日记里记录了一个高水平的装饰器，用来把类的只接受一个self的成员函数转换为该实例的一个属性并缓存。遗憾的是，这种装饰器如果用于缓存，则推广的场景不多。现在有一种简单办法，能够借助装饰器将普通函数输出也缓存起来。\n<!--more-->\n\n## pickle模块与持久化存储\n　　如果要缓存一个函数的输出，那么首先要获取函数的输入。对于输入一定则输出也一定的函数，我们才需要对其结果进行缓存，否则就没有意义甚至有害了，比如返回一个随机数的函数。知道这一点那么接下来就要想办法对输入的参数作唯一的标识。\n\n　　Python内置的pickle模块，可以将任意复杂的对象转化为字符串或者二进制文本，这一过程叫做对象的序列化。序列化之后的数据可以本地存储或转发到其他程序，再还原成原对象，这一持久化存储的特性即pickle的原本设计目标。需要注意的是，序列化之后的数据，不同于编译后的字节码或者可执行二进制代码，而是一种与代码执行流无关的Python对象的身份标识。对于这句话的理解，最后再去分析，暂时先认为：一个确定的对象，经过pickle转化之后，所得的数据可以唯一的标识该对象。\n```\nclass TestClass(object):\n    pass\n\nimport pickle\na = TestClass()\ndata = pickle.dumps(a)  # 序列化对象a\n```\n\n## 缓存一般函数返回值的装饰器\n\n　　有了上述的分析，很容易写出这样的装饰器：使用一个全局的dict作缓存池，当函数被调用时，序列化函数的输入参数，检查缓存池中有无该参数对应的值，有则返回，无则执行函数并记录下返回值，将其存储到字典中。\n\n\n```\nimport pickle\nimport hashlib\n\ndef serialize(function, args, kwargs):\n    key = pickle.dumps((function, args, kwargs))\n    sha = hashlib.sha1(key)\n    return sha.hexdigest()\n\n__cached_result = {}\ndef cache(f):\n    def _decoretor(*args, **kwargs):\n        key = serialize(f.func_name, args, kwargs)\n        if key in __cached_result:\n            return __cached_result[key]\n        __cached_result[key] = value = f(*args, **kwargs)\n        return value\n    return _decoretor\n\n@cache\ndef test_function(data):\n    print \"test_function called!\"\n    return data + 1\n\na = test_function(100)\nb = test_function(100)\nprint \"a: %s, b: %s\" % (a, b)\n\n[out]: test_function called!\na: 101, b: 101\n```\n可以看到，被缓存的函数只被调用了一次。这种方法十分简洁，但在生产环境中应该慎重使用这种方式来缓存结果，如果确实有需要以缓存程序输出来提升性能，应当使用具有高级缓存算法和机制的专门化缓存库。至于原因，你肯定发现了它没有使缓存失效的触发机制，这一点可以给缓存池增加一个时间戳字段来标记每一个key的产生时间，在返回缓存结果之前对其做检查，以确保过期的key失效。但即使这样，这种方法依然不安全，一个致命的原因就在于函数参数的序列化上。\n\n## pickle模块需要注意的事项\n\n　　之前所述，序列化之后的数据，不同于编译后的字节码或者可执行二进制代码，而是一种与代码执行流无关的Python对象的身份标识。例如：\n```\nclass TestClass(object):\n    def get(self):\n        return \"Hello\"\n\na = TestClass()\nb = TestClass()\ndata_a = pickle.dumps(a)\ndata_b = pickle.dumps(b)\n\nprint \"a == b ?\", a == b\nprint \"data_a == data_b ?\", data_a == data_b\nprint data_a\n\n[out]: a == b ? False\ndata_a == data_b ? True\nccopy_reg\n_reconstructor\np0\n(c__main__\nTestClass\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\n.\n```\ndata_a 和 data_b是TestClass初始化的两个对象实例，但序列化之后，他们完全相同。你可能认为，从固有的属性上来讲，这是合理的，因为初始化这两个对象实例不需要参数，而且任何时候他们的get方法都返回相同的值。但是，如果它们的get方法返回不同的值呢？\n```\nclass TestClass(object):\n    def get(self):\n        import datetime\n        return datetime.datetime.now()\n\na = TestClass()\nb = TestClass()\ndata_a = pickle.dumps(a)\ndata_b = pickle.dumps(b)\nprint \"a == b ?\", a == b\nprint \"data_a == data_b ?\", data_a == data_b\n\n[out]: a == b ? False\ndata_a == data_b ? True\n```\n这里改动了TestClass，get的方法返回当前时间，而序列化的结果仍然是相同的。如果缓存接收这种参数的函数，那么后果是非常可怕的。还有一种隐患则是，在函数参数序列化的时候只是冻结参数传递的对象状态，这种方式可能会将缓存值绑定到函数本身上，以管理其范围和生命周期来替代集中化的字典，这不是预期的结果。\n\n总结：使用Python的装饰器可以很pythonic的实现某些功能，这里实现了一种针对通用函数的缓存机制，但在生产环境中应当慎重使用。\n",
"layout": "post",
"title": "Pythonic - 装饰器正解(二) - 持久化存储与运行时缓存",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "Python装饰器应用广泛，在之前的日记里记录了一个高水平的装饰器，用来把类的只接受一个self的成员函数转换为该实例的一个属性并缓存。遗憾的是，这种装饰器如果用于缓存，则推广的场景不多。现在有一种简单办法，能够借助装饰器将普通函数输出也缓存起来。\n",
"first_figure": "/static/blog/img/blog/20161231/0.jpeg"
},
"20141103": {
"create_time": "2014年11月3日",
"id": 20141103,
"content": "## 学习Jekyll\n　　最近开始学习jekyll和bootstrap，这就必须要学习一堆英文技术文档，虽然英文不是晦涩难懂，但看的多了便眼花缭乱，看了下句忘了上句。还是彻底翻译成中文再彻头彻尾看吧。  \t\n\n## 文档\n　　以下将完整但简洁的介绍是Jekyll如何工作的。注意核心内容是介绍没有代码的快速替换. 这些信息并不打算明确教你做任何事,而是告诉你Jekyll世界的全貌.\n\n　　学习这些核心内容（core concepts）将帮你避免一些常见挫折，并且帮你更好的理解包含在Jekyll-Bootstrap里面的代码示例.\n\n## 初始设置\n　　安装jekyll之后，你需要依照jekyll期望的方式来格式化你的网页目录，Jekyll-bootstrap合理地提供基本的目录格式。 \n\n　　The Jekyll 应用程序的基本格式\nJekyll 希望你的网页目录按照下面这样建立:\n\n\t\t.\n\t\t|-- _config.yml\n\t\t|-- _includes\n\t\t|-- _layouts\n\t\t|   |-- default.html\n\t\t|   |-- post.html\n\t\t|-- _posts\n\t\t|   |-- 2011-10-25-open-source-is-good.markdown\n\t\t|   |-- 2011-04-26-hello-world.markdown\n\t\t|-- _site\n\t\t|-- index.html\n\t\t|-- assets\n\t\t    |-- css\n\t\t        |-- style.css\n\t\t    |-- javascripts\n\n\n　　_config.yml 存储配置设置.\n\n　　_includes 这个文件夹是局部视图.\n\n　　_layouts 这个文件夹存放你的内容将要插入的主模板.你可以建立更多不同的layouts来存放不同的页面.\n\n　　_posts 这个文档包含你的动态内容和公告. 需要按照这样的格式命名 @YEAR-MONTH-DATE-title.MARKUP@.\n\n　　_site 一旦Jekyll完成转换，将会把生成的网页放置在这个目录.\n\n　　assets 这个文件夹不是标准的jekyll结构.你创建根文件夹后，assets文档代表任何通用文件夹. 目录和文件不正确格式化将导致Jekyll不能正常为您服务.\n\n　　(了解更多: https://github.com/mojombo/jekyll/wiki/Usage)\n\n　　Jekyll 配置\n\n　　Jekyll 这里列出完全支持各种配置选项: (https://github.com/mojombo/jekyll/wiki/Configuration)\n\n## Jekyll 的内容\n　　Jekyll内的内容是一个 post 或者一个 page. 这些内容 “objects” 将插入到若干个模板来来建立一个静态页面.\n\n## Posts and Pages\n\n　　posts 和 pages 可以使用 markdown, textile, or HTML 等标记语言. 它们都可以使用元数据分配title, url path, 甚至任意自定义元数据.\n\n## Posts是如何工作的\n\n　　建立Posts需要正确的格式化文件并将它放置_post文件夹.\n\n　　格式化一个Post必须有一个有效的文件名，如：YEAR-MONTH-DATE-title.MARKUP .并且要放置到_posts文件夹中. 如果格式不正确，Jekyll将无法识别这是一篇Post. 借助正确的文件名，日期和标题会自动解析. 此外，每个文件必须含有YAML Front-Matter来返回它的前页. YAML Front-Matter 是一个有效的YAML语法，来指定给定文件的meta-data.\n\n## Order\n　　排序是Jekyll的重要组成部分，但很难指定一个自定义的排序策略. Jekyll只支持按时间倒序排序.\n\n　　由于日期是硬编码到文件名格式, 所以改变时序,你必须改变文件名中的日期.\n\n## Tags Posts\n　　可以有标签作为它们的meta-data关联它们 . 通过提供posts的YAML前页，标签可以放置到posts里面 . 你可以访问发布具体标签的模板. 这些标签也会添加到 sitewide collection.\n\n## Categories Posts\n　　在YAML的前页可以被归类为一个或多个类别. 类别提供更多的意义在标记,它们可以反映在给定的URL路径. Note categories in Jekyll work in a specific way. 如果你定义一个以上的类别，你需要定义一个类别层次结构“set”.\n\n　　示例：\n\n\t\t---\n\t\ttitle :  Hello World\n\t\tcategories : [lessons, beginner]\n\t\t---\n\t\t\n　　This defines the category hierarchy “lessons/beginner”. Note this is one category node in Jekyll. You won’t find “lessons” and “beginner” as two separate categories unless you define them elsewhere as singular categories.\n\n\n\n\n\t\t\n",
"layout": "post",
"title": "How Jekyll Works",
"category": "学习笔记",
"description": "Jekyll-bootstrap入门文档的翻译",
"preview": "最近开始学习jekyll和bootstrap，这就必须要学习一堆英文技术文档，虽然英文不是晦涩难懂，但看的多了便眼花缭乱，看了下句忘了上句。还是彻底翻译成中文再彻头彻尾看吧。  \t\n\n## 文档\n　　以下将完整但简洁的介绍是Jekyll如何工作的。注意核心内容是介绍没有代码的快速替换. 这些信息并不打算明确教你做任何事,而是告诉你Jekyll世界的全貌.\n\n　　学习这些核心内容（core concepts）将帮你避免一些常见挫折，并且帮你更好的理解包含在Jekyll-Bootstrap里面的代码示例.\n\n## 初始设置\n　　安装jekyll之后，你需要依照jekyll期望的方式来格式化你的网页目录，Jekyll-bootstrap合理地提供基本的目录格式。 \n\n　　The Jekyll 应用程序的基本格式\nJekyll 希望你的网页目录按照下面这样建立:\n\n\t\t.\n\t\t|-- _config.yml\n\t\t|-- _includes\n\t\t|-- _layouts\n\t\t|   |-- default.html\n\t\t|   |-- post.html\n\t\t|-- _posts\n\t\t|   |-- 2011-10-25-open-source-is-good.markdown\n\t\t|   |-- 2011-04-26-hello-world.markdown\n\t\t|-- _site\n\t\t|-- index.html\n\t\t|-- assets\n\t\t    |-- css\n\t\t        |-- style.css\n\t\t    |-- javascripts\n\n\n　　_config.yml 存储配置设置.\n\n　　_includes 这个文件夹是局部视图.\n\n　　_layouts 这个文件夹存放你的内容将要插入的主模板.你可以建立更多不同的layouts来存放不同的页面.\n\n　　_posts 这个文档包含你的动态内容和公告. 需要按照这样的格式命名 @YEAR-MONTH-DATE-title.MARKUP@.\n\n　　_site 一旦Jekyll完成转换，将会把生成的网页放置在这个目录.\n\n　　assets 这个文件夹不是标准的jekyll结构.你创建根文件夹后，assets文档代表任何通用文件夹. 目录和文件不正确格式化将导致Jekyll不能正常为您服务.\n\n　　(了解更多: https://github.com/mojombo/jekyll/wiki/Usage)\n\n　　Jekyll 配置\n\n　　Jekyll 这里列出完全支持各种配置选项: (https://github.com/mojombo/jekyll/wiki/Configuration)\n\n## Jekyll 的内容\n　　Jekyll内的内容是一个 post 或者一个 page. 这些内容 “objects” 将插入到若干个模板来来建立一个静态页面.\n\n## Posts and Pages\n\n　　posts 和 pages 可以使用 markdown, textile, or HTML 等标记语言. 它们都可以使用元数据分配title, url path, 甚至任意自定义元数据.\n\n## Posts是如何工作的\n\n　　建立Posts需要正确的格式化文件并将它放置_post文件夹.\n\n　　格式化一个Post必须有一个有效的文件名，如：YEAR-MONTH-DATE-title.MARKUP .并且要放置到_posts文件夹中. 如果格式不正确，Jekyll将无法识别这是一篇Post. 借助正确的文件名，日期和标题会自动解析. 此外，每个文件必须含有YAML Front-Matter来返回它的前页. YAML Front-Matter 是一个有效的YAML语法，来指定给定文件的meta-data.\n\n## Order\n　　排序是Jekyll的重要组成部分，但很难指定一个自定义的排序策略. Jekyll只支持按时间倒序排序.\n\n　　由于日期是硬编码到文件名格式, 所以改变时序,你必须改变文件名中的日期.\n\n## Tags Posts\n　　可以有标签作为它们的meta-data关联它们 . 通过提供posts的YAML前页，标签可以放置到posts里面 . 你可以访问发布具体标签的模板. 这些标签也会添加到 sitewide collection.\n\n## Categories Posts\n　　在YAML的前页可以被归类为一个或多个类别. 类别提供更多的意义在标记,它们可以反映在给定的URL路径. Note categories in Jekyll work in a specific way. 如果你定义一个以上的类别，你需要定义一个类别层次结构“set”.\n\n　　示例：\n\n\t\t---\n\t\ttitle :  Hello World\n\t\tcategories : [lessons, beginner]\n\t\t---\n\t\t\n　　This defines the category hierarchy “lessons/beginner”. Note this is one category node in Jekyll. You won’t find “lessons” and “beginner” as two separate categories unless you define them elsewhere as singular categories.\n\n\n\n\n\t\t\n",
"first_figure": "/static/blog/img/preview_5.jpg"
},
"20170305": {
"create_time": "2017年3月5日",
"id": 20170305,
"content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n### WSGI Utilities and Reference Implementation\n　　WSGI是一个介于web服务器与Python应用程序之间的标准接口，采用标准接口可以使应用程序方便的在各个web服务器间复用和移植。\n\n　　只有web服务器工程师和软件框架的作者才需要了解和关心WSGI设计的每个细节，对于应用层来讲，只需要遵循WSGI协议来安装和使用现有的框架去编写网络程序就够了。wsgiref提供WSGI环境变量以及HTTP header的回复等的各种操作方法，以及性能评测工具。\n\n## wsgiref.util – WSGI environment utilities\n　　此模块包含操作WSGI环境变量的众多方法。WSGI环境变量是一个包含HTTP请求参数的dict，处理函数要使用一个*environ* 的参数来接收它。\n\n* __wsgiref.util.guess_scheme(*environ*)__\n\n\t返回```wsgi.url_scheme```为“http”还是“https”，它是通过检查*environ* dict中的“HTTP”环境变量来实现的。返回值为string类型。\n\n\t此方法在创建一个CGI或CGI类（比如FastCGI）协议的装饰器时非常有用。比如服务器在收到基于SSL的请求时，在协议中会包含一个“HTTPS”的变量，其值为“1”、“yes”或“on”等，那么使用此方法将会返回一个“https”，否则就是“http”。\n\n\n* __wsgiref.util.request_uri(*environ, include_query=1*)__\n\n\t返回完整的请求的URI，通过*include_query* 参数来决定是否包含query string。判定算法使用的是PEP 333中的”URL Reconstruction“。\n\n\n* __wsgiref.util.application_uri(*environ*)__\n\n\t与request_uri方法类似，但这里忽略了PATH_INFO和QUERY_STRING变量。结果就是请求的应用程序对象地址的base URI。\n\n\n* __wsgiref.util.shift_path_info(*environ*)__\n\n\t从PATH_INFO中移出一个单词到SCRIPT_NAME，并且将之返回。*environ* 将会以空格填补，如果需要的话必须先保存原始的PATH_INFO和SCRIPT_NAME变量。\n\n\t如果PATH_INFO再没有可以移出的部分，执行此方法就会返回一个None。\n\n\t典型情况，一个需求要处理请求URI路径的每个部分，比如遍历一系列的dict的键来修改传入的环境使其适合调用另一个位于目标URI的WSGI程序。比如，有一个WSGI程序位于/foo，而请求的URI路径是/foo/bar/baz，那么位于/foo的应用程序调用 ```shift_path_info()```，将会返回\"bar\"。然后环境将更新来适配位于/foo/bar的WSGI应用程序。这样一来，SCRIPT_NAME将会从/foo变成/foo/bar，PATH_INFO将从/bar/baz变成/baz。\n\n\t当PATH_INFO只剩“/”，就返回一个空的string并且给SCRIPT_NAME追加一个反斜杠，即便是空的路径被忽略或者SCRIPT_NAME没有正常的终止于反斜杠。这是故意设置的，来确保在对象遍历时应用程序能够区分以“/x/”和“/x”结尾的URI。\n\n\n* __wsgiref.util.setup_testing_defaults(*environ*)__\n\n 通过默认值来更新*environ*变量，用于测试用途。\n\n 这个路由添加多个用于请求WSGI的参数，包括HTTP_HOST、SERVER_NAME、SERVER_PORT、REQUEST_METHOD、SCRIPT_NAME、PATH_INFO和所有在PEP 333中定义的以“wsgi.”开头的变量。只支持默认的值，并且不会替换他们当中任何已经存在的设定值。\n\n 此方法主要用来方便的模拟一个环境用于单元测试。由于数据是模拟的，所以不应用于生产服务器和应用程序中。\n\n 一个示例：\n        from wsgiref.util import setup_testing_defaults\n        from wsgiref.simple_server import make_server\n\n        # A relatively simple WSGI application. It's going to print out the\n        # environment dictionary after being updated by setup_testing_defaults\n\n        def simple_app(environ, start_response):\n            setup_testing_defaults(environ)\n\n            status = '200 OK'\n            headers = [('Content-type', 'text/plain')]\n\n            start_response(status, headers)\n\n            ret = [\"%s: %s\\n\" % (key, value) for key, value in environ.iteritems()]\n            return ret\n        httpd = make_server('', 8000, simple_app)\n        print \"Serving on port 8000...\"\n        httpd.serve_forever()\n\n\t除了上述功能，wsgiref.util还提供了一些杂项工具：\n\n* __wsgiref.util.is_hop_by_hop(*header_name*)__\n\n\t如果“‘header_name”是RFC 2616中定义的HTTP/1.1 “Hop-by-Hop” header，则返回True。\n\n\n* ___class___ wsgiref.util.__FileWrapper(*filelike, blksize=8192*)__\n\n\t一个装饰器，用来把file-like对象转换成一个迭代器，返回的对象支持```__getitem__()```和```__iter__()```两种循环风格。当对象迭代时，可选的*blksize*参数将被传入file-like对象的```read()```方法中用来获取产生的字符串。```当read()```方法返回一个空字符串时，迭代结束，且此对象不可恢复。\n\n\t如果file-like对象有一个```close()```方法，那么转换后的对象依然有一个```close()```方法，并且在调用这个对象的```close()```方法时触发file-like对象的```close()```方法。\n\n\t示例：\n\n\t\tfrom StringIO import StringIO\n\t\tfrom wsgiref.util import FileWrapper\n\n\t\t# We're using a StringIO-buffer for as the file-like object\n\n\t\tfilelike = StringIO(\"This is an example file-like object\"*10)\n\t\twrapper = FileWrapper(filelike, blksize=5)\n\n\t\tfor chunk in wrapper:\n\t\t    print chunk\n\n",
"layout": "post",
"title": "Web Server Gateway Interface (wsgiref.util部分)",
"category": "学习笔记",
"tags": [
"编程",
"Python",
"WSGI"
],
"preview": "WSGI是一个介于web服务器与Python应用程序之间的标准接口，采用标准接口可以使应用程序方便的在各个web服务器间复用和移植。\n\n　　只有web服务器工程师和软件框架的作者才需要了解和关心WSGI设计的每个细节，对于应用层来讲，只需要遵循WSGI协议来安装和使用现有的框架去编写网络程序就够了。wsgiref提供WSGI环境变量以及HTTP header的回复等的各种操作方法，以及性能评测工具。\n\n## wsgiref.util – WSGI environment utilities\n　　此模块包含操作WSGI环境变量的众多方法。WSGI环境变量是一个包含HTTP请求参数的dict，处理函数要使用一个*environ* 的参数来接收它。\n\n* __wsgiref.util.guess_scheme(*environ*)__\n\n\t返回```wsgi.url_scheme```为“http”还是“https”，它是通过检查*environ* dict中的“HTTP”环境变量来实现的。返回值为string类型。\n\n\t此方法在创建一个CGI或CGI类（比如FastCGI）协议的装饰器时非常有用。比如服务器在收到基于SSL的请求时，在协议中会包含一个“HTTPS”的变量，其值为“1”、“yes”或“on”等，那么使用此方法将会返回一个“https”，否则就是“http”。\n\n\n* __wsgiref.util.request_uri(*environ, include_query=1*)__\n\n\t返回完整的请求的URI，通过*include_query* 参数来决定是否包含query string。判定算法使用的是PEP 333中的”URL Reconstruction“。\n\n\n* __wsgiref.util.application_uri(*environ*)__\n\n\t与request_uri方法类似，但这里忽略了PATH_INFO和QUERY_STRING变量。结果就是请求的应用程序对象地址的base URI。\n\n\n* __wsgiref.util.shift_path_info(*environ*)__\n\n\t从PATH_INFO中移出一个单词到SCRIPT_NAME，并且将之返回。*environ* 将会以空格填补，如果需要的话必须先保存原始的PATH_INFO和SCRIPT_NAME变量。\n\n\t如果PATH_INFO再没有可以移出的部分，执行此方法就会返回一个None。\n\n\t典型情况，一个需求要处理请求URI路径的每个部分，比如遍历一系列的dict的键来修改传入的环境使其适合调用另一个位于目标URI的WSGI程序。比如，有一个WSGI程序位于/foo，而请求的URI路径是/foo/bar/baz，那么位于/foo的应用程序调用 ```shift_path_info()```，将会返回\"bar\"。然后环境将更新来适配位于/foo/bar的WSGI应用程序。这样一来，SCRIPT_NAME将会从/foo变成/foo/bar，PATH_INFO将从/bar/baz变成/baz。\n\n\t当PATH_INFO只剩“/”，就返回一个空的string并且给SCRIPT_NAME追加一个反斜杠，即便是空的路径被忽略或者SCRIPT_NAME没有正常的终止于反斜杠。这是故意设置的，来确保在对象遍历时应用程序能够区分以“/x/”和“/x”结尾的URI。\n\n\n* __wsgiref.util.setup_testing_defaults(*environ*)__\n\n 通过默认值来更新*environ*变量，用于测试用途。\n\n 这个路由添加多个用于请求WSGI的参数，包括HTTP_HOST、SERVER_NAME、SERVER_PORT、REQUEST_METHOD、SCRIPT_NAME、PATH_INFO和所有在PEP 333中定义的以“wsgi.”开头的变量。只支持默认的值，并且不会替换他们当中任何已经存在的设定值。\n\n 此方法主要用来方便的模拟一个环境用于单元测试。由于数据是模拟的，所以不应用于生产服务器和应用程序中。\n\n 一个示例：\n        from wsgiref.util import setup_testing_defaults\n        from wsgiref.simple_server import make_server\n\n        # A relatively simple WSGI application. It's going to print out the\n        # environment dictionary after being updated by setup_testing_defaults\n\n        def simple_app(environ, start_response):\n            setup_testing_defaults(environ)\n\n            status = '200 OK'\n            headers = [('Content-type', 'text/plain')]\n\n            start_response(status, headers)\n\n            ret = [\"%s: %s\\n\" % (key, value) for key, value in environ.iteritems()]\n            return ret\n        httpd = make_server('', 8000, simple_app)\n        print \"Serving on port 8000...\"\n        httpd.serve_forever()\n\n\t除了上述功能，wsgiref.util还提供了一些杂项工具：\n\n* __wsgiref.util.is_hop_by_hop(*header_name*)__\n\n\t如果“‘header_name”是RFC 2616中定义的HTTP/1.1 “Hop-by-Hop” header，则返回True。\n\n\n* ___class___ wsgiref.util.__FileWrapper(*filelike, blksize=8192*)__\n\n\t一个装饰器，用来把file-like对象转换成一个迭代器，返回的对象支持```__getitem__()```和```__iter__()```两种循环风格。当对象迭代时，可选的*blksize*参数将被传入file-like对象的```read()```方法中用来获取产生的字符串。```当read()```方法返回一个空字符串时，迭代结束，且此对象不可恢复。\n\n\t如果file-like对象有一个```close()```方法，那么转换后的对象依然有一个```close()```方法，并且在调用这个对象的```close()```方法时触发file-like对象的```close()```方法。\n\n\t示例：\n\n\t\tfrom StringIO import StringIO\n\t\tfrom wsgiref.util import FileWrapper\n\n\t\t# We're using a StringIO-buffer for as the file-like object\n\n\t\tfilelike = StringIO(\"This is an example file-like object\"*10)\n\t\twrapper = FileWrapper(filelike, blksize=5)\n\n\t\tfor chunk in wrapper:\n\t\t    print chunk\n\n",
"first_figure": "/static/blog/img/project/20160811/0.jpg"
},
"20150503": {
"create_time": "2015年5月3日",
"id": 20150503,
"content": "##类\n　　类即class，和结构体有很多共同的地方，主要区别在于类的成员分为三种类型：公共、私有和受保护的。相较于结构体，类严格定义了对成员的访问的权限，以及全新的数据复制等机制。可以像下面定义一个类,并声明一个具体的对象：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\t\t\t\t...\n\t\t\tprivate:\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\n\t\t\tprotected:\n\t\t\t\t...\n\t\t};\n\n\t\tCBook MathBook;\n\n　　成员函数不必定义在类的内部，如需定义在外部同时避免调用程序时跳转的开销，可以将函数定义为内联函数。这样，程序的代码块会直接嵌入到函数声明的地方，提高运行效率。假设上述的类中有成员函数```int GetPage();```,则在类外可以这样定义：\n\n\t\tinline int CBook::GetPage()\n\t\t{\n\t\t\treturn m_Page;\n\t\t}\n\t\t\n　　其中添加“::”的目的是告诉编译器，后面的函数归于前面的类。类内的函数可以访问类内的成员，但类外的函数只能访问public成员。可以使用inline关键字将普通的函数也定义为内联函数，只要函数体比较短小，就不会显著增加代码的体积。\n\n##友元函数\n　　在类中可以定义一类可以访问任何成员的函数，被称为友元函数。在类中声明友元函数和声明普通成员函数的唯一区别在于，需要给友元函数的原型前添加friend关键字。因为友元函数不是类的成员，所以友元函数在类中声明的位置不影响函数的访问权限。友元函数总是可以被访问的，它拥有和普通成员函数同等的特权。可以向下面这样声明友元函数：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\t\t\t\t...\n\t\t\tprivate:\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\n\t\t\tprotected:\n\t\t\t\t...\n\t\t\tfriend void showPage(CBook & book);\n\t\t};\n\n\t\tvoid showPage(CBook & book)\n\t\t{\n\t\t\tcout << book.m_Page << endl;\n\t\t}\n\n##类构造函数\n　　类构造函数是特殊的函数，没有返回值，它唯一的作用是在创建具体类对象的时候调用。上述的类中，```CBook()```就是一个构造函数。在命名上，没有任何商量的余地，一个类的构造函数必须和类的名字完全相同。如果我们不去定义类构造函数，那么编译器会提供一个默认的构造函数，但它什么也不做。我们最多可以定义两个类构造函数，一个不带参数，另一个带参数。如下定义构造函数，并在适当位置声明两个具体对象：\n\n\t\tCBook::CBook()\n\t\t{\n\t\t\tm_Page=0;\n\t\t\tm_Year=2015；\n\t\t\t...\n\t\t}\n\n\t\tCBook::CBook(int page,int year...)\n\t\t{\n\t\t\tm_Page=page;\n\t\t\tm_Year=year;\n\t\t\t...\n\t\t}\n\n\t\tCBook MathBook;\n\t\tCBook EnglishBook(200,2015...);\n\n　　如果我们只提供了上面第二个类构造函数，当我们执行语句```CBook MathBook;```编译器就会报错。因为编译器不再提供默认的构造函数```CBook()```，所以为了解决报错的问题，可以给上述第二个函数带上默认的实参，比如```CBook::CBook(int page = 0, int year = 2015, ...)```。要注意只有一个构造函数时才能这么做，如果同时还提供了默认的构造函数```CBook()```，那么当声明一个不带参数的类对象时，编译器不知道应该调用哪个类构造函数而报错，因为两个都适用。\n\n##避免隐式的类型装换\n　　当有时只使用一个参数来定义一个类对象时，可能会进行隐式的数据类型转换，有时需要避免这样的情况，可以在构造函数前添加关键字explicit。如果在构造函数前添加explicit，则不能用“=”来给一个类对象初始化，比如：```\n\t\tCBook EnglishBook = 200;```,因为这样会涉及隐式的类型转换。这时只能使用函数表示法来为具体的类对象初始化,比如```CBook EnglishBook(200);```。当然此处举例限定的情况是：假定构造函数只有一个参数。\n\n##this指针\n　　类中的任何成员函数在执行时，都会包含一个隐藏的指针，名为this指针，它指向调用该函数时使用的对象。诸如上述的```CBook::GetPage()```函数，其实就是使用this->m_Page。\n\n##类的const对象\n　　如果需要创建固定的类对象，只需要在声明时添加const关键字。比如```const CBook EngBook( ...);```，其中“...”表示CBook类定义的所有实参。这样一来，如果此类中有任何尝试修改类中成员的函数，都不允许被调用，否则编译器将报错。\n\n　　同样，如果不希望某个成员函数修改成员的值，也必须将其定义为const函数，方法是在该函数的后面写上const关键字，比如：```int CBook::GetPage() const```，此时它也被称作只读函数，因为该函数的this指针也同为const型，所以在函数内不能将类的数据成员写在赋值语句的左边。 const成员函数也不能调用非const成员函数。\n\n##类的静态成员\n　　和普通函数的静态成员一样，类的静态成员可以独立于本类的任何具体对象，适用于成员函数和数据成员。当定义一个静态的数据成员时，必须在类内声明成员，而在类外初始化，因为类内只是描绘类的特性，而不是具体的对象。下面是一个定义类静态数据成员和成员函数的实例：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\t\t\t\t\n\t\t\t\tstatic void ShowObjectCount()\n\t\t\tprivate:\n\t\t\t\t...\n\t\t\t\tstatic int ObjectCount;\n\t\t\tprotected:\n\t\t\t\t...\n\t\t};\n\n\t\tint CBook::ObjectCount = 0;\n\t\tvoid CBook::ShowObjectCount()\n\t\t{\n\t\t\tcout << ObjectCount << endl;\n\t\t}\n\n　　使用static成员函数的优势是，即使没有一个具体的类对象，也能调用它，比如可以执行```CBook::ShowObjectCount();```。\n\n",
"layout": "post",
"title": "学习C++之八：类",
"category": "学习笔记",
"description": "组织数据的一种方式",
"preview": "类即class，和结构体有很多共同的地方，主要区别在于类的成员分为三种类型：公共、私有和受保护的。相较于结构体，类严格定义了对成员的访问的权限，以及全新的数据复制等机制。可以像下面定义一个类,并声明一个具体的对象：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\t\t\t\t...\n\t\t\tprivate:\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\n\t\t\tprotected:\n\t\t\t\t...\n\t\t};\n\n\t\tCBook MathBook;\n\n　　成员函数不必定义在类的内部，如需定义在外部同时避免调用程序时跳转的开销，可以将函数定义为内联函数。这样，程序的代码块会直接嵌入到函数声明的地方，提高运行效率。假设上述的类中有成员函数```int GetPage();```,则在类外可以这样定义：\n\n\t\tinline int CBook::GetPage()\n\t\t{\n\t\t\treturn m_Page;\n\t\t}\n\t\t\n　　其中添加“::”的目的是告诉编译器，后面的函数归于前面的类。类内的函数可以访问类内的成员，但类外的函数只能访问public成员。可以使用inline关键字将普通的函数也定义为内联函数，只要函数体比较短小，就不会显著增加代码的体积。\n\n##友元函数\n　　在类中可以定义一类可以访问任何成员的函数，被称为友元函数。在类中声明友元函数和声明普通成员函数的唯一区别在于，需要给友元函数的原型前添加friend关键字。因为友元函数不是类的成员，所以友元函数在类中声明的位置不影响函数的访问权限。友元函数总是可以被访问的，它拥有和普通成员函数同等的特权。可以向下面这样声明友元函数：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\t\t\t\t...\n\t\t\tprivate:\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\n\t\t\tprotected:\n\t\t\t\t...\n\t\t\tfriend void showPage(CBook & book);\n\t\t};\n\n\t\tvoid showPage(CBook & book)\n\t\t{\n\t\t\tcout << book.m_Page << endl;\n\t\t}\n\n##类构造函数\n　　类构造函数是特殊的函数，没有返回值，它唯一的作用是在创建具体类对象的时候调用。上述的类中，```CBook()```就是一个构造函数。在命名上，没有任何商量的余地，一个类的构造函数必须和类的名字完全相同。如果我们不去定义类构造函数，那么编译器会提供一个默认的构造函数，但它什么也不做。我们最多可以定义两个类构造函数，一个不带参数，另一个带参数。如下定义构造函数，并在适当位置声明两个具体对象：\n\n\t\tCBook::CBook()\n\t\t{\n\t\t\tm_Page=0;\n\t\t\tm_Year=2015；\n\t\t\t...\n\t\t}\n\n\t\tCBook::CBook(int page,int year...)\n\t\t{\n\t\t\tm_Page=page;\n\t\t\tm_Year=year;\n\t\t\t...\n\t\t}\n\n\t\tCBook MathBook;\n\t\tCBook EnglishBook(200,2015...);\n\n　　如果我们只提供了上面第二个类构造函数，当我们执行语句```CBook MathBook;```编译器就会报错。因为编译器不再提供默认的构造函数```CBook()```，所以为了解决报错的问题，可以给上述第二个函数带上默认的实参，比如```CBook::CBook(int page = 0, int year = 2015, ...)```。要注意只有一个构造函数时才能这么做，如果同时还提供了默认的构造函数```CBook()```，那么当声明一个不带参数的类对象时，编译器不知道应该调用哪个类构造函数而报错，因为两个都适用。\n\n##避免隐式的类型装换\n　　当有时只使用一个参数来定义一个类对象时，可能会进行隐式的数据类型转换，有时需要避免这样的情况，可以在构造函数前添加关键字explicit。如果在构造函数前添加explicit，则不能用“=”来给一个类对象初始化，比如：```\n\t\tCBook EnglishBook = 200;```,因为这样会涉及隐式的类型转换。这时只能使用函数表示法来为具体的类对象初始化,比如```CBook EnglishBook(200);```。当然此处举例限定的情况是：假定构造函数只有一个参数。\n\n##this指针\n　　类中的任何成员函数在执行时，都会包含一个隐藏的指针，名为this指针，它指向调用该函数时使用的对象。诸如上述的```CBook::GetPage()```函数，其实就是使用this->m_Page。\n\n##类的const对象\n　　如果需要创建固定的类对象，只需要在声明时添加const关键字。比如```const CBook EngBook( ...);```，其中“...”表示CBook类定义的所有实参。这样一来，如果此类中有任何尝试修改类中成员的函数，都不允许被调用，否则编译器将报错。\n\n　　同样，如果不希望某个成员函数修改成员的值，也必须将其定义为const函数，方法是在该函数的后面写上const关键字，比如：```int CBook::GetPage() const```，此时它也被称作只读函数，因为该函数的this指针也同为const型，所以在函数内不能将类的数据成员写在赋值语句的左边。 const成员函数也不能调用非const成员函数。\n\n##类的静态成员\n　　和普通函数的静态成员一样，类的静态成员可以独立于本类的任何具体对象，适用于成员函数和数据成员。当定义一个静态的数据成员时，必须在类内声明成员，而在类外初始化，因为类内只是描绘类的特性，而不是具体的对象。下面是一个定义类静态数据成员和成员函数的实例：\n\n\t\tclass CBook\n\t\t{\n\t\t\tpublic:\n\t\t\t\tCBook();\n\t\t\t\t~CBook();\n\n\t\t\t\tint m_Page;\n\t\t\t\tint m_Year;\n\t\t\t\t...\t\t\t\t\n\t\t\t\tstatic void ShowObjectCount()\n\t\t\tprivate:\n\t\t\t\t...\n\t\t\t\tstatic int ObjectCount;\n\t\t\tprotected:\n\t\t\t\t...\n\t\t};\n\n\t\tint CBook::ObjectCount = 0;\n\t\tvoid CBook::ShowObjectCount()\n\t\t{\n\t\t\tcout << ObjectCount << endl;\n\t\t}\n\n　　使用static成员函数的优势是，即使没有一个具体的类对象，也能调用它，比如可以执行```CBook::ShowObjectCount();```。\n\n",
"first_figure": "/static/blog/img/preview_0.jpg"
},
"20161225": {
"create_time": "2016年12月25日",
"id": 20161225,
"content": "<img   src=\"/static/blog/img/blog/20161211/0.jpg\" style=\"width: 100%\">\n### 一个注重内容、轻量级，永久免费的markdown编辑器\n　　为什么要写编辑器呢？我相信很多人用markdown写博客的时候，都苦于没有一个好用的markdown转html的编辑器。要么是重量级的IDE，要么就是花里胡哨的页面、弹乱七八糟的广告。如果你一直在寻找一个足够简单，有一定的分享性，同时容易使用的工具，那没准你现在已经找到了。\n\n### 开始使用\n　　如果你还不了解markdown语法，这里有一个很好的介绍：[markdown语法说明](http://www.appinn.com/markdown/)。文章开始用“---”包含起来的部分，我称它为“content-header”，你可以像示例那样自由的添加属性。下面是几个疯人编辑器支持的属性：\n\n* sendto  点击【保存】按钮之后，将文章发送到这个邮箱（目前仅支持发送给你自己）\n* title  文章标题\n* category  分类（暂时没什么用）\n* tags  文章的标签（暂时没什么用）\n* description  文章的简短描述（暂时没什么用）\n\n　　没错，你在这里写的所有的文章，不仅可以保存到这个站点，还可以保存的你的邮箱。但出于安全起见，你必须经过身份验证。我对很多网站的注册程序非常厌恶，往往它需要我们填写一大堆没有什么作用的表项。而在这里很简单，只需输入你的邮箱名，然后设置一个密码。即使是注册，也只有两个表格，这意味着你只需要输入一次密码。如果你手抖输错了，那就会注册成这个错误的密码，但我相信没有哪个傻蛋会遇到这种情况。你现在就可以点击【保存】按钮试一试。\n\n　　最后值得一提的是，在文章里插入图片其实很简单。虽然这个版本已经十分快捷了，但在下个版本中，把图片拖拽到输入框内，就会自动将链接插入到光标处，只需一步。<img src=\"/static/blog/img/project/20161225/upload_image.gif\" style=\"width: 100%\">\n### 安全和隐私\n　　归功于无数计算机先驱和科学家们的不懈探索和努力，现在的计算机和它诞生之初已经不可同日而语。而现代计算的机当中的硬盘，和它的CPU、RAM以及昂贵的带宽相比，则更加不值一提。这是为什么现在的互联网厂商都千方百计搜集用户的各种各样的信息并且存储下来以供日后方便的一个重要原因。\n\n　　信息时代，一旦你把某些东西上传到了互联网，那么它永远都不会有被删除的那一天。即使你点击了删除按钮，那也不过是在数据库的某条记录上做了一个“已删除”的标记罢了，而它本身依然完好的存在。必要的时候，它仍然可以被转发和散播， 甚至被心怀不轨之人所利用。这是一件可怕而且值得重视的问题。\n\n　　你在caoliang.net上上传的所有资料，网站的维护者都尽可能的保护你的隐私，但诚实的说，你的资料依然有可能会其他人查阅，甚至大范围泄露到互联网，你的信息安全在这里并没有充足的保障。所以，请不要在这里上传敏感信息。\n\n### 最后\n　　已知的问题：\n* 由于阿里云的限制，发送的邮件将有很大几率被他们的服务器拦截。所以，“保存到邮箱”是一个碰运气的功能\n* 导出为pdf将在2017年上线\n\n　　有任何的建议，欢迎发送邮件反馈。反馈邮箱：i@caoliang.net。",
"title": "疯人编辑器",
"sendto": "calom@qq.com",
"category": "学习笔记",
"tags": [
"编程",
"博客"
],
"description": "一个注重内容、轻量级，永久免费的markdown编辑器",
"preview": "为什么要写编辑器呢？我相信很多人用markdown写博客的时候，都苦于没有一个好用的markdown转html的编辑器。要么是重量级的IDE，要么就是花里胡哨的页面、弹乱七八糟的广告。如果你一直在寻找一个足够简单，有一定的分享性，同时容易使用的工具，那没准你现在已经找到了。\n\n### 开始使用\n　　如果你还不了解markdown语法，这里有一个很好的介绍：[markdown语法说明](http://www.appinn.com/markdown/)。文章开始用“---”包含起来的部分，我称它为“content-header”，你可以像示例那样自由的添加属性。下面是几个疯人编辑器支持的属性：\n\n* sendto  点击【保存】按钮之后，将文章发送到这个邮箱（目前仅支持发送给你自己）\n* title  文章标题\n* category  分类（暂时没什么用）\n* tags  文章的标签（暂时没什么用）\n* description  文章的简短描述（暂时没什么用）\n\n　　没错，你在这里写的所有的文章，不仅可以保存到这个站点，还可以保存的你的邮箱。但出于安全起见，你必须经过身份验证。我对很多网站的注册程序非常厌恶，往往它需要我们填写一大堆没有什么作用的表项。而在这里很简单，只需输入你的邮箱名，然后设置一个密码。即使是注册，也只有两个表格，这意味着你只需要输入一次密码。如果你手抖输错了，那就会注册成这个错误的密码，但我相信没有哪个傻蛋会遇到这种情况。你现在就可以点击【保存】按钮试一试。\n\n　　最后值得一提的是，在文章里插入图片其实很简单。虽然这个版本已经十分快捷了，但在下个版本中，把图片拖拽到输入框内，就会自动将链接插入到光标处，只需一步。### 安全和隐私\n　　归功于无数计算机先驱和科学家们的不懈探索和努力，现在的计算机和它诞生之初已经不可同日而语。而现代计算的机当中的硬盘，和它的CPU、RAM以及昂贵的带宽相比，则更加不值一提。这是为什么现在的互联网厂商都千方百计搜集用户的各种各样的信息并且存储下来以供日后方便的一个重要原因。\n\n　　信息时代，一旦你把某些东西上传到了互联网，那么它永远都不会有被删除的那一天。即使你点击了删除按钮，那也不过是在数据库的某条记录上做了一个“已删除”的标记罢了，而它本身依然完好的存在。必要的时候，它仍然可以被转发和散播， 甚至被心怀不轨之人所利用。这是一件可怕而且值得重视的问题。\n\n　　你在caoliang.net上上传的所有资料，网站的维护者都尽可能的保护你的隐私，但诚实的说，你的资料依然有可能会其他人查阅，甚至大范围泄露到互联网，你的信息安全在这里并没有充足的保障。所以，请不要在这里上传敏感信息。\n\n### 最后\n　　已知的问题：\n* 由于阿里云的限制，发送的邮件将有很大几率被他们的服务器拦截。所以，“保存到邮箱”是一个碰运气的功能\n* 导出为pdf将在2017年上线\n\n　　有任何的建议，欢迎发送邮件反馈。反馈邮箱：i@caoliang.net。",
"first_figure": "/static/blog/img/blog/20161211/0.jpg"
},
"20170808": {
"create_time": "2017年8月8日",
"id": 20170808,
"content": "<img src=\"/static/blog/img/blog/20170808/0.jpg\" style=\"width: 100%\">\n　　南朝宋国谢灵运尝曰：“天下才有一石，曹子建独占八斗，我得一斗，天下共分一斗。” 从此可见谢灵运自命不凡和狂妄自大。说谢灵运恃才傲物，人家倒也是有资本的。谢灵运出生在南朝大族，自幼聪明好学，学识广博。一句“池塘生春草，园柳变鸣禽”让人暇想万千，彰显出了他的儒雅文风，足以俱备显才的资格。也正是他的有才，葬送了他的一切。谢灵运仗着自己有才，走上了政坛，仕途一路顺风，曾官做到过中书侍郎。后南朝刘宋武帝永初元年刘裕取晋立宋国后，把谢灵运官职一降再降，一句话就是对谢灵运的不信任。\n<!--more-->\n\n　　到了刘宋文帝元嘉三年的时候，文帝刘义隆为巩固其统治，对世家大族采取笼络政策，谢灵运由于名气大，被征召为秘书监，还被指定撰修晋史。其实这只是利用而并非重用，谢灵运看自己的政治抱负不得实现，反屡遭排挤，以后便不理政务，一味纵情山水，写写诗文。\n\n　　如果说谢灵运就这样也就罢了，可他偏偏喜欢纠集一帮人，议论朝政，结果受了牢狱之苦。到了晚年谢灵运又动了造反的念头，兵败身亡。\n\n　　象谢灵运这样自喻只占了世间一成才的能人，所做之事，让后人觉得不可理喻，他的这种自大也被世人笑话了几百年。\n\n　　可抬眼看看身边的牛人，可有和谢灵运可比？不过你可不能小看了他们，我到觉得他们要比谢灵运强，谢灵运只认为身有一斗才能，可多少不知天高地厚的人，认为他才是天下之大才。这种人评论自己时应该是这样的：“天下才有一石，我得十斗，纵有子建重生，不过斗底残剩。”\n\n　　其实，我们身边绝大多数人都是凡夫俗子，只是凭着自己在社会中所饰演的这么一个小角色，从事着为养家糊口不得已而为之的所谓工作。也就是这工作，有的人如鱼得水，应付自如；有的人如必履溥冰，患得患失；有的人痛苦不堪，步履艰难。不管怎样，这都体现了一种能力，这种能力是种才能，但不是全部。有的人为了掩饰自己的无知，拼命的想把自己粉饰的象个大学教授，结果却是东施效颦。\n\n　　还有的人没才就没才，本来也没有人笑话，可非要把自己扮成无赖。大事小事一推六二五，什么也不干，一问什么也不会啊！这倒成了堂而皇之的理由，真是可笑。说是这样说，可这样的蠢材却也背后窃笑着，这么一群傻蛋，让他们干去吧，累死他们活该！唉，这也是新时代的人才啊！\n",
"title": "转载：从谢灵运独占天下一斗才说起",
"author": "碧浪清波 @新浪博客 （<a target=\"_blank\" href=\"http://blog.sina.com.cn/s/blog_5325f6ce0100f9jo.html\">http://blog.sina.com.cn/s/blog_5325f6ce0100f9jo.html</a>）",
"category": "观点",
"tags": [
"生活"
],
"description": "从谢灵运独占天下一斗才说起",
"preview": "南朝宋国谢灵运尝曰：“天下才有一石，曹子建独占八斗，我得一斗，天下共分一斗。” 从此可见谢灵运自命不凡和狂妄自大。说谢灵运恃才傲物，人家倒也是有资本的。谢灵运出生在南朝大族，自幼聪明好学，学识广博。一句“池塘生春草，园柳变鸣禽”让人暇想万千，彰显出了他的儒雅文风，足以俱备显才的资格。也正是他的有才，葬送了他的一切。谢灵运仗着自己有才，走上了政坛，仕途一路顺风，曾官做到过中书侍郎。后南朝刘宋武帝永初元年刘裕取晋立宋国后，把谢灵运官职一降再降，一句话就是对谢灵运的不信任。\n",
"first_figure": "/static/blog/img/blog/20170808/0.jpg"
},
"20160904": {
"create_time": "2016年9月4日",
"id": 20160904,
"content": "<img src=\"/static/blog/img/blog/20160904/0.jpg\" alt=\"money\" style=\"width:100%;\"/>\n\n　　难得的周末时光，当我正要上床休息时，一个同学给我发来求助信息，说是自己的比赛项目没有进展，请我稍稍指导一下。谁没有做新手的时候呢，心想着应该也不是什么大问题，就爽快答应了。\n<!--more-->\n\n　　我本以为是思路的问题，谁知道他直接发了两个Doc文档让我review代码。虽然我很讨厌看别人的代码，但本着助人为乐的精神还是认真的过了一遍。在他的程序里没有明显的结构、逻辑条理非常混乱，像是要在一个模块里做一万件事情，我抓破头皮也猜不出他这些代码的目的。debug半天无果之后，我抛给他“单元测试”四个字之后就倒床休息了。更多的，我也帮不了。\n\n　　最近朋友圈里有一句话很火，叫“先挣他一个亿”，这是亚洲首富王健林在一档综艺节目里说的，可惜很多人都忽略了上下语境，只记住了这一句话。原话是这样的：\n\n> 　　很多学生一见面上来一句话就是我要当首富，我要做世界最大的公司。这个你得跟他聊，哪方面做到最大，从什么地方开始，（他）说不出来。有这个想法是对，但是最好先定一个能达到的小目标。比方说我先挣它一个亿，应该到了一个亿我再说下一个目标，我说这是个目标，做到了更好，做不到咱挣了八千万挣了五千万不也挺乐呵？那先要把目标放大。\n\n　　很多人都惊讶于王总的财大气粗，随随便便一个小目标，却是我们平民奋斗一辈子也难以企及的梦想，不禁慨叹人与人之间差别之巨大，让人怀疑奋斗的意义。当今的王总身家1700多亿，即便一年挣一亿，那也得挣一千七百多年，如果以做首富为参照系，这个目标确实不值一提。如果你只是想挣一个亿，那挣100万就是一个小目标，当然他对于大多数人还很遥远，但如果你的目标是挣到100万，“先挣他一万”就应该是谁都可以实现的目标了。我想更多人的目标是让生活过的更幸福美好而不是真的想当世界首富，挣100万就是一个切实的目标。但不管是一个亿还是100万，一万都是一个基石，只有当这个点跨越了，才能使最终的目标离得更近。\n\n　　这个过程和函数栈如出一辙，我们使用API就能随随便便地绘制一个窗口、发送一条网络消息，但即使如此简单的功能，都有无数条指令在后台执行。它们不是并发的，而是逐层调用，最底一层也许只是给某个IO翻转一下电平，又或者是改写了某个内存单元，但正是这种微小的指令构成一个个模块，从硬件层一直往上，一层一层最终支撑起了整个项目。\n\n　　要实现一个大的目标，就要分布实施。如果有能力做到最大，当然可以一步做到，但现实中谁能上来就创建世界上最大的公司、出生就是首富呢？没有这种一步到位的能力，就要思考自己能做到什么程度。选中一个基本点，然后在基础上添砖加瓦，这才是成事基本的道理。就拿智能车比赛来讲，首先把通信部分、电机部分各自调试OK了，再对接一起，做前端以及更高层的工作。如果乱起砸八掺在一起，你发现你要解决的不是一件事，而是大大小小一万件事。而回过头来，如果连最基本的电机控制部分都不能完成，就要细分更小的任务，比如搞定电源模块、驱动模块的和控制模块等等。如果每个单元都能做的很好，最后你会发现所有的工作只是像搭积木一样简单。一个有条理的计划和一个个细分到能够实施的小目标是成功的关键。\n\n　　我在《创客星球》看过一期节目，一个创业公司企图做出一辆各个方面都有巨大创新的电动车，体积更小、电力更强大，还有更轻、扭矩更强的电机，声称在各项指标都要达到世界前三。而现场演示的时候，拿来的样品破烂不堪，没有任何设计感，而且只是作展示而不能骑动。其中一位评委试坐时，轮毂上竟然掉落了一个螺栓，现场场面尴尬至极。尽管该负责人连连解释由于时间急促导致样品装配工艺存在问题，又拿来精美的宣传文案展示，说的天花乱坠，最后也没能得到支持。这种结局是显而易见的了。当然还有罗永浩的锤子科技，口口声声要收购苹果的公司、重新定义国产高端手机，如今却面临窘境。很多事情不是一步做完的，我坚信锤子可以收购苹果，但前提是把它当作一个长远的目标，先定一个小目标，比如做出一些有稳定用户群体的产品，再扩充规模、更新迭代，可惜老罗想把十年的事情浓缩到一年来做，结果一年的事情做了两年。\n\n　　罗马不是一天建成的，放慢节奏、稳扎稳打、步步为营才能是通往成功的捷径。拦住我们去路的那些鸿沟，很多时候都只是当年我们天真的以为没有必要修补而直接跳过的小坑。",
"layout": "post",
"title": "先挣他一个亿",
"category": "观点",
"tags": [
"生活"
],
"preview": "难得的周末时光，当我正要上床休息时，一个同学给我发来求助信息，说是自己的比赛项目没有进展，请我稍稍指导一下。谁没有做新手的时候呢，心想着应该也不是什么大问题，就爽快答应了。\n",
"first_figure": "/static/blog/img/blog/20160904/0.jpg"
},
"20150429": {
"create_time": "2015年4月29日",
"id": 20150429,
"content": "##异常\n　　在某些特定的情况下，程序的运行会难免产生错误，而标志程序中产生错误或者意外状态，叫做异常。之前用new操作符来申请内存时，也有可能返回异常，但我们编写程序时将其忽略。下面我们学习如何捕获这种异常，并且在异常发生后做一些挽救。\n\n　　运行下面程序：\n\n``` \n#include<iostream>\n#include<new>\n\nusing\tstd::bad_alloc;\nusing\tstd::cout;\nusing\tstd::endl;\n\nvoid main(void)\n{\n\tchar* pdata(nullptr);\n\n\twhile(1)\n\t{\n\t\ttry\n\t\t{\n\t\t\tpdata = new char[static_cast<size_t>(100)];\n\t\t}\n\t\tcatch(bad_alloc &ex)\n\t\t{\n\t\t\tcout << \"memory allocation failed !\" << endl\n\t\t\t\t << \"the information from the exception object is :\" << ex.what() <<endl;\n\t\t\tbreak ;\n\t\t}\n\t}\n}\n```\n\n　　上面的程序使用new操作符反复申请一个长度为100的char型数组，直到系统资源被消耗殆尽，最终导致内存申请失败，new抛出一个异常。在try标示的可能出现异常的代码块下方的catch代码块中，捕获new操作抛出的bad_alloc类型的异常，并执行信息输出操作。可以看到，程序输出：\n\n\t\tmemory allocation failed !\n\t\tthe information from the exception object is :bad allocation\n\n　　需要注意到，当不能申请到内存时，new抛出一个bad_alloc类型的异常，bad_alloc是new标准头文件中定义的类类型，所以需要包含<new>头文件。\n\n##异常机制\n　　异常机制使用三个关键字，```try```、 ```throw```和```catch```。把可能发生异常的代码包含在try的代码块内，其中的代码会按照顺序正常执行。try代码块中，使用throw或者包含throw操作的函数来抛出一个异常，此时程序立即跳转到与抛出的异常相匹配的catch代码块中。此时仍可在catch块中使用没有操作数的throw来重新抛出异常，这样就会把抛出的异常转交给调用函数，以执行某些附加的操作。运行下面程序：\n\n```\n#include<iostream>\nusing\tstd::cout;\nusing\tstd::endl;\n\nvoid main(void)\n{\n\tint sum[]={1,2,3,4,5};\n\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\ttry{\n\t\t\tif(sum[i] == 1) throw 1;\n\t\t\tif(sum[i] == 2) throw \"sum[i] is 2.\";\n\t\t\tif(sum[i] == 3) throw 'x';\n\t\t}\n\t\tcatch(const char* a){\n\t\t\tcout << a << endl;\n\t\t}\n\t\tcatch(const int a){\n\t\t\tcout << a << endl;\n\t\t}\n\t\tcatch(...){\n\t\t\tcout << \"error !\" << endl;\n\t\t}\n\t}\n\tcout << \"program has been terminated.\"\n\t\t << endl;\n}\n```\n\n　　运行结果：\n\n\t\t1\n\t\tsum[i] is 2.\n\t\terror !\n\t\tprogram has been terminated.\n\n　　程序在for循环中判断sum数组中元素的值，如果为1，则抛出一个const int类型的异常，然后用第二个catch代码块来捕获，将const int输出。因此第一行输出数字1。当sum某个元素值等于2时，抛出一个字符串，实质上是抛出一个字符数组类型的异常，被第一个catch代码块捕获，输出这个字符数组。第三个catch的括号中是三个点，它可以处理任何异常，在前两个catch代码块中无法处理的异常，都在这里处理。因此，在一个try中可以抛出多个不同类型的异常，后可跟多个catch分别捕获不同类型的异常。而且，如果有```catch(...) {... ...}```，则必须放在最后。",
"layout": "post",
"title": "学习C++之六：异常的处理",
"category": "学习笔记",
"description": "处理程序运行错误",
"preview": "在某些特定的情况下，程序的运行会难免产生错误，而标志程序中产生错误或者意外状态，叫做异常。之前用new操作符来申请内存时，也有可能返回异常，但我们编写程序时将其忽略。下面我们学习如何捕获这种异常，并且在异常发生后做一些挽救。\n\n　　运行下面程序：\n\n``` \n#include<iostream>\n#include<new>\n\nusing\tstd::bad_alloc;\nusing\tstd::cout;\nusing\tstd::endl;\n\nvoid main(void)\n{\n\tchar* pdata(nullptr);\n\n\twhile(1)\n\t{\n\t\ttry\n\t\t{\n\t\t\tpdata = new char[static_cast<size_t>(100)];\n\t\t}\n\t\tcatch(bad_alloc &ex)\n\t\t{\n\t\t\tcout << \"memory allocation failed !\" << endl\n\t\t\t\t << \"the information from the exception object is :\" << ex.what() <<endl;\n\t\t\tbreak ;\n\t\t}\n\t}\n}\n```\n\n　　上面的程序使用new操作符反复申请一个长度为100的char型数组，直到系统资源被消耗殆尽，最终导致内存申请失败，new抛出一个异常。在try标示的可能出现异常的代码块下方的catch代码块中，捕获new操作抛出的bad_alloc类型的异常，并执行信息输出操作。可以看到，程序输出：\n\n\t\tmemory allocation failed !\n\t\tthe information from the exception object is :bad allocation\n\n　　需要注意到，当不能申请到内存时，new抛出一个bad_alloc类型的异常，bad_alloc是new标准头文件中定义的类类型，所以需要包含<new>头文件。\n\n##异常机制\n　　异常机制使用三个关键字，```try```、 ```throw```和```catch```。把可能发生异常的代码包含在try的代码块内，其中的代码会按照顺序正常执行。try代码块中，使用throw或者包含throw操作的函数来抛出一个异常，此时程序立即跳转到与抛出的异常相匹配的catch代码块中。此时仍可在catch块中使用没有操作数的throw来重新抛出异常，这样就会把抛出的异常转交给调用函数，以执行某些附加的操作。运行下面程序：\n\n```\n#include<iostream>\nusing\tstd::cout;\nusing\tstd::endl;\n\nvoid main(void)\n{\n\tint sum[]={1,2,3,4,5};\n\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\ttry{\n\t\t\tif(sum[i] == 1) throw 1;\n\t\t\tif(sum[i] == 2) throw \"sum[i] is 2.\";\n\t\t\tif(sum[i] == 3) throw 'x';\n\t\t}\n\t\tcatch(const char* a){\n\t\t\tcout << a << endl;\n\t\t}\n\t\tcatch(const int a){\n\t\t\tcout << a << endl;\n\t\t}\n\t\tcatch(...){\n\t\t\tcout << \"error !\" << endl;\n\t\t}\n\t}\n\tcout << \"program has been terminated.\"\n\t\t << endl;\n}\n```\n\n　　运行结果：\n\n\t\t1\n\t\tsum[i] is 2.\n\t\terror !\n\t\tprogram has been terminated.\n\n　　程序在for循环中判断sum数组中元素的值，如果为1，则抛出一个const int类型的异常，然后用第二个catch代码块来捕获，将const int输出。因此第一行输出数字1。当sum某个元素值等于2时，抛出一个字符串，实质上是抛出一个字符数组类型的异常，被第一个catch代码块捕获，输出这个字符数组。第三个catch的括号中是三个点，它可以处理任何异常，在前两个catch代码块中无法处理的异常，都在这里处理。因此，在一个try中可以抛出多个不同类型的异常，后可跟多个catch分别捕获不同类型的异常。而且，如果有```catch(...) {... ...}```，则必须放在最后。",
"first_figure": "/static/blog/img/preview_3.jpg"
},
"20171103": {
"create_time": "2017年11月3日",
"id": 20171103,
"content": "\n<img src=\"/static/blog/img/preview_0.jpg\" style=\"width: 100%\">\n\n　　从出生到十几年的成长日子里，我认为狗不过是一只牲口而已。在我们屯里、我们镇子上，大家无不是这么觉得的。给它喂剩菜剩饭，让它看家护院，仅此而已。\n<!--more-->\n　　上大学那年，新生QQ交流群里有几个同学在讨论养狗的问题。从谈话中我得知，他们的一个狗窝床垫竟然都要花几百几千块，而买狗粮的花费竟然比我的生活费水平还高。一只狗尚且能得到人类无微不至的情感的倾注，吃好喝好，有人陪着玩耍，病了也有人给医治，可狗狗吃的一根火腿肠却是穷苦人家的孩子的奢求。那刻我才意识到原来人与人的阶级差异是很大的，大到让你怀疑自己是否真的跟他们来自同一个世界。穷人家的小孩不如富人家的狗，这句话并不是我说的，可那一刻我突然想起这句话并深深的扎根在心底。\n\n　　有的人不愿相信现在还有这么穷的人。我回到老家，看到那些的孩子，年纪小的就在脏兮兮的庄稼地里地里摸爬滚打，年级稍大点就得帮大人下地干活，他们没有一件好衣裳、一个个被晒的黢黑。上学的娃，要么每天翻越几座大山走几十里路，要么住在学校里几十人一间的通铺宿舍。我见得多了，所以我从不怀疑，我才敢说这世界上有很多人根本不配有孩子，穷人群体占大数比例。\n\n　　一提起穷人不配生孩子，有得人就会急的跳起来，“穷人就没有生育权了？” 是，你是有生育权，那是站在你的角度，可你有没有站在小孩的立场，想想他有“拒绝被生育权”吗？你在生他的时候，有征求过他的意见，问过他是否愿意承受一辈子贫困疾苦和与生俱来的冷眼嘲笑？问他愿不愿意付出数倍于常人的努力却依然过不上正常人的舒坦的生活？你生下他，是他苦苦央求你带他到这个世界上，还是你一厢情愿所作出的自私的决定？自己已经过的很狼狈了，还要让发生在自己身上的苦痛经历在下一代身上重演，我不敢想象这是一种怎样的悲剧。\n\n　　每次我说起这些，总有人说我三观不正，消极堕落。实话说，其实我由衷的感谢我的父母，我就是从穷苦大山里走出来的，小时候经历的饥荒至今历历在目，如果没有父母苦心的培养，没有他们砸锅卖铁供我念书，我可能至今都呆在那个闭塞的乡村，愚昧的活着，苟延残喘的活着。\n\n　　可是作为我自己，我是不想生小孩的。罗永浩曾说，我们这个世界是摧残人的希望的世界，成长的过程是一个苦多乐少的过程。他不忍心再给这个满目疮痍的世界带来更多的苦难，所以这么些年一直没敢要孩子。我很认同他说的这段话。很多念叨着“穷有穷养”的穷人，他们给与小孩的，不仅是物质的缺乏，更是精神的贫窭。口口声声说给小孩竖立正确的三观、“直面困难和学会感恩，生活也会很美好”，可要真正在言传身教中做到，又何其难。\n\n　　我有时在想，如果我真要有了孩子，我愿意倾注全部的爱。可是你知道再坚强的人心里也有柔软的一面，一个人总走在艰难曲折的又孤独无助的人生路上，太远太久，总有一天他会累，会哭，会伤心。如果他真的伤心一秒，我也会陷入无尽的自责和愧疚之中。不过，还好，这也只是想想罢了。",
"title": "穷人家的小孩",
"category": "观点",
"tags": [
"生活"
],
"preview": "\n从出生到十几年的成长日子里，我认为狗不过是一只牲口而已。在我们屯里、我们镇子上，大家无不是这么觉得的。给它喂剩菜剩饭，让它看家护院，仅此而已。\n",
"first_figure": "/static/blog/img/preview_4.jpg"
},
"20171020": {
"create_time": "2017年10月20日",
"id": 20171020,
"content": "\n## <img src=\"/static/blog/img/project/20160821/0.jpg\" alt=\"released\" style=\"width:100%;\"/>\n\n　　译注：这是一篇在Stack overflow上很热的帖子。提问者自称已经掌握了有关Python OOP编程中的各种概念，但始终觉得元类(metaclass)难以理解。他知道这肯定和自省有关，但仍然觉得不太明白，希望大家可以给出一些实际的例子和代码片段以帮助理解，以及在什么情况下需要进行元编程。于是e-satis同学给出了神一般的回复，该回复获得了985点的赞同点数，更有人评论说这段回复应该加入到Python的官方文档中去。而e-satis同学本人在Stack Overflow中的声望积分也高达64271分。以下就是这篇精彩的回复（提示：非常长）\n<!--more-->\n### 类也是对象\n\n在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：\n\n```\n>>> class ObjectCreator(object):\n…       pass\n…\n>>> my_object = ObjectCreator()\n>>> print my_object\n<__main__.ObjectCreator object at 0x8974f2c>\n```\n但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。下面的代码段：\n```\n>>> class ObjectCreator(object):\n…       pass\n…\n```\n将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：\n\n1. 你可以将它赋值给一个变量\n\n2. 你可以拷贝它\n\n3. 你可以为它增加属性\n\n4. 你可以将它作为函数参数进行传递\n\n下面是示例：\n```\n>>> print ObjectCreator     # 你可以打印一个类，因为它其实也是一个对象\n<class '__main__.ObjectCreator'>\n>>> def echo(o):\n…       print o\n…\n>>> echo(ObjectCreator)                 # 你可以将类做为参数传给函数\n<class '__main__.ObjectCreator'>\n>>> print hasattr(ObjectCreator, 'new_attribute')\nFasle\n>>> ObjectCreator.new_attribute = 'foo' #  你可以为类增加属性\n>>> print hasattr(ObjectCreator, 'new_attribute')\nTrue\n>>> print ObjectCreator.new_attribute\nfoo\n>>> ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量\n>>> print ObjectCreatorMirror()\n<__main__.ObjectCreator object at 0x8997b4c>\n```\n\n### 动态地创建类\n\n因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。\n```\n>>> def choose_class(name):\n…       if name == 'foo':\n…           class Foo(object):\n…               pass\n…           return Foo     # 返回的是类，不是类的实例\n…       else:\n…           class Bar(object):\n…               pass\n…           return Bar\n…\n>>> MyClass = choose_class('foo')\n>>> print MyClass              # 函数返回的是类，不是类的实例\n<class '__main__'.Foo>\n>>> print MyClass()            # 你可以通过这个类创建类实例，也就是对象\n<__main__.Foo object at 0x89c6d4c>\n```\n但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样：\n```\n>>> print type(1)\n<type 'int'>\n>>> print type(\"1\")\n<type 'str'>\n>>> print type(ObjectCreator)\n<type 'type'>\n>>> print type(ObjectCreator())\n<class '__main__.ObjectCreator'>\n```\n这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）\n\ntype可以像这样工作：```type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)```,\n比如下面的代码：\n```\n>>> class MyShinyClass(object):\n…       pass\n```\n可以手动像这样创建：\n```\n>>> MyShinyClass = type('MyShinyClass', (), {})  # 返回一个类对象\n>>> print MyShinyClass\n<class '__main__.MyShinyClass'>\n>>> print MyShinyClass()  #  创建一个该类的实例\n<__main__.MyShinyClass object at 0x8997cec>\n```\n你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。\n\ntype 接受一个字典来为类定义属性，因此\n```\n>>> class Foo(object):\n…       bar = True\n```\n可以翻译为：\n```\n>>> Foo = type('Foo', (), {'bar':True})\n```\n并且可以将Foo当成一个普通的类一样使用：\n```\n>>> print Foo\n<class '__main__.Foo'>\n>>> print Foo.bar\nTrue\n>>> f = Foo()\n>>> print f\n<__main__.Foo object at 0x8a9b84c>\n>>> print f.bar\nTrue\n```\n\n当然，你可以向这个类继承，所以，如下的代码：\n```\n>>> class FooChild(Foo):\n…       pass\n```\n就可以写成：\n```\n>>> FooChild = type('FooChild', (Foo,),{})\n>>> print FooChild\n<class '__main__.FooChild'>\n>>> print FooChild.bar   # bar属性是由Foo继承而来\nTrue\n```\n最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。\n```\n>>> def echo_bar(self):\n…       print self.bar\n…\n>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n>>> hasattr(Foo, 'echo_bar')\nFalse\n>>> hasattr(FooChild, 'echo_bar')\nTrue\n>>> my_foo = FooChild()\n>>> my_foo.echo_bar()\nTrue\n```\n你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。\n\n### 到底什么是元类（终于到主题了）\n\n元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解 为：\n```\nMyClass = MetaClass()\nMyObject = MyClass()\n```\n你已经看到了type可以让你像这样做：\n```\nMyClass = type('MyClass', (), {})\n```\n这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。\n```\n>>> age = 35\n>>> age.__class__\n<type 'int'>\n>>> name = 'bob'\n>>> name.__class__\n<type 'str'>\n>>> def foo(): pass\n>>>foo.__class__\n<type 'function'>\n>>> class Bar(object): pass\n>>> b = Bar()\n>>> b.__class__\n<class '__main__.Bar'>\n```\n现在，对于任何一个__class__的__class__属性又是什么呢？\n```\n>>> a.__class__.__class__\n<type 'type'>\n>>> age.__class__.__class__\n<type 'type'>\n>>> foo.__class__.__class__\n<type 'type'>\n>>> b.__class__.__class__\n<type 'type'>\n```\n因此，元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”（不要和工厂类搞混了:D） type就是Python的内建元类，当然了，你也可以创建自己的元类。\n\n### \\__metaclass__属性\n\n你可以在写一个类的时候为其添加```__metaclass__```属性。\n```\nclass Foo(object):\n\t__metaclass__ = something…\n[…]\n```\n如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 :\n```\nclass Foo(Bar):\n    pass\n```\nPython做了如下的操作：\n\nFoo中有\\__metaclass\\__这个属性吗？如果是，Python会在内存中通过\\__metaclass\\__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到\\__metaclass\\__，它会继续在Bar（父类）中寻找\\__metaclass\\__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到\\__metaclass\\__，它就会在模块层次中去寻找\\__metaclass\\__，并尝试做同样的操作。如果还是找不到\\__metaclass\\__,Python就会用内置的type来创建这个类对象。\n\n现在的问题就是，你可以在\\__metaclass\\__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。\n\n### 自定义元类\n\n元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定\\__metaclass\\__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。\n\n幸运的是，\\__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，画画图理解下，这很有帮助）。所以，我们这里就先以一个简单的函数作为例子开始。\n```\n# 元类会自动将你通常传给‘type’的参数作为自己的参数传入\ndef upper_attr(future_class_name, future_class_parents, future_class_attr):\n    '''返回一个类对象，将属性都转为大写形式'''\n    #  选择所有不以'__'开头的属性\n    attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n\n    # 将它们转为大写形式\n    uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n    # 通过'type'来做类对象的创建\n    return type(future_class_name, future_class_parents, uppercase_attr)\n\n__metaclass__ = upper_attr  #  这会作用到这个模块中的所有类\n\nclass Foo(object):\n    # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中\n    bar = 'bip'\n\nprint hasattr(Foo, 'bar')\n# 输出: False\nprint hasattr(Foo, 'BAR')\n# 输出:True\n\nf = Foo()\nprint f.BAR\n# 输出:'bip'\n```\n现在让我们再做一次，这一次用一个真正的class来当做元类。\n```\n# 请记住，'type'实际上是一个类，就像'str'和'int'一样\n# 所以，你可以从type继承\nclass UpperAttrMetaClass(type):\n    # __new__ 是在__init__之前被调用的特殊方法\n    # __new__是用来创建对象并返回之的方法\n    # 而__init__只是用来将传入的参数初始化给对象\n    # 你很少用到__new__，除非你希望能够控制对象的创建\n    # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__\n    # 如果你希望的话，你也可以在__init__中做些事情\n    # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用\n    def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):\n        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n        return type(future_class_name, future_class_parents, uppercase_attr)\n```\n但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的__new__方法。现在让我们这样去处理:\n```\nclass UpperAttrMetaclass(type):\n    def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):\n        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n        # 复用type.__new__方法\n        # 这就是基本的OOP编程，没什么魔法\n        return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)\n```\n你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的：\n```\nclass UpperAttrMetaclass(type):\n    def __new__(cls, name, bases, dct):\n        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__')\n        uppercase_attr  = dict((name.upper(), value) for name, value in attrs)\n        return type.__new__(cls, name, bases, uppercase_attr)\n```\n如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）\n```\nclass UpperAttrMetaclass(type):\n    def __new__(cls, name, bases, dct):\n        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n        return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)\n```\n就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的：\n\n1. 拦截类的创建\n1. 修改类\n1. 返回修改之后的类\n\n\n\n为什么要用metaclass类而不是函数?\n\n由于__metaclass__可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？这里有好几个原因：\n\n1）  意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。\n\n2） 你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。\n\n3）  你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。\n\n4） 你可以使用\\__new\\__, \\__init\\__以及\\__call\\__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在\\__new\\__里处理掉，有些人还是觉得用\\__init\\__更舒服些。\n\n5） 哇哦，这东西的名字是metaclass，肯定非善类，我要小心！\n\n### 究竟为什么要使用元类？\n\n现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：\n\n> “元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。”\n—— Python界的领袖 Tim Peters\n\n元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义：\n```\nclass Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n```\n但是如果你像这样做的话：\n```\nguy  = Person(name='bob', age='35')\nprint guy.age\n```\n这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了\\__metaclass\\__， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。\n\n### 结语\n\n首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。\n```\n>>>class Foo(object): pass\n>>> id(Foo)\n142630324\n```\nPython中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：\n\n1. Monkey patching\n2. class decorators\n\n当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D\n",
"title": "转载：深刻理解Python中的元类(metaclass)",
"author": "bigship 翻译 @伯乐在线 （<a target=\"_blank\" href=\"http://blog.jobbole.com/21351/\">http://blog.jobbole.com/21351/</a>）",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "",
"first_figure": "/static/blog/img/preview_2.jpg"
},
"20150117": {
"create_time": "2015年1月17日",
"id": 20150117,
"content": "\n## MySQL的数据类型\n\n一、整数：\n\n```\n#类型\t\t\t\t字节数\nTINYINT\t\t\t1\nSMALLINT\t\t\t2\nMEDIUMINT\t\t\t3\nINT\t\t\t\t4\nBIGINT\t\t\t8\n```\n\n\n二、实数（带小数）：\n\n```\n#浮点数类型\t\t\t字节数\nFLOAT\t\t\t\t4\nDOUBLE\t\t\t\t8\n\n#定点数\nDEC,DECIMAL(M,D)\tM+2\t\t\t\n\n#decimal(20,2):小数点前18位，小数点后2位\n\n#位类型\t\t\t\t字节数\nBIT(M)\t\t\t\t1~8\n```\n\n三、字符串：\n\n```\nCHAR(M)\t\t\t\t#定长,M,M的范围0~255\nVARCHAR(M)\t\t\t\t#长度可变,0~65535,值的长度加1\n\n\nTEXT\t\t\t\t#字符字符集\n\tTINYTEXT\n\tTEXT\n\tMEDIUMTEXT\n\tLONGTEXT\n\nBLOB\t\t\t#二进制数据流\n\tTINYBLOB\n\tBLOB\n\tMEDIUMBLOB\n\tLONGBLOB\nBINARY(M)\t\t\t# 0~M个字节的定长字符串\n```\n\n四、日期：\n\n```\t\nDATE \t\t\t4B\n#只表示日期，1000-01-01 ~ 9999-12-31\n\nDATETIME \t\t8B\t\t\n#1000-01-01 00:00:00 ~9999-12-31 23:59:59 精确到秒\n\nTIMESTAMP\t\t4B\t\t\n#1970~2038，时间戳，格林威治标准时间以来经历的秒数\n\nTIME \t\t\t3B\n#-838:59:59 ~ 838:59:59\n\nYEAR\t\t\t1B\n#1901 ~ 2155\n```\n\n使用```now()```函数何以获得当前日期，例如插入一条当前时间的记录:\n\n```\nINSERT INTO tb_name(date,time,date_time) VALUES (now(),now(),now());\n```\n\n*选择原则\n\n1、最小原则\n2、简单原则\n3、避免索引列上的NULL",
"layout": "post",
"title": "MySQL(2):常用数据类型",
"category": "学习笔记",
"description": "MySQL的常用数据类型",
"tags": [
"MySQL"
],
"preview": "一、整数：\n\n```\n#类型\t\t\t\t字节数\nTINYINT\t\t\t1\nSMALLINT\t\t\t2\nMEDIUMINT\t\t\t3\nINT\t\t\t\t4\nBIGINT\t\t\t8\n```\n\n\n二、实数（带小数）：\n\n```\n#浮点数类型\t\t\t字节数\nFLOAT\t\t\t\t4\nDOUBLE\t\t\t\t8\n\n#定点数\nDEC,DECIMAL(M,D)\tM+2\t\t\t\n\n#decimal(20,2):小数点前18位，小数点后2位\n\n#位类型\t\t\t\t字节数\nBIT(M)\t\t\t\t1~8\n```\n\n三、字符串：\n\n```\nCHAR(M)\t\t\t\t#定长,M,M的范围0~255\nVARCHAR(M)\t\t\t\t#长度可变,0~65535,值的长度加1\n\n\nTEXT\t\t\t\t#字符字符集\n\tTINYTEXT\n\tTEXT\n\tMEDIUMTEXT\n\tLONGTEXT\n\nBLOB\t\t\t#二进制数据流\n\tTINYBLOB\n\tBLOB\n\tMEDIUMBLOB\n\tLONGBLOB\nBINARY(M)\t\t\t# 0~M个字节的定长字符串\n```\n\n四、日期：\n\n```\t\nDATE \t\t\t4B\n#只表示日期，1000-01-01 ~ 9999-12-31\n\nDATETIME \t\t8B\t\t\n#1000-01-01 00:00:00 ~9999-12-31 23:59:59 精确到秒\n\nTIMESTAMP\t\t4B\t\t\n#1970~2038，时间戳，格林威治标准时间以来经历的秒数\n\nTIME \t\t\t3B\n#-838:59:59 ~ 838:59:59\n\nYEAR\t\t\t1B\n#1901 ~ 2155\n```\n\n使用```now()```函数何以获得当前日期，例如插入一条当前时间的记录:\n\n```\nINSERT INTO tb_name(date,time,date_time) VALUES (now(),now(),now());\n```\n\n*选择原则\n\n1、最小原则\n2、简单原则\n3、避免索引列上的NULL",
"first_figure": "/static/blog/img/preview_1.jpg"
},
"20170306": {
"create_time": "2017年3月6日",
"id": 20170306,
"content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n### wsgiref.headers\n　　这个模块提供一个Headers的类，用于方便的使用一个mapping-like的接口来操作WSGI头的响应。\n\n* __class__ wsgiref.headers.__Headers(*headers*)__\n\n\t创建一个mapping-like的对象来装饰headers，这个对象必须是由PEP 333中定义的header的name/value元组构成的list。任何更改将直接更新新的Headers对象。\n\n\tHeaders对象支持典型的map操作有```__getitem()__```、```__get()__```、```__setitem()__```、```__setdefault()__```、```__delitem()__```、```__contains()__```、```__haskey()__```等。\n\n\t不管哪种操作，key都是header的name，value是name接下来的第一个值。设置一个header将会删除任何已存在的值，然后追加一个新的值到装饰header的list的末尾。\n\n\t与dict不同的是，即使你试图get或删除一个不存在的key，Headers对象也不会抛出异常，取不存在的key会返回一个None，删除不存在的key则是什么也不做。\n\n\tHeaders对象也同样支持```keys()```、```values()```和```items()```方法。如果有一键多值的Header，可以返回多个list并且keys和items可以包含同一个key多次。对一个Headers对象使用```len()```方法跟len它的items有相同的效果，返回的是装饰Headers的list的长度。```items()```方法指挥返回这个装饰Header的list的副本。\n\n\t对Headers对象使用```str()```方法将会得到一个格式化的字符串，来适配HTTP headers响应的传送。每个header都和它的值置于一行，以冒号和一个空格相隔。每行都终止于“\\r\\n”，并且这个字符串终止于一个空行。\n\n\t除上述之外，Headers对象还支持两种方法来查找和追加一键多值的header、给header添加MIME参数。\n\n\n* __get_all(*name*)__\n\n\t返回一个包含所有这个header中的name/value的list。\n\n\t返回的list的顺序是根据他们在原header中出现的先后、添加到实例的先后来决定的，而且可能会重复。任何的字段删除并重新插入，都将追加到header list的末尾。如果没有给定的name没有存在的字段，就返回一个空的list。\n\n\n* __add_header(*name, value, **params*)__\n\n\t添加一个header，并且可能是一键多值的header，可以通过params中特定的key给此方法传入MIME参数。\n\n\tname是要添加的字段，keyword参数可以给这个字段添加MIME参数。每个参数必须为字符串或者None。“_”将会被转化成“-”，因为“-”在Python中是不合法的标识符，但很多MIME参数都包含它。如果参数的值是一个字符串，就会被追加到header的值中，比如```name=\"value\"```。如果是None，就只有name会被添加，这种情况用在无值的MIME参数中。\n\n\t生产实例：\n\n\t\th.add_header('content-disposition', 'attachment', filename='bud.gif')\n\n\t将会回复：\n\n\t\tContent-Disposition: attachment; filename=\"bud.gif\"\n\n",
"layout": "post",
"title": "Web Server Gateway Interface (wsgiref.headers部分)",
"category": "学习笔记",
"tags": [
"编程",
"Python",
"WSGI"
],
"preview": "这个模块提供一个Headers的类，用于方便的使用一个mapping-like的接口来操作WSGI头的响应。\n\n* __class__ wsgiref.headers.__Headers(*headers*)__\n\n\t创建一个mapping-like的对象来装饰headers，这个对象必须是由PEP 333中定义的header的name/value元组构成的list。任何更改将直接更新新的Headers对象。\n\n\tHeaders对象支持典型的map操作有```__getitem()__```、```__get()__```、```__setitem()__```、```__setdefault()__```、```__delitem()__```、```__contains()__```、```__haskey()__```等。\n\n\t不管哪种操作，key都是header的name，value是name接下来的第一个值。设置一个header将会删除任何已存在的值，然后追加一个新的值到装饰header的list的末尾。\n\n\t与dict不同的是，即使你试图get或删除一个不存在的key，Headers对象也不会抛出异常，取不存在的key会返回一个None，删除不存在的key则是什么也不做。\n\n\tHeaders对象也同样支持```keys()```、```values()```和```items()```方法。如果有一键多值的Header，可以返回多个list并且keys和items可以包含同一个key多次。对一个Headers对象使用```len()```方法跟len它的items有相同的效果，返回的是装饰Headers的list的长度。```items()```方法指挥返回这个装饰Header的list的副本。\n\n\t对Headers对象使用```str()```方法将会得到一个格式化的字符串，来适配HTTP headers响应的传送。每个header都和它的值置于一行，以冒号和一个空格相隔。每行都终止于“\\r\\n”，并且这个字符串终止于一个空行。\n\n\t除上述之外，Headers对象还支持两种方法来查找和追加一键多值的header、给header添加MIME参数。\n\n\n* __get_all(*name*)__\n\n\t返回一个包含所有这个header中的name/value的list。\n\n\t返回的list的顺序是根据他们在原header中出现的先后、添加到实例的先后来决定的，而且可能会重复。任何的字段删除并重新插入，都将追加到header list的末尾。如果没有给定的name没有存在的字段，就返回一个空的list。\n\n\n* __add_header(*name, value, **params*)__\n\n\t添加一个header，并且可能是一键多值的header，可以通过params中特定的key给此方法传入MIME参数。\n\n\tname是要添加的字段，keyword参数可以给这个字段添加MIME参数。每个参数必须为字符串或者None。“_”将会被转化成“-”，因为“-”在Python中是不合法的标识符，但很多MIME参数都包含它。如果参数的值是一个字符串，就会被追加到header的值中，比如```name=\"value\"```。如果是None，就只有name会被添加，这种情况用在无值的MIME参数中。\n\n\t生产实例：\n\n\t\th.add_header('content-disposition', 'attachment', filename='bud.gif')\n\n\t将会回复：\n\n\t\tContent-Disposition: attachment; filename=\"bud.gif\"\n\n",
"first_figure": "/static/blog/img/project/20160811/0.jpg"
},
"20170525": {
"create_time": "2017年5月25日",
"id": 20170525,
"content": "\n\n## 迭代器\n\n所有生成器都是迭代器，因为生成器完全实现了迭代器接口。不过通常来讲，迭代器用于从集合中取出元素，而生成器用于“凭空”生成元素。在 Python 中，所有集合都是可以迭代对象。\n\n<!--more-->\n\n当需要迭代对象 x 时，会自动调用 iter(x)。内置的iter函数会检查x对象是否实现了 ```__iter__``` 方法，如果实现了就调用它。如果没有实现 ```__iter__``` 方法，但是实现了 ```__getitem__``` 方法，Python 会创建一个迭代\n器，尝试从索引 0 开始顺序获取元素。如果连```__getitem__```方法也没有实现，那么Python会抛出一个异常，提示对象不可迭代。\n\nPython序列都可迭代，因为它们至少都实现了 ```__getitem__```方法。但严格的讲，实现了```__iter__```方法的对象才能算可迭代的，Python标准的序列也都实现了```__iter__```方法。对于只实现了```__getitem__```方法而未实现```__iter__```方法的对象，无法通过```issubclass (Sentence, collocations.abc.Iterable) ```测试。\n\n## 标准的迭代器接口\n\n* ```__next__```: 返回下一个可用的元素，如果没有元素了，抛出 StopIteration 异常。\n* ```__iter__```: 返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如在 for 循环中。\n\n这个接口在 collections.abc.Iterator 抽象基类中制定。Iterator定义了``` __next__```抽象方法，在Python3中是``` it.__next__()```的封装，而在 Python 2 中是 ```it.next()```。Iterator继承自 Iterable 类，后者定义了```__iter__```抽象方法。\n\n使用iter(x)创建一个x的迭代器，并调用next(x)来获取下一个元素。当x中所有的元素都已经迭代完成，则抛出StopIteration异常。\n\n## 迭代器与可迭代对象\n\n构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。要知道，可迭代的对象有个 ```__iter__ ```方法，每次都实例化一个新的迭代器；而迭代器要实现 ```__next__``` 方法， 返回单个元素，此外还要实现 ```__iter__``` 方法，返回迭代器本身。因此，迭代器可以迭代，但是可迭代的对象不是迭代器。\n\n在《Fluent Python》中有一个很好的例子来说明二者的不同：\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile('\\w+')\n\nclass Sentence:\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(text)\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)\n\n    def __iter__(self): \n        return SentenceIterator(self.words) \n\nclass SentenceIterator:\n    def __init__(self, words): \n        self.words = words\n        self.index = 0\n\n    def __next__(self):\n        try:\n            word = self.words[self.index]\n        except IndexError:\n            raise StopIteration()\n        self.index += 1\n        return word\n\n    def __iter__(self):\n        return self\n```\n\n以上代码使用Sentence类构造一个可迭代对象，使用SentenceIterator类创建迭代Sentence对象的迭代器。\n如果在 Sentence 类中实现 ```__next__``` 方法，就可以让 Sentence 实例既是可迭代的对象，也是自身的迭代器，但不建议这么做。因为它违反了以下原则：\n1. 访问一个聚合对象的内容而无需暴露它的内部表示\n2. 为了“支持多种遍历”，必须能从同一个可迭代的实例中获取多个独立的迭代器，而且各个迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，每次调用 iter(my_ iterable) 都新建一个独立的迭代器。这就是为什么之前需要定义 SentenceIterator 类\n3. 为遍历不同的聚合结构提供一个统一的接口(即支持多态迭代)\n\n__可迭代的对象一定不能是自身的迭代器，也就是说，可迭代的对象必须实现__```__iter__```__方法，但不能实现__```__next__```__方法；迭代器应该一直可以迭代，即迭代器的__```__iter__```__方法应该返回自身。__\n\n但实现Sentence类的迭代器就要新创建一个类，工作量变得很大，也不利于维护。所以引入了生成器函数：yield。可以这样简化Sentence类中的```__iter__```函数。\n```\ndef __iter__(self):\n    for word in self.words:\n        yield word\n```\n\n只要函数体中包含yield关键字，这个函数就是生成器函数。执行生成器函数会返回一个生成器对象，而生成器同时也是迭代器，会生成传给 yield 关键字的表达式的值，并保存内部状态并返回该值，直到下一次迭代时返回yield 生成的下一个元素。生成器函数的定义体执行完毕后，生成器对象会抛出 StopIteration 异常。\n\n",
"title": "Python迭代器",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "所有生成器都是迭代器，因为生成器完全实现了迭代器接口。不过通常来讲，迭代器用于从集合中取出元素，而生成器用于“凭空”生成元素。在 Python 中，所有集合都是可以迭代对象。\n\n",
"first_figure": "/static/blog/img/preview_5.jpg"
},
"20151120": {
"create_time": "2015年11月20日",
"id": 20151120,
"content": "\n![maibaozhi](/static/blog/img/blog/20151120/2015112001.jpg)\n\n　　今天傍晚我走在校园里，一个小朋友突然把我拦住，我先是以为小朋友可能要问个路什么的，但他却有些怯懦的说，“叔叔，买份报纸吧……”我看到他手里拿着一摞报纸，明白了这可能是他们学校组织的一次让学生卖报纸的课外实践活动。我其实并不想买他的报纸，犹豫了一下，看着可爱的小朋友我有些不好意思的说，“对不起小朋友，这个我暂时不太需要。”然后小朋友失望的走开了。\n\n　　接着我继续走，又被另外一个小朋友拦下来，重复发生了上述的事情，我还是回绝了。接着又重复被好几个小朋友拦下被恳求买报纸，如你所猜想的那样，我一口气拒绝了好几个小朋友。原则上我的拒绝没有任何不妥，但每次拒绝他们，看到他们表情失落地走开的时候，我也感觉有些难过。接着引起了我的思考，学校组织这种活动，有些什么意义呢？\n<!--more-->\n　　我想到刚上大学那年，被表妹说服去她的大学卖被子那段难忘的经历。理由很简单，“锻炼交际能力”，“学习为人处世”。\n\n　　但是卖被子谈何容易。我背着一大卷被子一踏进学生宿舍，六双眼睛齐刷刷的投来诧异的目光，我见这阵势突然紧张的不知道如何说话。当时的场面就像相亲时初次见面的男女，你看看我、我看看你，尴尬无比。所以第一次完美失败了。随后我慢慢大胆起来，一间宿舍一间宿舍的挨个走访，问他们“请问有人需要被子吗？”，没人说话，继续另一间……折腾了一上午，但依然没有一床被子卖出。我的心情失望到了极点，可以说那个上午让我体会到了此生都从未有过的挫败感，甚至是落败感。\n\n　　我的表妹虽然年纪比我小，但却比我成熟得多。那天我们都在卖被子，中午在约定好的地点见面时，她的已经全都卖完了。我开始向她吐苦水，后悔听她的蛊惑，想想也是，堂堂大男人卖什么被子，也是够憋屈的。她却开心得笑起来，最后告诉我一个秘诀。\n\n　　我按照她的办法，我去了另一栋宿舍楼，一个下午全都卖光了，第二天还附带卖了些插销板。但是，这是怎么做到的呢？其实是这样的，买被子的成本是50块，我要100块卖掉，为了达到这个目的，我要克服心理障碍先跟学生宿舍的同学唠嗑聊天，冒充他们的学长跟他们讲大学的趣事、生活的琐事，在他们不排斥我的情况下，告诉他们“我的故事”：“我有个女朋友，她老爱勤工俭学，前几天她又进了一大批被子卖。你说她一个女生做这种事，真的非常辛苦，但我劝她她也不听，我看她真的不容易，就只好跟她一块卖了。但是你看，跑了一上午一床都没卖掉……”\n\n　　这个时候我已经获得了大部分人的同情，但杀手锏还在后面：“我实在没辙了，这些被子本来是120块进的，女朋友要150块卖掉，你也知道，这破被子150卖我我都不要……但我又不能告诉她，不然她很伤心。你们如果谁想要的话，我亏本100块卖了，女朋友那边每床被子我自己掏钱凑150给她，不能让她知道了……” 晓之以理、动之以情，并且让大家看到这哥们做好事不留名，这才是无私的爱情啊，就是铁石心肠也软化了，所以一下午卖光所有被子也不为怪了。当然，所讲的故事都是虚构的。\n\n　　这能说明什么呢？首先就是表面上简单的卖东西这一行为，其实学问很深。你也许会觉得我的营销方式含有欺骗的成分而感到厌恶，但从某种意义上讲，这种“欺骗”其实给他们提供了另一种虚拟商品，就是一个唯美的故事。大家可能因为我是个好人、负责任而买我的被子；也许是因为我的爱情故事而感动才买这床被子；又或许是因为这床被子有特殊的意义而买了下来，因为买下它帮助了两个努力奋斗的年轻人。但说到底，还是利用了人们的同情心，就像今天小朋友卖报纸一样，我们有手机、Pad各种获取信息的工具，为什么还要看这些过期的报纸呢？小孩不会讲故事，买这些报纸的人真正的原因，也只有一个：因为这个小孩真的很可爱，不忍心让他们的自信心受挫。\n\n　　那让这些小孩卖报纸值得肯定吗？我觉得，小孩在这些活动中受挫是必然的。绝大多数的小孩全程没有卖出一份报纸，而且我也看到有个成年人跟孩子的家长闹起来，大概是不满这个过程中的道德绑架，他说了一些伤人的话甚至是脏话，这无疑对在旁的小孩的内心造成了深深的伤害。我敢肯定有N多人吐槽这次活动，因为首先，孩子不是独立出来卖报纸，这个过程中还是家长的陪同下完成的，那么孩子在独立性、交际能力方面究竟得到了多少锻炼尤为可知；其次，这次实践卖的报纸并没有实际意义，单不论报纸是不是已经被时代淘汰的东西，也许卖一些《读者》、《意林》之类的刊物会更受欢迎；再其次，经历过大学的团日活动的我们都或多或少有些担忧，因为我们害怕小朋友单纯的实践活动沦为某学校领导的讲话精神的材料，害怕这种政治目的的、赤裸裸的“走过场”的陋习污染了他们幼小的心灵，让他们在这种活动中学会了如何去应付，从而在以后的实践中失去积极性。\n\n　　但是，我却要竖起大拇指，真真儿的点个赞。持反对观点的人大多应该只看到了这个过程中暴露给小孩的腌臜的东西、体制化的东西，就如我自己在大学卖被子的经历，它让我体会到的其实更多的是生活中的假恶丑，让我明白生活的艰难，人心的丑恶，我曾被那些同学当做下人一样被赶出宿舍，我不得不接受“想更快成功最好的办法是编故事”这种厚黑学理论，等等。但那次经历仍然使我受益匪浅。在我看来，只要人能走出校园，不管他经历过什么都是一笔对成长有益的财富。我们的世界本就不完美，认识这些不完美也同样是成长路上必须经历的事情。也许现在回复给那些小孩的东西远远超出了他们认知的范围和承受的底线，但受伤总是难免的，我们不能逃避必须去面对的挫折。也许他们理解了为什么那位成年人不买账，为什么爆粗口，明白原来不能肆无忌惮的依托人们的同情心来卖东西，有一点点努力学习的觉悟，那就值了。\n\n　　最后，点赞并不代表我全盘认可这次活动的全部理念和细节。除了上述的几点理由，还有更重要的一点，也是最重要的，就是如何教会小孩面对失败。我只是言辞上稍微拒绝，但那些孩子都不一而同的放弃了，然后连一句“没关系”之类的客套话也不说就失望的走开了，不加反思又去寻找下一个“买家”。如果他们谁能够再恳切一些，再央求我一次，或者直接说“如果这次任务没完成会很丢人”之类的话，我也就买下了，我只需要一个理由，只要足够真切。但没有一个人是这样，只是因为老师怎么教、他们就怎么做，所以那么多小朋友开场的话都是一样，没有自己的思考，哪怕是一丁点。如何面对失败，这也许同样是我们大人要去学习、也是真正要身体力行的事情吧。\n",
"layout": "post",
"title": "卖报纸的小盆友",
"category": "观点",
"tags": [
"生活"
],
"preview": "\n![maibaozhi](/static/blog/img/blog/20151120/2015112001.jpg)\n\n　　今天傍晚我走在校园里，一个小朋友突然把我拦住，我先是以为小朋友可能要问个路什么的，但他却有些怯懦的说，“叔叔，买份报纸吧……”我看到他手里拿着一摞报纸，明白了这可能是他们学校组织的一次让学生卖报纸的课外实践活动。我其实并不想买他的报纸，犹豫了一下，看着可爱的小朋友我有些不好意思的说，“对不起小朋友，这个我暂时不太需要。”然后小朋友失望的走开了。\n\n　　接着我继续走，又被另外一个小朋友拦下来，重复发生了上述的事情，我还是回绝了。接着又重复被好几个小朋友拦下被恳求买报纸，如你所猜想的那样，我一口气拒绝了好几个小朋友。原则上我的拒绝没有任何不妥，但每次拒绝他们，看到他们表情失落地走开的时候，我也感觉有些难过。接着引起了我的思考，学校组织这种活动，有些什么意义呢？\n",
"first_figure": "/static/blog/img/preview_0.jpg"
},
"20150927": {
"create_time": "2015年9月27日",
"id": 20150927,
"content": "\n![遥远的路](/static/blog/img/blog/20150927/2015092701.jpg)\n\n　　早上爸爸送妹妹去上课，我正好去超市买东西，大家一起走，回家的路上，碰上以前同学在等公交，爸爸说要捎上她，我拒绝了。爸爸有点不高兴的说“都认识人，捎一段给她送家去，她自己从公交站走到家得走挺老远的呢！”我就跟爸爸说了我们小时候的一件事，我们一起上学的时候，有一次连着下雨好多天，我几双鞋都湿了，怎么都晾不干，我妈找出一双旧鞋让我穿。<!--more-->这位同学看到之后说：“这鞋是你捡的吧？我前天刚扔垃圾桶的！”我说这鞋我的。她坚持说，她前天扔垃圾桶的，就是这双！无论我怎么解释，她就说这是她扔的，还找来跟她不错的同学作证！说我这鞋是捡她的，连着好多天，不停的说我从垃圾桶捡了她的鞋。把我烦的不行，回家我让我妈把我的鞋烤干了，把那双旧鞋给了她。我以为这事完了，没想到她就自以为她说的是对的，到处跟人说我捡她旧鞋。一连说了好几年。从那儿以后只要看见她，我就想起这事，我爸一说要捎着她，我果断就拒绝了。\n\n　　无独有偶，我高中同学里有个类似的事，同学A没事就欺负同学B，比如冬天半夜趁着同学B上厕所，把宿舍门锁上，同学B在门口敲门不让其他人开，同学B只好去找宿管老师，可还是冻两小时发烧了。再比如大家一起去洗澡，他把同学B的衣服带走，让同学B找不到衣服。再比如挑拨别的同学打同学B，等等损人不利己的事。大家毕业以后，各奔东西，巧的是，同学B开了公司，当了老板，同学A去他公司面试，同学B找借口没有收同学A。同学A在我们的同学群里谴责同学B，不讲同学情谊，一点也没有人情味。\n\n　　最近陪爸妈看电视，有个大叔家里拆迁，他回家要分家产，父母和兄弟姐妹都不同意，大叔很可怜，家里只有个两居室，儿子要结婚了，可是没房子，老两口的退休金根本不够给孩子买房子，想趁着这次拆迁要点钱，给儿子买房子，可是家里都不给。本来挺可怜这大叔的，可是等大叔父母和兄弟姐妹诉说之后，有了戏剧性的转折。大叔父母拿出了一个协议，大叔二十多年前结婚的时候跟父母商定，父母给一万块钱，他离家结婚，对父母生的时候不养，死了不用葬。大叔拿了钱，真的履行了协议，除了春节带着孩子回家看看父母以外，父母生病、盖房、搬家等等从来没管过。律师看了协议之后说协议无效，大叔很高兴，说是不是可以分家里拆迁的钱和房子。律师说家里财产是父母的，爱给谁给谁。协议无效，子女对父母有赡养义务，你必须赡养父母。\n\n　　很多遇到困难的人总说自己很可怜，总说别人不对，遇到不顺的事就抱怨。我就是这样，每次我跟我妈抱怨，我妈就告诉我“脚上的泡都是自己走的”。我很喜欢《生命的寻路人》里的一句话“每件事都不止是表面呈现的样貌。看得见的世界只是知觉的一种层次。”一方面是说我们不要对别人的故事妄下结论，事情可能不像我们看到的一样。另外一方面是指我们面对困难的时候，要多想自己是不是有什么不对。人生路上，有些绊脚的石头，是我们自己放的。",
"layout": "post",
"title": "转载：脚上的泡都是自己走的",
"author": "鼹鼠的土豆 <a target=\"_blank\" href=\"http://www.douban.com/note/438207501/\">http://www.douban.com/note/438207501/</a>",
"category": "观点",
"description": "脚上的泡都是自己走的",
"preview": "\n![遥远的路](/static/blog/img/blog/20150927/2015092701.jpg)\n\n　　早上爸爸送妹妹去上课，我正好去超市买东西，大家一起走，回家的路上，碰上以前同学在等公交，爸爸说要捎上她，我拒绝了。爸爸有点不高兴的说“都认识人，捎一段给她送家去，她自己从公交站走到家得走挺老远的呢！”我就跟爸爸说了我们小时候的一件事，我们一起上学的时候，有一次连着下雨好多天，我几双鞋都湿了，怎么都晾不干，我妈找出一双旧鞋让我穿。",
"first_figure": "/static/blog/img/preview_1.jpg"
},
"20170308": {
"create_time": "2017年3月8日",
"id": 20170308,
"content": "<img src=\"/static/blog/img/project/20160811/0.jpg\" alt=\"django\" style=\"width:100%;\"/>\n\n### wsgiref.handlers\n　　这个模块是WSGI服务器和网关的实现。只要给予一个类CGI的环境，以及输入、输出和错误流，就可以用WSGI应用程序处理绝大部分的网络连接。\n\n* __class__ wsgiref.handlers.__CGIHandler__\n\n\t使用sys.stdin、sys.stdout和sys.stderr流的基于CGI的调用。可以用在你想以一个CGI脚本来运行你写的WSGI应用程序时。它会直接调用```CGIHandler().run(app)```，这里的app就是你想调用的对象。\n\n\t这个class是把wsgi.run_once设置为True、把wsgi.multithread设置为False，而且总是使用sys和os来获取必要的CGI流和环境变量的BaseCGIHandler的派生类。\n\n* __class__ wsgiref.handlers.__BaseCGIHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t与CGIHandler类似，但不使用sys和os，而是显式的指定CGI环境和IO流。*multithread*和*multiprocess*的值是用来给任何通过此实例来运行的应用程序设置*wsgi.multithread*和*wsgi.multiprocess*标志位的。\n\n\t这个类是一个随非HTTP \"origin servers\"软件而使用的SimpleHandler的派生类。如果你想写一个网关接口的实现，比如CGI、FastCGI、SCGI等，使用```Status: ```头来发送一个HTTP的状态码，那您肯定很想用这个实例而不是SimpleHandler的实例。\n\n* __class__ wsgiref.handlers.__SimpleHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t和上述BaseCGIHandler类似，但为了HTTP origin servers来设计的。如果你正在写一个HTTP服务器的实现，那使用这个类的实例就比BaseCGIHandler要好得多。\n\n\t这个类基于BaseHandler，但覆写了__init__()、get_stdin()、get_stderr()、add_cgi_vars()、_write()和_flush()方法来支持通过这个构造器来显式设置环境和流。支持的环境和流被存储在stdin、stdout、stderr和environ属性里。\n\n* __class__ wsgiref.handlers.__BaseHandler__\n\n\t这是一个用来运行WSGI应用程序的抽象类，虽然原则上你可以派生出一个类来复用，使得他能接收多个请求，但每个实例都应该只处理一个HTTP请求。\n\n __BaseHandler__只有一个用于外部调用的方法：\n\t- run(*app*)\n\n\t运行指定的WSGI应用程序，如*app*。\n\n 所有其他的方法都只被这个方法调用，用来辅助这个app的运行。这样从根本上可以定制处理过程。\n\n\t- _write(*data*)\n\n\t给字符串*data*做缓冲用来传送到client。如果这个方法发送了data，是OK的，BaseHandler只是区分了写和刷新的操作用于给特定的系统提升效率。\n\n\t- _flush()\n\n\t强制把缓冲区中的数据发送到client。\n\n\t- get_stdin()/get_stderr()\n\n\t返回WSGI请求正在处理之时对应的流。\n\n\t- get_stdvars()\n\n\t插入当前的请求中的CGI变量到environ的属性中。\n\n 另外，有一些方法和属性你肯定想重写它。这里仅列举出一部分，而且在打算基于BaseHandler来定制自己的类之前， 应该翻阅更官方的文档和源码来获得更确切的信息。\n\n\t用来定制WSGI环境的属性和方法如下：\n\n\t- wsgi_multithread\n\n\t用于wsgi.multithread的环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_multiprocess\n\n\t用于wsgi.multiprocess环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_run_once\n\n\t用于wsgi.run_once环境变量.在BaseHandler中默认为False，但CGIHandler中默认为True。\n\n\t- os_environ\n\n\t是每一个请求的WSGI环境中的默认环境变量。默认情况下它是当wsgiref.handlers被import的时候os.environ的拷贝，但派生类也可以在class或者实例层单独创建它们。需要注意的是，这个dict应该被设计成只读的，因为这个默认值是被多个类和实例共享的。\n\n\t- server_software\n\n\t如果设置origin_server属性，它的值将用于设置默认的SERVER_SOFTWARE WSGI环境变量，也会在HTTP响应中设置默认的```Server:```头. 他被非 HTTP origin servers忽略，比如BaseCGIHandler和CGIHandler。\n\n\t- get_scheme()\n\n\t用来返回当前请求的URL方案。默认的实现是使用guess_scheme()方法从wsgiref.util中判定当前的方案是“http”还是“https”，它是基于当前请求的environ变量的。\n\n\t- setup_environ()\n\n\t设置*environ*属性为fully-populated的WSGI环境。默认的实现是使用上述所有的方法加上get_stdin()、get_stderr()、和add_cgi_vars()方法，以及wsgi_file_wrapper属性。如果不存在SERVER_SOFTWARE的key，并且origin_server属性设置为真而且server_software是有值的，它也会插入这个key。\n\n 用来定制处理过程的方法和属性如下：\n\n\t- log_exception(*exc_info*)\n\n\t给*exc_info*元组加上log。*exc_info*是(type, value, traceback) 元组，默认的实现是单纯的写入到wsgi.errors流中，然后flush。派生类可以重写这个方法来改变格式或者重定向输出、发送信息给管理员等等。\n\n\t- traceback_limit\n\n\t定义log_exception()中包含tracebacks输出信息的最大的帧的大小。如果为None，就会包含所有的帧。\n\n\t- error_output(*environ, start_response*)\n\n\t这个方法时一个WSGI应用程序来给用户产生一个error页面。它仅在发送Header之前发生错误时调用。\n\n\t这个方法可以使用sys.exc_info()来进入当前错误信息。并且在被调用时，应当pass这条信息到start_response，在PEP 333中的“Error Handling”章节定义。\n\n\t默认的实现就是使用```error_status```、```error_headers```和```error_body```属性来产生输出的页面。派生类可以重写它来产生更多动态的信息。\n\n\t需要注意的是，从安全的角度来输出诊断信息是不推荐的，要做一些额外的工作来启用诊断输出。这就是为什么默认的实现没有包含任何东西的原因。\n\n\t- error_status\n\n\t用来做HTTP错误回复的状态码。这里应该是PEP 333中定义的一个字符串。默认是一个500的错误码和信息。\n\n\t- error_headers\n\n\t用于错误回复的HTTP headers。它应当是PEP 333中定义的WSGI响应头元组的list，比如[(name, value)]。默认的就是设置“content type”为“text/plain”。\n\n\t- error_body\n\n\t错误回复的body。应该是HTTP响应的body字符串，默认的是纯文本“A server error occurred. Please contact the administrator.”。\n\n PEP 333中定义的“Optional Platform-Specific File Handling”特性相关的方法和属性：\n\n\t- wsgi_file_wrapper\n\n\t为wsgi.file_wrapper的factory，或者为None。默认的值是wsgiref.util中的__FileWrapper__的属性。\n\n\t- sendfile()\n\n\t重写以实现平台特异的文件传输。这个方法只会在应用程序返回的值为wsgi_file_wrapper属性指定的类的实例时被调用。如果成功传送了一个文件它应该返回一个Ture，这样默认的传送代码就不会执行。默认的实现就是返回一个False。\n\n 其他的方法和属性:\n\n\t- origin_server\n\n\t当handler的_write()和_flush()被用来与客户端直接连接，而不是通过类CGI的希望在特殊的```Status:```头中到HTTP状态码网关接口时，这个属性应该被设置为True。\n\n\t在BaseHandler中，这个属性的默认值为True，在BaseCGIHandler和CGIHandler中为假。\n\n\t- http_version\n\n\t如果origin_server为真，这个字符串属性被用来给client设置HTTP版本。默认的是”1.0“。\n\n### 示例用法：\n\n　　一个“Hello World”的WSGI应用程序：\n\n\n```\nfrom wsgiref.simple_server import make_server\n\n# Every WSGI application must have an application object - a callable\n# object that accepts two arguments. For that purpose, we're going to\n# use a function (note that you're not limited to a function, you can\n# use a class for example). The first argument passed to the function\n# is a dictionary containing CGI-style environment variables and the\n# second variable is the callable object (see PEP 333).\ndef hello_world_app(environ, start_response):\n    status = '200 OK'  # HTTP Status\n    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n    start_response(status, headers)\n\n    # The returned object is going to be printed\n    return [\"Hello World\"]\n\nhttpd = make_server('', 8000, hello_world_app)\nprint \"Serving on port 8000...\"\n\n# Serve until process is killed\nhttpd.serve_forever()\n```\n",
"layout": "post",
"title": "Web Server Gateway Interface (wsgiref.handlers部分)",
"category": "学习笔记",
"tags": [
"编程",
"Python",
"WSGI"
],
"preview": "这个模块是WSGI服务器和网关的实现。只要给予一个类CGI的环境，以及输入、输出和错误流，就可以用WSGI应用程序处理绝大部分的网络连接。\n\n* __class__ wsgiref.handlers.__CGIHandler__\n\n\t使用sys.stdin、sys.stdout和sys.stderr流的基于CGI的调用。可以用在你想以一个CGI脚本来运行你写的WSGI应用程序时。它会直接调用```CGIHandler().run(app)```，这里的app就是你想调用的对象。\n\n\t这个class是把wsgi.run_once设置为True、把wsgi.multithread设置为False，而且总是使用sys和os来获取必要的CGI流和环境变量的BaseCGIHandler的派生类。\n\n* __class__ wsgiref.handlers.__BaseCGIHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t与CGIHandler类似，但不使用sys和os，而是显式的指定CGI环境和IO流。*multithread*和*multiprocess*的值是用来给任何通过此实例来运行的应用程序设置*wsgi.multithread*和*wsgi.multiprocess*标志位的。\n\n\t这个类是一个随非HTTP \"origin servers\"软件而使用的SimpleHandler的派生类。如果你想写一个网关接口的实现，比如CGI、FastCGI、SCGI等，使用```Status: ```头来发送一个HTTP的状态码，那您肯定很想用这个实例而不是SimpleHandler的实例。\n\n* __class__ wsgiref.handlers.__SimpleHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)__\n\n\t和上述BaseCGIHandler类似，但为了HTTP origin servers来设计的。如果你正在写一个HTTP服务器的实现，那使用这个类的实例就比BaseCGIHandler要好得多。\n\n\t这个类基于BaseHandler，但覆写了__init__()、get_stdin()、get_stderr()、add_cgi_vars()、_write()和_flush()方法来支持通过这个构造器来显式设置环境和流。支持的环境和流被存储在stdin、stdout、stderr和environ属性里。\n\n* __class__ wsgiref.handlers.__BaseHandler__\n\n\t这是一个用来运行WSGI应用程序的抽象类，虽然原则上你可以派生出一个类来复用，使得他能接收多个请求，但每个实例都应该只处理一个HTTP请求。\n\n __BaseHandler__只有一个用于外部调用的方法：\n\t- run(*app*)\n\n\t运行指定的WSGI应用程序，如*app*。\n\n 所有其他的方法都只被这个方法调用，用来辅助这个app的运行。这样从根本上可以定制处理过程。\n\n\t- _write(*data*)\n\n\t给字符串*data*做缓冲用来传送到client。如果这个方法发送了data，是OK的，BaseHandler只是区分了写和刷新的操作用于给特定的系统提升效率。\n\n\t- _flush()\n\n\t强制把缓冲区中的数据发送到client。\n\n\t- get_stdin()/get_stderr()\n\n\t返回WSGI请求正在处理之时对应的流。\n\n\t- get_stdvars()\n\n\t插入当前的请求中的CGI变量到environ的属性中。\n\n 另外，有一些方法和属性你肯定想重写它。这里仅列举出一部分，而且在打算基于BaseHandler来定制自己的类之前， 应该翻阅更官方的文档和源码来获得更确切的信息。\n\n\t用来定制WSGI环境的属性和方法如下：\n\n\t- wsgi_multithread\n\n\t用于wsgi.multithread的环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_multiprocess\n\n\t用于wsgi.multiprocess环境变量。在BaseHandler中默认为真，但亦可能为不同的默认值，因为有可能被别的派生类的构造器设置成了别的值。\n\n\t- wsgi_run_once\n\n\t用于wsgi.run_once环境变量.在BaseHandler中默认为False，但CGIHandler中默认为True。\n\n\t- os_environ\n\n\t是每一个请求的WSGI环境中的默认环境变量。默认情况下它是当wsgiref.handlers被import的时候os.environ的拷贝，但派生类也可以在class或者实例层单独创建它们。需要注意的是，这个dict应该被设计成只读的，因为这个默认值是被多个类和实例共享的。\n\n\t- server_software\n\n\t如果设置origin_server属性，它的值将用于设置默认的SERVER_SOFTWARE WSGI环境变量，也会在HTTP响应中设置默认的```Server:```头. 他被非 HTTP origin servers忽略，比如BaseCGIHandler和CGIHandler。\n\n\t- get_scheme()\n\n\t用来返回当前请求的URL方案。默认的实现是使用guess_scheme()方法从wsgiref.util中判定当前的方案是“http”还是“https”，它是基于当前请求的environ变量的。\n\n\t- setup_environ()\n\n\t设置*environ*属性为fully-populated的WSGI环境。默认的实现是使用上述所有的方法加上get_stdin()、get_stderr()、和add_cgi_vars()方法，以及wsgi_file_wrapper属性。如果不存在SERVER_SOFTWARE的key，并且origin_server属性设置为真而且server_software是有值的，它也会插入这个key。\n\n 用来定制处理过程的方法和属性如下：\n\n\t- log_exception(*exc_info*)\n\n\t给*exc_info*元组加上log。*exc_info*是(type, value, traceback) 元组，默认的实现是单纯的写入到wsgi.errors流中，然后flush。派生类可以重写这个方法来改变格式或者重定向输出、发送信息给管理员等等。\n\n\t- traceback_limit\n\n\t定义log_exception()中包含tracebacks输出信息的最大的帧的大小。如果为None，就会包含所有的帧。\n\n\t- error_output(*environ, start_response*)\n\n\t这个方法时一个WSGI应用程序来给用户产生一个error页面。它仅在发送Header之前发生错误时调用。\n\n\t这个方法可以使用sys.exc_info()来进入当前错误信息。并且在被调用时，应当pass这条信息到start_response，在PEP 333中的“Error Handling”章节定义。\n\n\t默认的实现就是使用```error_status```、```error_headers```和```error_body```属性来产生输出的页面。派生类可以重写它来产生更多动态的信息。\n\n\t需要注意的是，从安全的角度来输出诊断信息是不推荐的，要做一些额外的工作来启用诊断输出。这就是为什么默认的实现没有包含任何东西的原因。\n\n\t- error_status\n\n\t用来做HTTP错误回复的状态码。这里应该是PEP 333中定义的一个字符串。默认是一个500的错误码和信息。\n\n\t- error_headers\n\n\t用于错误回复的HTTP headers。它应当是PEP 333中定义的WSGI响应头元组的list，比如[(name, value)]。默认的就是设置“content type”为“text/plain”。\n\n\t- error_body\n\n\t错误回复的body。应该是HTTP响应的body字符串，默认的是纯文本“A server error occurred. Please contact the administrator.”。\n\n PEP 333中定义的“Optional Platform-Specific File Handling”特性相关的方法和属性：\n\n\t- wsgi_file_wrapper\n\n\t为wsgi.file_wrapper的factory，或者为None。默认的值是wsgiref.util中的__FileWrapper__的属性。\n\n\t- sendfile()\n\n\t重写以实现平台特异的文件传输。这个方法只会在应用程序返回的值为wsgi_file_wrapper属性指定的类的实例时被调用。如果成功传送了一个文件它应该返回一个Ture，这样默认的传送代码就不会执行。默认的实现就是返回一个False。\n\n 其他的方法和属性:\n\n\t- origin_server\n\n\t当handler的_write()和_flush()被用来与客户端直接连接，而不是通过类CGI的希望在特殊的```Status:```头中到HTTP状态码网关接口时，这个属性应该被设置为True。\n\n\t在BaseHandler中，这个属性的默认值为True，在BaseCGIHandler和CGIHandler中为假。\n\n\t- http_version\n\n\t如果origin_server为真，这个字符串属性被用来给client设置HTTP版本。默认的是”1.0“。\n\n### 示例用法：\n\n　　一个“Hello World”的WSGI应用程序：\n\n\n```\nfrom wsgiref.simple_server import make_server\n\n# Every WSGI application must have an application object - a callable\n# object that accepts two arguments. For that purpose, we're going to\n# use a function (note that you're not limited to a function, you can\n# use a class for example). The first argument passed to the function\n# is a dictionary containing CGI-style environment variables and the\n# second variable is the callable object (see PEP 333).\ndef hello_world_app(environ, start_response):\n    status = '200 OK'  # HTTP Status\n    headers = [('Content-type', 'text/plain')]  # HTTP Headers\n    start_response(status, headers)\n\n    # The returned object is going to be printed\n    return [\"Hello World\"]\n\nhttpd = make_server('', 8000, hello_world_app)\nprint \"Serving on port 8000...\"\n\n# Serve until process is killed\nhttpd.serve_forever()\n```\n",
"first_figure": "/static/blog/img/project/20160811/0.jpg"
},
"20180408": {
"create_time": "2018年4月8日",
"id": 20180408,
"content": "<!--more-->\n\n#### 尽量使用就地操作。\n\nPython的某些对象的同一种操作有多种方法，如对一个list进行排序，可以使用内置函数sorted和list.sort方法。不同的是，后者返回值是none，这以为排序操作是原址进行的，而不会像前一种一样会复制一个list出来，因而也会节省一些内存。\n\n用返回 None 来表示就地改动，这种做法其实有个弊端，那就是调用者无法将其串联起来，形成类似JavaScript常见的链式操作。Python中的str对象却有些特殊，它的所有方法都可以串联起来调用，从而形成连贯接口。当然究其原因，是因为str在Python中是一个不可变对象，就地改动也就行不通了。\n\n#### 尝试使用扁平序列\n\nPython中的序列包括list、tuple、str、bytes、bytearray等，可以大致分为两类，就是可以包含不同对象的容器类型，如list、tuple等，和只能包含同一种对象的扁平类型，如str、bytes、bytearray、memoryview 和 array.array等。\n\n容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。扁平序列一段连续的内存空间，所以更加紧凑，在绝大多数的情况下，它的操作效率是远高于容器序列的。\n\n比如，当需要创建一个只包含数字的列表，那么 array.array 比 list 高效多了。数组几乎支持所有list、tuple等可变序列所支持的操作，包括.pop、.insert 和 .extend等。另外，数组还提供从文件读取和存入文件的更快的方法，如.frombytes 和 .tofile。\n\n同样还有memoryview，亦即内存视图。它是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。它让你在不需要复制内容的前提下， 在数据结构之间共享内存。其中数据结构可以是任何形式，比如 PIL 图片、SQLite 数据库和 NumPy 的数组等。这个功能在处理大型数据集合的时候非常重要。memoryview.cast 的概念跟数组模块类似，能用不同的方式读写同一块内存数据，而且内容字节不会随意移动。这听上去又跟 C 语言中类型转换的概念差不多。memoryview.cast 会把同一块内存里的内容打包成一个全新的 memoryview 对象给你。\n\n内存视图是一个很微妙的类，要想熟练使用，必须对内存对其之类的计算机基础知识有扎实的掌握。下面是一个实例：\n```\nnumbers = array.array('h', [-2, -1, 0, 1, 2])\nmemv = memoryview(numbers)\nlen(memv)\n>>>: 5\nmemv[0]\n>>>: -2\n\nmemv_oct = memv.cast('B')\nmemv_oct.tolist()\n>>>: [254, 255, 255, 255, 0, 0, 1, 0, 2, 0]\nmemv_oct[5] = 4\nnumbers\n>>>: array('h', [-2, -1, 1024, 1, 2])\n```\n\n这里利用含有 5 个短整型有符号整数的数组(类型码是 'h'，对应C语言2字节有符号整数，32位系统中通常为short int)创建一个 memoryview。而此时，5 个元素跟数组里的没有区别。接下来把 memv 里的内容转换成 'B' 类型，也就是无符号字符类型，绑定到memv_oct。然后把memv_oct中位于位置 5 的字节赋值成 4。因为把占 2 个字节的整数的高位字节改成了 4，所以这个有符号整数的值就变成了 1024。再转换回去，得到最终的结果。利用 memoryview 和 struct 来操作二进制序列，不仅可以实现强大的功能，而且在时间效率和空间利用率上也是十分的高效。\n\n#### 在合适的场合使用具名元组\n\nPython中的映射类型采用了哈希表存储索引，一般来讲会消耗较多的空间，相比于数组或者list、tuple等类型，比较不经济。而在某些情景下，比如已知一个树形结构的字段的范围，就可以使用具名元组来替代dict。\n\ncollections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类。用 namedtuple 构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。这个实例甚至跟普通的对象实例比起来也要小一些，因为具名元组的实例没有```__dict__```，而其他对象一般需要```__dict__```来存放这些实例的属性。\n\n在《流畅的Python》中是这样使用具名元组的:\n```\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n```\n下面展示了使用具名元组来记录一个城市的信息。\n```\nfrom collections import namedtuple\nCity = namedtuple('City', 'name country population coordinates')\ntokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))\n\ntokyo\n>>>: City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))\n\ntokyo.population\n>>>: 36.933\n\ntokyo.coordinates\n>>>: (35.689722, 139.691667)\n\ntokyo[1]\n>>>: 'JP'\n```\n\n创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。存放在对应字段里的数据要以一串参数的形式传入到构造函数中，这与元组不同的是，后者的构造函数却只接受单一的可迭代对象。然后就可以通过字段名或者位置来获取一个字段的信息。\n\n除了从普通元组那里继承来的属性之外，具名元组还有一些自己专有的属性：\n\n* _fields: 返回一个包含这个类所有字段名称的元组\n* _make(): 通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟City(*delhi_data) 是一样的\n* _asdict() 把具名元组以 collections.OrderedDict 的形式返回，我们可以利用它来把元组里的信息友好地呈现出来\n\n使用具名元组在处理大数据量的场景下，能够节省大量内存。但之所以说在合适的场合使用具名元组，是因为具名元组并不能完全替代映射类型。一般来讲，映射类型对单个元素的访问速度极高，只要内存里放得下，随机访问的时间效率趋近O(1)。而具名元组这种序列在随机访问下，表现就比较糟糕，例如做\" in \"操作时，最坏需要把序列中所有的元素都遍历一遍，时间复杂度为O(n)。所以时间重要还是空间重要，这是一个权衡。\n\n#### 泛映射类型的效率\n\ndict是Python中最常见的映射类型，而且标准库里的所有映射类型都是利用 dict 来实现的，因此它们有个共同的限制，即只有可散列的数据类型才能用作这些映射里的键，也叫可哈希类型。可散列对象的定义包含两个条件，一是整个生命周期中它的散列值不变，第二个条件是这个对象需要实现 ```__hash__```() 方法来获取哈希值，并实现```__qe__```()方法和其他值做对比。如果两个可散列对象是相等的，那么它们的散列值一定是一样的。因此，不仅常见的原子不可变类型如str、bytes和数值类型可以作为dict的键，所有包含的元素都是可散列对象的tuple同样可以作为dict的键，如(1, 2, 3)等。\n\n##### 处理找不到的键\n* 使用```__missing__```\n\n\t所有的映射类型在处理找不到的键的时候，都会调用```__missing__```方法。也就是说，如果有一个类继承了 dict，然后这个继承类提供了 __missing__ 方 法，那么在 ```__getitem__``` 碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个 KeyError 异常。\n\n\t```__missing__``` 方法只会被 ```__getitem__``` 调用(比如在表达式 d[k] 中)。提供 ```__missing__``` 方法对 get 或者 ```__contains__```(in 运算符会用到这个方法)这些方法的使用没有影响。例如：\n\t```\n\tclass UserDict(dict):\n\t\tdef __missing__(self, key):\n\t\t\tprint key\n\t\t\treturn 0\n\n\td = UserDict()\n\tprint d[\"k\"]\n\t>>>: k\n\t0\n\n\tprint d.get(\"k\")\n\t>>>: None\n\t```\n\n* 使用setdefault\n\n\tdict中访问元素的方法有两种，一种是直接使用下标形如d[k]来访问，另一种是使用d.get(k)。第一种方法的效率更高，所以在需要大量访问dict元素的场合，这种形式能够节约大量的开销。然而这种方式在遇到找不到该键的时候会抛出恼人的KeyError异常。所以在不能确保key是否包含在d中的时候，一般更倾向于使用后者。\n\n\t下例是一个常见的操作：\n```\n# d={...: ... }\ndata = d.get(\"data\", [])\ndata.append(\"x...\")\nd[\"data\"] = data\n```\n这完全可以改写成：\n```\nd.setdefault(\"data\", []).append(\"x...\")\n```\nsetdefault的作用是获取键为\"data\"的元素，如果不存在则设置为[]，再将该[]返回。这种写法不仅更紧凑，而且减少了一次对dict的访问。\n\n对于dict和list等的效率，《流畅的Python》中做了一个测试，在 core i7的CPU上，分别从含有1000个键、1万个、……1千万个键的dict中，取1000个元素，测试消耗时间。在只有1000个键的dict中取1000个元素，平均每个消耗202微秒，在1千万个键的dict中取1000个元素，平均每个也只消耗了337微秒。而换成list之后，花费分别变为20毫秒和97秒。而理解了dict使用哈希表来实现的事实之后，也就不奇怪了。\n\n所以对于dict有以下特性：\n\n* 键必须可哈希。需要注意的是，所有由用户自定义的对象默认都是可散列的，因为它们的散列值由 id() 来获取，而且它们 都是不相等的\n* 字典在内存上的开销巨大。由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上的效率低下，所以字典并不是在任何时候都是合适的\n* 键查询很快。字典类型有着巨大的内存开销，但保证了数据量呈数量级的规模增长时，查询时间的开销仅仅常数级增多\n* 键的次序取决于添加顺序。当往 dict 里添加新键而又发生散列冲突的时候，新键可能会被安排存放到另一个位置，从而造成键值得无序\n* 往字典里添加新键可能会改变已有键的顺序。无论何时往字典里添加新的键，Python 解释器都可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里，这个过程中可能会发生新的散列冲突，导致新散列表中键的次序变化",
"title": "一些Python编程技巧",
"category": "学习笔记",
"tags": [
"编程",
"Python"
],
"preview": "",
"first_figure": "/static/blog/img/preview_1.jpg"
},
"20150426": {
"create_time": "2015年4月26日",
"id": 20150426,
"content": "##函数\n　　当编写一个大型程序的时候，将不同的工作分配给不同的模块函数来完成，是一个明智的做法。当一个函数调用另一个函数的时候，如果被调用的函数声明需要传递一些参数才能工作，则传递给它的参数是某些变量、常量的副本，也就是说，函数的调用时传递数据是通过按值传递机制来进行的。实际的参数并没有传递给被调用的函数，这样一来可以有效的保护实参不被篡改。但有时确实要修改实参，这时，我们有以下几种办法让函数来操作实参。\n\n##给函数传递指针实参和引用实参\n　　一个经典的例子：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid exchange(int* a, int* b){\n\t\t\tint temp(0);\n\t\t\ttemp = *b;\n\t\t\t*b = *a;\n\t\t\t*a = temp;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tint x(10),y(20);\n\t\t\texchange(&x,&y);\n\t\t\tcout<<x << ','<<y\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序输出：20,10。程序的作用是给两个变量调换数值。同样，可以通过传递引用实参来使函数操作实参：\t\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid exchange(int& a, int& b){\n\t\t\tint temp(0);\n\t\t\ttemp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tint x(10),y(20);\n\t\t\texchange(x,y);\n\t\t\tcout<<x << ','<<y\n\t\t\t\t<<endl;\n\t\t}\n\n　　两次运行程序结果相同。因为在我们给函数传递指针实参的时候，系统会给函数传递一个指针的副本，但这个指针副本指向的地址和实参指向的是同一区域，因为我们可以在函数中操作实参。\n\n　　数组是唯一不能按值传递的数据类型，传递给函数的是该数组首个元素的指针的副本。因此，在函数中大可以随意操作指针副本，而不必担心数组的指针发生改变。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid change(int a[])\n\t\t{\n\t\t\ta++;\n\t\t\tcout<<a\n\t\t\t\t<<endl;\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tint x[10];\n\n\t\t\tcout<<x\n\t\t\t\t<<endl;\n\n\t\t\tchange(x);\n\n\t\t\tcout<<x\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序会输出三个地址，而第一行的值等于第三行，第二行的值等于第一行的值+4。虽然在函数change()中对数组的地址经行了递增操作，显然操作的只是传递给函数change的指针副本，因此实参数组x[]的地址并未改变。\n\n##给函数传递不确定数量的实参\n　　有时候，我们需要给函数传递不确定数量的实参，这时该怎么办呢？可以分析下面的程序：\n\n\t\t#include<iostream>\n\t\t#include<cstdarg>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid sum(int count, ...){\n\n\t\t\tva_list pArgument;\n\t\t\tva_start(pArgument,count);\n\n\t\t\tint a = 0;\n\t\t\tfor(int i=0;i<count;i++)\n\t\t\t{\n\t\t\t\ta = va_arg(pArgument,int);\n\t\t\t\tcout << a << endl;\t\n\t\t\t}\n\t\t\tva_end(pArgument);\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tsum(7,1,2,3,4,5,7,6);\n\t\t}\n\n　　应该注意到，此次在程序中包含了<cstdarg>头文件。其中，sum()函数的作用是，把传入的每个实参输出显示。程序运行结果：\n\n\t\t1\n\t\t2\n\t\t3\n\t\t4\n\t\t5\n\t\t7\n\t\t6\n\n　　省略号代表可以传递任意多的实参到函数sum(),但使用时必须确定数量。上面用count来表示传入的实参数量，另一种确定传入实参数量的办法是，给最后一个实参打上特殊标记，在函数中检查和识别。\n\n　　函数在运行时，首先创建了一个va_list型的指针pArguement，用来依次指向各个实参。然后调用va_start()函数来初始化pArguement，使其指向第一个实参。在for循环中，va_arg的宏返回pArguement指向的实参值，其中第二个参数int是返回实参值的类型。最后使用va_end来释放pArguement指针，使其指向一个空值，函数结束。\n\n　　",
"layout": "post",
"title": "学习C++之四：让函数操作实参",
"category": "学习笔记",
"description": "让函数做更多的事情",
"preview": "当编写一个大型程序的时候，将不同的工作分配给不同的模块函数来完成，是一个明智的做法。当一个函数调用另一个函数的时候，如果被调用的函数声明需要传递一些参数才能工作，则传递给它的参数是某些变量、常量的副本，也就是说，函数的调用时传递数据是通过按值传递机制来进行的。实际的参数并没有传递给被调用的函数，这样一来可以有效的保护实参不被篡改。但有时确实要修改实参，这时，我们有以下几种办法让函数来操作实参。\n\n##给函数传递指针实参和引用实参\n　　一个经典的例子：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid exchange(int* a, int* b){\n\t\t\tint temp(0);\n\t\t\ttemp = *b;\n\t\t\t*b = *a;\n\t\t\t*a = temp;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tint x(10),y(20);\n\t\t\texchange(&x,&y);\n\t\t\tcout<<x << ','<<y\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序输出：20,10。程序的作用是给两个变量调换数值。同样，可以通过传递引用实参来使函数操作实参：\t\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid exchange(int& a, int& b){\n\t\t\tint temp(0);\n\t\t\ttemp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\tvoid main(void){\n\t\t\tint x(10),y(20);\n\t\t\texchange(x,y);\n\t\t\tcout<<x << ','<<y\n\t\t\t\t<<endl;\n\t\t}\n\n　　两次运行程序结果相同。因为在我们给函数传递指针实参的时候，系统会给函数传递一个指针的副本，但这个指针副本指向的地址和实参指向的是同一区域，因为我们可以在函数中操作实参。\n\n　　数组是唯一不能按值传递的数据类型，传递给函数的是该数组首个元素的指针的副本。因此，在函数中大可以随意操作指针副本，而不必担心数组的指针发生改变。运行下面程序：\n\n\t\t#include<iostream>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid change(int a[])\n\t\t{\n\t\t\ta++;\n\t\t\tcout<<a\n\t\t\t\t<<endl;\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tint x[10];\n\n\t\t\tcout<<x\n\t\t\t\t<<endl;\n\n\t\t\tchange(x);\n\n\t\t\tcout<<x\n\t\t\t\t<<endl;\n\t\t}\n\n　　程序会输出三个地址，而第一行的值等于第三行，第二行的值等于第一行的值+4。虽然在函数change()中对数组的地址经行了递增操作，显然操作的只是传递给函数change的指针副本，因此实参数组x[]的地址并未改变。\n\n##给函数传递不确定数量的实参\n　　有时候，我们需要给函数传递不确定数量的实参，这时该怎么办呢？可以分析下面的程序：\n\n\t\t#include<iostream>\n\t\t#include<cstdarg>\n\t\tusing std::cout;\n\t\tusing std::endl;\n\n\t\tvoid sum(int count, ...){\n\n\t\t\tva_list pArgument;\n\t\t\tva_start(pArgument,count);\n\n\t\t\tint a = 0;\n\t\t\tfor(int i=0;i<count;i++)\n\t\t\t{\n\t\t\t\ta = va_arg(pArgument,int);\n\t\t\t\tcout << a << endl;\t\n\t\t\t}\n\t\t\tva_end(pArgument);\n\t\t}\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tsum(7,1,2,3,4,5,7,6);\n\t\t}\n\n　　应该注意到，此次在程序中包含了<cstdarg>头文件。其中，sum()函数的作用是，把传入的每个实参输出显示。程序运行结果：\n\n\t\t1\n\t\t2\n\t\t3\n\t\t4\n\t\t5\n\t\t7\n\t\t6\n\n　　省略号代表可以传递任意多的实参到函数sum(),但使用时必须确定数量。上面用count来表示传入的实参数量，另一种确定传入实参数量的办法是，给最后一个实参打上特殊标记，在函数中检查和识别。\n\n　　函数在运行时，首先创建了一个va_list型的指针pArguement，用来依次指向各个实参。然后调用va_start()函数来初始化pArguement，使其指向第一个实参。在for循环中，va_arg的宏返回pArguement指向的实参值，其中第二个参数int是返回实参值的类型。最后使用va_end来释放pArguement指针，使其指向一个空值，函数结束。\n\n　　",
"first_figure": "/static/blog/img/preview_2.jpg"
}
};window.articleIdList=[20180625, 20180408, 20180401, 20180101, 20171103, 20171020, 20170928, 20170919, 20170808, 20170626, 20170525, 20170410, 20170407, 20170312, 20170308, 20170307, 20170306, 20170305, 20170203, 20170202, 20170127, 20161225, 20161128, 20161027, 20160904, 20160826, 20160821, 20160811, 20160315, 20151120, 20151026, 20150927, 20150910, 20150712, 20150710, 20150629, 20150628, 20150508, 20150503, 20150430, 20150429, 20150428, 20150426, 20150424, 20150423, 20150419, 20150128, 20150121, 20150117, 20150110, 20141103, 20120921]